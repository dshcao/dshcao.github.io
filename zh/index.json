[
{
	"uri": "https://dshcao.github.io/zh/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/",
	"title": "文章",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Post page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-imagecropview/",
	"title": "自定义view-ImageCropView",
	"tags": ["android", "自定义view"],
	"categories": [],
	"series": ["自定义view"],
	"description": "一个文件实现自定义头像裁剪控件",
	"content": "项目中需要为用户截取头像，刚开始调用系统自带功能，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  Intent intent = new Intent(\u0026#34;com.android.camera.action.CROP\u0026#34;); intent.setDataAndType(Uri.fromFile(new File(itemData.getPath())), \u0026#34;image/*\u0026#34;); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); // crop=true是设置在开启的Intent中设置显示的VIEW可裁剪 intent.putExtra(\u0026#34;crop\u0026#34;, \u0026#34;true\u0026#34;); // aspectX aspectY 是宽高的比例 intent.putExtra(\u0026#34;aspectX\u0026#34;, 1); intent.putExtra(\u0026#34;aspectY\u0026#34;, 1); // outputX outputY 是裁剪图片宽高 intent.putExtra(\u0026#34;outputX\u0026#34;, 350); intent.putExtra(\u0026#34;outputY\u0026#34;, 350); intent.putExtra(\u0026#34;scale\u0026#34;, true); intent.putExtra(\u0026#34;noFaceDetection\u0026#34;, false);//取消人脸识别功能 intent.putExtra(\u0026#34;outputFormat\u0026#34;, Bitmap.CompressFormat.PNG.toString()); //true则图片在intent中返回，如果图片过大，会导致oom，这里设置为false intent.putExtra(\u0026#34;return-data\u0026#34;, false); File avatar = new File(getExternalFilesDir(Environment.DIRECTORY_PICTURES), AppConfig.Path.AVATAR); // FileProvider.getUriForFile(AvatarPickerActivity.this, getPackageName() + \u0026#34;.provider\u0026#34;, new File(itemData.getPath())); Uri outputUri = Uri.fromFile(avatar);//裁剪后输出位置 intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri); startActivityForResult(intent, REQUEST_CROP);   但使用过程中发现各手机ui不一致，更严重的是发现锤子手机有问题，锤子手机缩放图片后截取的图像仍是未缩放时的区域，然后就一顿搜索发现github上有不少这个项目，但效果不满意，且实现复杂，就这一个功能拆成N个文件。\n代码讲究 高内聚 低耦合 可重用\n最终目的方便维护\n首先分析如何实现：\n重写onDraw添加自己的逻辑代码，画一层蒙板，蒙板要覆盖整个imageview,周围是半透明，中间是方形或者圆形透明区域，可以用Path实现，还需要手势支持，所以还要用到GestureDetector ScaleGestureDetector，另外图片大小不一，第一次加载到imageview中肯定不是原尺寸，要经过缩放，那我们缩放到什么程度呢？因为我们截图不能使图像缩放小于中间透明区域，所以我们规定初次加载图像最短边缩放到中间透明区域，这里图片说明，这里还用到Matrix从来缩放图像,不太了解的可先看下文档谷歌一下\n首先为了使用方便自定义属性：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;declare-styleable name=\u0026#34;ImageCropView\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;aspectX\u0026#34; format=\u0026#34;integer\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;aspectY\u0026#34; format=\u0026#34;integer\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewStrokeColor\u0026#34; format=\u0026#34;color|reference\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewStrokeWidth\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewShape\u0026#34; format=\u0026#34;enum\u0026#34;\u0026gt; \u0026lt;enum name=\u0026#34;square\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;enum name=\u0026#34;circle\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/attr\u0026gt; \u0026lt;/declare-styleable\u0026gt;   自定义注解取代枚举\nViewShape\n1 2 3 4 5 6 7 8  @Retention(AnnotationRetention.SOURCE) @IntDef(SQUARE, CIRCLE) annotation class ViewShape(val value: Int = CIRCLE) { companion object { const val SQUARE = 1 const val CIRCLE = 1 shl 1 } }   ImageCropView\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117  class ImageCropView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : AppCompatImageView(context, attrs, defStyleAttr), ViewTreeObserver.OnGlobalLayoutListener, ScaleGestureDetector.OnScaleGestureListener { @ViewShape var viewShape = ViewShape.CIRCLE//透明区域形状  private var viewStrokeWidth: Float = 1f//透明区域Stroke宽度  private var viewStrokeColor: Int = Color.WHITE//透明区域Stroke颜色  private var viewMaskColor: Int = Color.parseColor(\u0026#34;#77000000\u0026#34;)//半透明区域颜色  var aspectX: Int = 1//宽高比  var aspectY: Int = 1//宽高比  private val touchSlop: Int var overViewOffset = RectF() private var overViewSpace: Int = 0//透明区域与控件边缘的space  private var imageSpace: Int = 0//  private val paint: Paint//半透明区域  private val paintS: Paint//stroke  private var gestureDetector: GestureDetector private var scaleGestureDetector: ScaleGestureDetector var mValues = FloatArray(9) var mMatrix = Matrix() var initScale: Float = 0f var minScale: Float = 0f var maxScale: Float = 0f var max = 6 var overViewPath = Path() var overView = RectF() init { if (attrs != null) { val a = context.obtainStyledAttributes(attrs, R.styleable.ImageCropView) viewStrokeWidth = a.getDimension(R.styleable.ImageCropView_viewStrokeWidth, viewStrokeWidth) viewStrokeColor = a.getColor(R.styleable.ImageCropView_viewStrokeColor, viewStrokeColor) viewMaskColor = a.getColor(R.styleable.ImageCropView_viewStrokeColor, viewMaskColor) aspectX = a.getInt(R.styleable.ImageCropView_aspectX, aspectX) aspectY = a.getInt(R.styleable.ImageCropView_aspectY, aspectY) viewShape = if (aspectX != aspectY) ViewShape.SQUARE else viewShape a.recycle() } touchSlop = ViewConfiguration.get(context).scaledTouchSlop setLayerType(View.LAYER_TYPE_SOFTWARE, null) scaleType = ScaleType.MATRIX paint = Paint(Paint.ANTI_ALIAS_FLAG) paint.color = viewMaskColor paintS = Paint(Paint.ANTI_ALIAS_FLAG) paintS.color = viewStrokeColor paintS.style = Paint.Style.STROKE paintS.strokeWidth = viewStrokeWidth if (overViewSpace == 0) overViewSpace = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 42f, resources.displayMetrics) .toInt() imageSpace = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1f, resources.displayMetrics) .toInt() val gestureListener: SimpleOnGestureListener = object :SimpleOnGestureListener() { override fun onDoubleTap(e: MotionEvent): Boolean { //双击时若当前缩放小于最大缩放的一半时就缩放到最大，反之回到到初始加载的缩放  val currScale: Float = getCurrentScale() val midScale: Float = maxScale / (max / 2f) if (currScale \u0026lt; midScale) { val rScale = midScale / currScale scale(rScale, rScale, e.x, e.y) } else { val rScale: Float = initScale / currScale scale(rScale, rScale, e.x, e.y) } return true } override fun onScroll( e1: MotionEvent, e2: MotionEvent, distanceX: Float, distanceY: Float ): Boolean { val dx: Float val dy: Float val matrixRectF: RectF = getMatrixRectF() //滑动时判断滑动的距离是否超出中间透明区域，取两者最小值，即最多只能滑动到透明区域边缘  if (distanceX \u0026lt; 0) { dx = distanceX.coerceAtLeast(matrixRectF.left - overViewOffset.left) } else { dx = distanceX.coerceAtMost(matrixRectF.right - overViewOffset.right) } if (distanceY \u0026lt; 0) { dy = distanceY.coerceAtLeast(matrixRectF.top - overViewOffset.top) } else { dy = distanceY.coerceAtMost(matrixRectF.bottom - overViewOffset.bottom) } translate(-dx, -dy) return true } } gestureDetector = GestureDetector(context, gestureListener) scaleGestureDetector = ScaleGestureDetector(context, this) } ....暂时省略 }   onGlobalLayout中确定初始值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  override fun onAttachedToWindow() { super.onAttachedToWindow() viewTreeObserver.addOnGlobalLayoutListener(this) } //onGlobalLayout作用是获取构造函数中获取不到的尺寸以便确定初始缩放大小 //最大最小缩放根据初始缩放决定 override fun onGlobalLayout() { val drawable = drawable ?: return val scale: Float val viewWidth = width val viewHeight = height val overViewSize: Int = Math.min(viewWidth, viewHeight) - overViewSpace * 2 val drawableWidth = drawable.intrinsicWidth val drawableHeight = drawable.intrinsicHeight //build overview path  overViewPath.addRect( 0f, 0f, viewWidth.toFloat(), viewHeight.toFloat(), Path.Direction.CCW ) val circlePath = Path() val radius = overViewSize / 2.toFloat() if (viewShape == ViewShape.CIRCLE) { circlePath.addCircle( viewWidth / 2.toFloat(), viewHeight / 2.toFloat(), radius, Path.Direction.CCW ) } else { circlePath.addRect( viewWidth / 2f - radius, viewHeight / 2f - radius, viewWidth / 2f + radius, viewHeight / 2f + radius, Path.Direction.CCW ) } overViewPath.op(circlePath, Path.Op.XOR) overView.set( viewWidth / 2f - radius, viewHeight / 2f - radius, viewWidth / 2f + radius, viewHeight / 2f + radius ) overViewOffset.set(overView) overViewOffset.inset(-imageSpace.toFloat(), -imageSpace.toFloat()) //calculate the scale  scale = (overViewSize + imageSpace * 2) * 1f / Math.min( drawableWidth, drawableHeight ) initScale = scale minScale = initScale maxScale = minScale * max //calculate the delta move to center  val dx = viewWidth / 2 - drawableWidth / 2 val dy = viewHeight / 2 - drawableHeight / 2 mMatrix.postTranslate(dx.toFloat(), dy.toFloat()) mMatrix.postScale(initScale, initScale, viewWidth / 2.toFloat(), viewHeight / 2.toFloat()) imageMatrix = mMatrix //初始测量一次就够了  viewTreeObserver.removeOnGlobalLayoutListener(this) }   onDraw\n1 2 3 4 5 6 7 8 9 10 11 12  override fun onDraw(canvas: Canvas?) { super.onDraw(canvas) //画蒙层  canvas!!.drawPath(overViewPath, paint) //画stroke  if (viewStrokeWidth \u0026gt; 0) { canvas.drawCircle( overView.centerX(), overView.centerY() , (overView.width() + viewStrokeWidth) / 2, paintS ) } }   缩放处理逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  override fun onScale(detector: ScaleGestureDetector?): Boolean { val currScale = getCurrentScale() var scaleFactor = detector!!.scaleFactor //主要是判断不能小于最小缩放值，不能大于最大缩放值  scaleFactor = if (scaleFactor \u0026lt; 1 \u0026amp;\u0026amp; currScale \u0026gt; minScale) { Math.max(scaleFactor, minScale / currScale) } else if (scaleFactor \u0026gt; 1 \u0026amp;\u0026amp; currScale \u0026lt; maxScale) { Math.min(scaleFactor, maxScale / currScale) } else { 1f } if (scaleFactor != 1f) { scale(scaleFactor, scaleFactor, detector.focusX, detector.focusY) } return true }   裁剪图片,这里可以替换其他方式，提高效率,这里使用中够用，暂时这样处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  fun crop(file: File, outputX: Int, outputY: Int): Boolean { val bitmap = cropImage(outputX, outputY) ?: return false try { if (!file.exists()) { if (!file.parentFile.mkdirs() || !file.createNewFile()) { return false } } val fos = FileOutputStream(file) //java 中可以直接bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos)  //kotlin中报错，必须work线程中处理  val thread = Thread(Runnable { bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos) }) thread.join() fos.flush() fos.close() bitmap.recycle() return true } catch (e: Exception) { e.printStackTrace() } return false } fun cropImage(outputX: Int, outputY: Int): Bitmap? { val drawable = (drawable ?: return null) as? BitmapDrawable ?: return null val scale = getCurrentScale() val mRectF = getMatrixRectF() val w: Float = overView.width() / scale val h: Float = overView.height() / scale val left: Float = (overView.left - mRectF.left) / scale val top: Float = (overView.top - mRectF.top) / scale val srcBmp = drawable.bitmap val cropBmp = Bitmap.createBitmap( srcBmp, left.toInt(), top.toInt(), w.toInt(), h.toInt() ) val bmp = Bitmap.createScaledBitmap(cropBmp, outputX, outputY, false) cropBmp.recycle() return bmp }   最开始写这个控件的时候是java，写文章的时候重写改成kotlin，继承OnScaleGestureListener ,onScaleEnd这里原不需要逻辑，结果kotlin自动生成TODO(\u0026quot;not implemented\u0026quot;) ，这个标志必须删除，不然缩放的时候会崩溃。。。\noverride fun onScaleEnd(detector: ScaleGestureDetector?) {\nTODO(\u0026ldquo;not implemented\u0026rdquo;) //To change body of created functions use File | Settings | File Templates.\n}\n 源码\n "
},
{
	"uri": "https://dshcao.github.io/zh/series/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/renderscript%E4%BD%BF%E7%94%A8/",
	"title": "Android RenderScript使用",
	"tags": ["android"],
	"categories": [],
	"series": ["renderscript"],
	"description": "Android RenderScript详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BBtransition/",
	"title": "Android 转场动画Transition",
	"tags": ["android", "animation"],
	"categories": [],
	"series": ["android"],
	"description": "Android 转场动画Transition详解.",
	"content": "Transition Android中Transition是两个场景(Scene)之间的一个过渡转场动画效果。\nTransition有两个构造函数\n1 2 3 4 5 6  //代码创建 public Transition() {} //从res/transition资源文件加载创建 public Transition(Context context, AttributeSet attrs) { ... }   如：\n1 2 3 4 5 6 7 8  \u0026lt;transitionSet xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;changeBounds/\u0026gt; \u0026lt;fade android:fadingMode=\u0026#34;fade_in\u0026#34; android:duration=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target android:targetId=\u0026#34;@id/transition_title\u0026#34; /\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/fade\u0026gt; \u0026lt;/transitionSet\u0026gt;   TransitionManager.changeScene/TransitionManager.beginDelayedTransition-\u0026gt;\nsceneChangeRunTransition\nsceneChangeRunTransition中为sceneRoot设置监听器监听onPreDraw，在onPreDraw调用transition.playTransition-\u0026gt;runAnimators\nPathMotion 1 2 3 4 5  public abstract class PathMotion { public PathMotion() {} public PathMotion(Context context, AttributeSet attrs) {} public abstract Path getPath(float startX, float startY, float endX, float endY); }   Scene和TransitionInflater/TransitionManager Scene 场景，即UI状态\nTransitionInflater 初始化Scene或TransitionManager\nTransitionManager 控制Scene使用某个Transition动画效果转换\n new Scene() Scene.getSceneForLayout scene.enter() scene.exit() TransitionInflater.from(context).inflateTransition() TransitionInflater.from(context).inflateTransitionManager() TransitionManager.go() 默认transition效果是AutoTransition，也可以指定其他Transition实现 transitionManager.transitionTo()  Transition 的实现  TransitionSet 多个transition(TransitionSet也是transition)的集合，TransitionSet是集合子transition的parent，通过ORDERING_TOGETHER和ORDERING_SEQUENTIAL两种play方式实现复杂的转场效果。TransitionSet对子transitions管理  AutoTransition 继承自TransitionSet并使用初始化的指定效果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class AutoTransition extends TransitionSet { public AutoTransition() { init(); } public AutoTransition(Context context, AttributeSet attrs) { super(context, attrs); init(); } private void init() { setOrdering(ORDERING_SEQUENTIAL); addTransition(new Fade(Fade.OUT)). addTransition(new ChangeBounds()). addTransition(new Fade(Fade.IN)); } }      ChangeBounds Scene改变前后布局边界转场动画 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * Setting this flag tells ChangeBounds to track the before/after parent * of every view using this transition. The flag is not enabled by * default because it requires the parent instances to be the same * in the two scenes or else all parents must use ids to allow * the transition to determine which parents are the same. * * @param reparent true if the transition should track the parent * container of target views and animate parent changes. * @deprecated Use {@link android.transition.ChangeTransform} to handle * transitions between different parents. */ @Deprecated public void setReparent(boolean reparent) { mReparent = reparent; }    ChangeTransform Scene改变前后视图缩放和旋转动画 ChangeClipBounds Scene改变前后视图clipBounds边界转场动画 ChangeImageTransform Scene改变前后imageView matrix变换动画 ChangeScroll Scene改变前后view x/y上滚动变换动画 Visibility Scene改变前后view visibility变换动画  Slide Scene改变前后根据视图可见性，操作视图translationX/translationY将视图从场景某个边缘移入或移出 Explode Scene改变前后根据视图可见性，操作视图translationX/translationY将视图从场景边缘移入或移出,其中移入动画源码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public Animator onAppear(ViewGroup sceneRoot, View view, TransitionValues startValues, TransitionValues endValues) { if (endValues == null) { return null; } Rect bounds = (Rect) endValues.values.get(PROPNAME_SCREEN_BOUNDS); float endX = view.getTranslationX(); float endY = view.getTranslationY(); calculateOut(sceneRoot, bounds, mTempLoc); float startX = endX + mTempLoc[0]; float startY = endY + mTempLoc[1]; return TranslationAnimationCreator.createAnimation(view, endValues, bounds.left, bounds.top, startX, startY, endX, endY, sDecelerate, this); }    Fade Scene改变前后视图transitionAlpha变换动画 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private Animator createAnimation(final View view, float startAlpha, final float endAlpha) { if (startAlpha == endAlpha) { return null; } view.setTransitionAlpha(startAlpha); final ObjectAnimator anim = ObjectAnimator.ofFloat(view, \u0026#34;transitionAlpha\u0026#34;, endAlpha); if (DBG) { Log.d(LOG_TAG, \u0026#34;Created animator \u0026#34; + anim); } final FadeAnimatorListener listener = new FadeAnimatorListener(view); anim.addListener(listener); addListener(new TransitionListenerAdapter() { @Override public void onTransitionEnd(Transition transition) { view.setTransitionAlpha(1); transition.removeListener(this); } }); return anim; }       自定义Transition 过渡动画Transition需要捕获两个Sence之间的差异并使用属性动画实现过渡。属性动画是更改指定时间段内的起始值和结束值之间的视图属性，因此Transition框架需要同时具有属性的起始值和结束值才能构建动画，可参考官方文档创建自定义过渡动画\n 捕获初始值 override fun captureStartValues(transitionValues: TransitionValues)  Transition有两个抽象方法，一个空方法需要实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class CustomTransition : Transition() { // package_name:transition_name:property_name  private val PROPNAME_BACKGROUND = \u0026#34;com.example.android.customtransition:CustomTransition:background\u0026#34; override fun captureStartValues(transitionValues: TransitionValues) { captureValues(transitionValues) } override fun captureEndValues(transitionValues: TransitionValues) { captureValues(transitionValues) } private fun captureValues(transitionValues: TransitionValues) { transitionValues.values[PROPNAME_BACKGROUND] = view.background } override fun createAnimator( sceneRoot: ViewGroup, startValues: TransitionValues?, endValues: TransitionValues? ): Animator? { return super.createAnimator(sceneRoot, startValues, endValues) } ... }   ActivityOptions \u0026amp; Activity的过渡动画 Activity的过渡动画是建立在Transition的基础上的。进入动画/退出动画/共享元素动画都是一个transition。Activity的过渡动画主要包含：\n 进入动画/退出动画 必须是继承Visibility的Transition，Android中的实现有Slide Explode Fade 共享元素动画 activity视图中的过渡元素，Android中的实现有ChangeBounds ChangeClipBounds ChangeTransform ChangeImageTransform ChangeScroll等 API分析    window.enterTransition A-\u0026gt;B B中View的动画\n  window.exitTransition A-\u0026gt;B A中View的动画\n  window.returnTransition A-\u0026gt;B 再从B退到A，B中View的动画\n  window.reenterTransition A-\u0026gt;B 再从B退到A，A中View的动画\n  window.sharedElementEnterTransition 针对共享元素的，时机同window.enterTransition\n  window.sharedElementExitTransition 针对共享元素的，时机同window.exitTransition\n  window.sharedElementReturnTransition 针对共享元素的，时机同window.returnTransition\n  window.sharedElementReenterTransition 针对共享元素的，时机同window.reenterTransition\n  ActivityOptions.makeSceneTransitionAnimation() 设置共享元素，此处传递的A中的view和transitionName会与B中有相同transitionName的View做动画，即以A中的某个transitionName的view状态作为初始Sence，以B中该transitionName的view状态作为最终Sence做动画\n  activity.postponeEnterTransition() 延迟EnterTransition，使用场景：图片选择activity进入图片查看activity,图片查看activity的共享元素ImageView需要下载大图资源，显示大图前无法确定ImageView大小，此时可以用postponeEnterTransition()延迟动画，下载完成后调用startPostponedEnterTransition()开启动画。但这也会造成一个问题：如果下载时间较长，下载完成前EnterTransition动画会卡住一段时间，可以使用占位图片等方式配合解决\n  activity.supportPostponedEnterTransition() 支持库版本，会判定版本号是否执行activity.postponeEnterTransition()\n  activity.startPostponedEnterTransition() 配合activity.postponeEnterTransition()使用，开启EnterTransition\n  activity.supportStartPostponedEnterTransition() 支持库版本，会判定版本号是否执行activity.supportStartPostponedEnterTransition()\n  activity.finishAfterTransition()\n  window.transitionManager/activity.contentTransitionManager\n  window.contentScene/activity.contentScene windown content的Sence，activity需要设置window.requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)，否则window.contentScene为null\n  window.allowEnterTransitionOverlap true尽快执行过渡动画，false会等待A的exitTransition执行完执行完再执行B的enterTransition\n  window.allowReturnTransitionOverlap true尽快执行过渡动画，false会等待B的exitTransition执行完再执行A的reenterTransition\n  Activity方法onActivityReenter(resultCode: Int, data: Intent?)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * Called when an activity you launched with an activity transition exposes this * Activity through a returning activity transition, giving you the resultCode * and any additional data from it. This method will only be called if the activity * set a result code other than {@link #RESULT_CANCELED} and it supports activity * transitions with {@link Window#FEATURE_ACTIVITY_TRANSITIONS}. * * \u0026lt;p\u0026gt;The purpose of this function is to let the called Activity send a hint about * its state so that this underlying Activity can prepare to be exposed. A call to * this method does not guarantee that the called Activity has or will be exiting soon. * It only indicates that it will expose this Activity\u0026#39;s Window and it has * some data to pass to prepare it.\u0026lt;/p\u0026gt; * * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \u0026#34;extras\u0026#34;). */ public void onActivityReenter(int resultCode, Intent data) { }     Window.FEATURE_CONTENT_TRANSITIONS\n1 2 3 4 5 6 7 8 9 10 11  /** * Flag for requesting that window content changes should be animated using a * TransitionManager. * * \u0026lt;p\u0026gt;The TransitionManager is set using * {@link #setTransitionManager(android.transition.TransitionManager)}. If none is set, * a default TransitionManager will be used.\u0026lt;/p\u0026gt; * * @see #setContentView */ public static final int FEATURE_CONTENT_TRANSITIONS = 12;     Window.FEATURE_ACTIVITY_TRANSITIONS\n1 2 3 4 5 6 7 8  /** * Enables Activities to run Activity Transitions either through sending or receiving * ActivityOptions bundle created with * {@link android.app.ActivityOptions#makeSceneTransitionAnimation(android.app.Activity, * android.util.Pair[])} or {@link android.app.ActivityOptions#makeSceneTransitionAnimation( * android.app.Activity, View, String)}. */ public static final int FEATURE_ACTIVITY_TRANSITIONS = 13;     Fragment的过渡动画 Fragment中有类似Activity的方法，区别是：\nvar transaction: FragmentTransaction = supportFragmentManager.beginTransaction()\ntransaction.addSharedElement()//添加共享元素\ntransaction在added, removed, attached, detached, shown,hidden等触发transition过渡动画\n 源码\n 参考：\n 创建自定义过渡动画 用开源项目ActivityOptionsICS让ActivityOptions的动画实现兼容  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-handler%E8%A7%A3%E6%9E%90/",
	"title": "Android源码解析-Handler",
	"tags": ["android", "handler"],
	"categories": [],
	"series": ["源码解析"],
	"description": "android Handler机制详解.",
	"content": "前言 Handler使Android中非常重要的组成部门，很多地方包括系统服务也大量用到Handler这一机制。Handler让我们的开发难度大大降低，几乎看不到多线程死锁问题。\nHandler常见问题  Handler使用不当导致内存泄漏 在子线程创建Handler需要为该Handler准备Looper(调用Looper.prepare()、Looper.loop())，在主线程则不需要(系统帮我们做了) Handler处理消息过程中页面可能已销毁，此时页面控件已经不在，此时更新控件可能空指针异常。  Handler机制源码解析 Handler机制涉及到:Handler、Looper、MessageQueue、Message、ThreadLocal\nHandler  Handler(Looper, Callback, boolean) hide方法，最后一个参数是设置分发的是否是异步消息 1 2 3 4 5 6  public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; }    sendMessage(Message) 发送一个消息 sendMessageDelayed(Message, long) 发送一个延迟消息 sendMessageAtTime(Message, long) 发送一个在指定时间点分发的消息 sendMessageAtFrontOfQueue(Message) 在消息队列队首插入一个消息(消息的when=0，即分发时间是当前时间。) sendEmptyMessage(int) 发送一个空消息 sendEmptyMessageDelayed(int, long) 发送一个延迟空消息 sendEmptyMessageAtTime(int, long) 发送一个在指定时间点分发的空消息 enqueueMessage(MessageQueue, Message,long) 将消息入队。这里有亮点需要注意：1.msg.target = this; 2.msg.setAsynchronous(true); 1 2 3 4 5 6 7 8 9 10 11 12 13  private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,long uptimeMillis) { //为msg设置target，我们一般编程发送消息都会走到这里，即我们所发送的消息都会有target  //这是和后面介绍的屏障消息的重要区别。  msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); //如果创建的Handler是异步Handler，那么其发送的所有消息都将是异步消息  //创建异步Handler在API28才对开发者开放。  if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); }    hasMessages(int, Object) 知否存在指定的消息 removeMessages(int, Object) 移除指定消息 hasCallbacks(Runnable) 是否存在指定callback的消息 removeCallbacks(Runnable, Object) 移除指定队列消息包含callback且obj=Object的消息，若Object==null，则不对比Message的obj。 post(Runnable) 发送一个callback消息 postAtFrontOfQueue(Runnable) 类似post。  Message Message分为两类：同步消息、异步消息。异步消息优先级高于同步消息。在屏障消息机制下异步消息会优先于同步消息执行。所谓屏障消息是一种特殊(target==null)的消息，用于保证异步消息的优先执行。屏障消息的本质就是告诉MessageQueue#next操作我这个队列中有异步消息，你快去循环出来优先执行。\nMessage#what 识别message的标识，相当于id。\nMessage#arg1/Message#arg2 arg1和arg2是data的低成本替代品，当只需要几个整形参数时，可以使用arg1和arg2替代data\nMessage#obj 发接收/处理方的任意对象，但当是跨进程发送消息时：Android2.2以后必须是Parcelable的，Android2.2以前不支持使用此字段快进程。\nMessage#replyTo 当使用Messenger跨进程通信时可以使用replyTo回复消息。\nMessage#when 基于SystemClock#uptimeMillis的时间，是Message被分发(dispatchMessage)的时间。\nMessage#data Message携带数据\nMessage#target 发送(sendMessage)这个Message的Handler\nMessage#callback 只能在Messenger.obtain时设置，当dispatchMessage时如果Message有callback则不再走handleMessage。\nMessage#obtain() 复用sPool对象，避免频繁创建销毁对象增加GC压力。sPool是一个Message链表的第一个元素，默认长度MAX_POOL_SIZE(50)。每当调用obtain()时若sPool不为null(链表有元素)，则复用sPool对象，并修改sPool链表长度减1。\nMessage#recycle()/Message#recycleUnchecked() 每当调用该方法则检查sPool链表是否达到最大长度MAX_POOL_SIZE，如果未达到则将当前Message重置并加入到sPool链表(复用池)中。\nMessage#.isAsynchronous() 是否是异步消息，API22后用户可获取，之前未对开发者开放\nMessage#.setAsynchronous(async) 设置是否是异步消息，API22后用户可设置，之前未对开发者开放\nLooper 为什么Looper.myLooper可以获取当前线程的Looper或者说Looper如何与Thread关联的呢？首先我们查看Looper.myLooper是如何获取当前线程的Looper的\n1 2 3  public static @Nullable Looper myLooper() { return sThreadLocal.get(); }   原来是通过sThreadLocal获取的。sThreadLocal可以存放获取绑定到当前线程的数据，你不往里放它自己肯定是没有的，既然是存放获取绑定到当前线程的数据肯定是在当前线程存放的，很容易想到Looper.prepare()和Looper.loop()两个方法，查看Looper.prepare()源码\n1 2 3 4 5 6 7 8 9 10  public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } sThreadLocal.set(new Looper(quitAllowed)); }   正中所想。\n那Looper.loop()这个方法是做什么用的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\u0026#34;No Looper; Looper.prepare() wasn\u0026#39;t called on this thread.\u0026#34;); } final MessageQueue queue = me.mQueue; ... for (;;) { Message msg = queue.next(); // 从消息队列取Message对象，如果没取到则阻塞在这  if (msg == null) {//MessageQueue已退出，即调用了quit()或quitSafely()  return; } ... final Observer observer = sObserver; Object token = null; if (observer != null) { token = observer.messageDispatchStarting(); } try { msg.target.dispatchMessage(msg);//分发消息  if (observer != null) { observer.messageDispatched(token, msg); } dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } catch (Exception exception) { if (observer != null) { observer.dispatchingThrewException(token, msg, exception); } throw exception; } finally { ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) { Trace.traceEnd(traceTag); } } ... msg.recycleUnchecked();//复用消息  } } public void quit() { mQueue.quit(false); } public void quitSafely() { mQueue.quit(true); }   从源码可以看出loop()方法主要做了三件事：从MessageQueue取消息、调用dispatchMessage分发取出的消息、复用分发后的消息。\nMessageQueue MessageQueue是一个存放一个有序(以Message的when排序)的Message的队列。从上面Looper源码分析来看，我们有几个问题：1.queue.next()既然是阻塞的为什么没有导致ANR？2.quit()和quitSafely()最终是怎么实现退出loop循环的？从loop方法看似乎是让MessageQueue的next方法取出一个null的Message对象。\n在回答这两个问题前我们需要先了解什么是屏障消息。屏障消息即时一个target==null的特殊消息(正常我们调用sendMessage发送消息系统会自动帮我们设定非空target)。系统如何发布一个屏障消息：\nMessageQueue#postSyncBarrier\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public int postSyncBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); } private int postSyncBarrier(long when) { // Enqueue a new sync barrier token.  // We don\u0026#39;t need to wake the queue because the purpose of a barrier is to stall it.  synchronized (this) { final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) { while (p != null \u0026amp;\u0026amp; p.when \u0026lt;= when) { prev = p; p = p.next; } } if (prev != null) { // invariant: p == prev.next  msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } }   当然这是只有系统才可以使用的API，没有对开发者开放。\n现在我们先看第二个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException(\u0026#34;Main thread not allowed to quit.\u0026#34;); } synchronized (this) { if (mQuitting) { return; } mQuitting = true; if (safe) { removeAllFutureMessagesLocked(); } else { removeAllMessagesLocked(); } // We can assume mPtr != 0 because mQuitting was previously false.  nativeWake(mPtr); } } //重置复用消息，然后将所有mMessages链表Message对象置为null private void removeAllMessagesLocked() { Message p = mMessages; while (p != null) { Message n = p.next; p.recycleUnchecked(); p = n; } mMessages = null; } //检查mMessages的when是否小于等于当前时间，如果是标明mMessages这个消息已经分发/正在出去并且可能正在使用，如果粗暴的将mMessages重置然后置为null，可能导致程序异常；如果mMessages的when大于当前时间说明尚未分发，可以放心回收。 private void removeAllFutureMessagesLocked() { final long now = SystemClock.uptimeMillis(); Message p = mMessages; if (p != null) { if (p.when \u0026gt; now) { removeAllMessagesLocked(); } else {//mMessages.when\u0026lt;=now  Message n; for (;;) { n = p.next;//跳过mMessages从mMessages的下个元素开始  if (n == null) { return; } if (n.when \u0026gt; now) { break; } p = n; } p.next = null; do { p = n; n = p.next; p.recycleUnchecked(); } while (n != null); } } }   从上面代码可以看出Looper.quit()和Looper.quitSafely()的主要区别是判断了mMessages链表的首元素的when，即是否已分发，分发出去的消息可能正在使用不能回收，强制回收可能消息行为改变(recycleUnchecked后mMessages = null前)或导致空指针异常。\n再来看MessageQueue#next()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  Message next() { final long ptr = mPtr; if (ptr == 0) {//mPtr为0表示已调用quit退出或者当前MessageQueue已没有被其他任何对象引用(调用了finalize()方法)等待被GC回收状态  return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration  int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis);//会调用到linux的epoll_wait，阻塞指定时间(nextPollTimeoutMillis)并释放时间片  synchronized (this) { // Try to retrieve the next message. Return if found.  final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null \u0026amp;\u0026amp; msg.target == null) {//同步屏障消息  // Stalled by a barrier. Find the next asynchronous message in the queue.  do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026amp;\u0026amp; !msg.isAsynchronous()); } if (msg != null) { if (now \u0026lt; msg.when) {//消息未到分发时间，设置一个超时唤醒时间。  nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else {//有消息需要分发，执行正常流程  mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \u0026#34;Returning message: \u0026#34; + msg); msg.markInUse(); return msg; } } else {// mMessages链表中没有消息  nextPollTimeoutMillis = -1; } //------------只有没有消息时才会执行到下面的代码-------------------//  if (mQuitting) {//退出  dispose(); return null; } // If first time idle, then get the number of idlers to run.  // Idle handles only run if the queue is empty or if the first message  // in the queue (possibly a barrier) is due to be handled in the future.  if (pendingIdleHandlerCount \u0026lt; 0 \u0026amp;\u0026amp; (mMessages == null || now \u0026lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } //如果没有IdleHandler需要运行  if (pendingIdleHandlerCount \u0026lt;= 0) { //标识当前处于阻塞状态，用于enqueueMessage唤醒mPtr(nativeWake(mPtr))，即唤醒next执行，取消阻塞重新争抢时间片。  mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } for (int i = 0; i \u0026lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler  boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, \u0026#34;IdleHandler threw exception\u0026#34;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } //重置需要执行的IdelHandler  pendingIdleHandlerCount = 0; //执行IdelHandler时可能队列已有了新消息，因此将nextPollTimeoutMillis设置为0重新检查。  nextPollTimeoutMillis = 0; } }   其他 IdleHandler 在MessageQueue的小节通过分析源码我们了解到IdleHandler，它会在无消息空闲状态下触发执行，这是一种很好的优化方法。比如用来优化App的启动。\nThreadLocal ThreadLocal是一个线程隔离的工具类，详细请见另一篇Java-ThreadLocal源码解析\nHandler机制大致流程(不严谨的流程) Looper.prepare()-\u0026gt;Looper.loop()-\u0026gt;MessageQueue.next-\u0026gt;Handler.dispatchMessage-\u0026gt;Message.callback/Handler.handlerMessage\nHandler、Looper、MessageQueue对应关系 一个线程对应一个Looper，多个Handler\n一个Looper对应一个MessageQueue，多个Handler\n一个MessageQueue对应一个线程，一个Looper，多个Handler。\nHandler机制原理 内存共享，使用MessageQueue/Message这一线程独有的内存对象实现线程间通信。\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/animation/",
	"title": "animation",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/animation/",
	"title": "animation",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/handler/",
	"title": "handler",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/http/",
	"title": "http",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/http/",
	"title": "http",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/httphttps/",
	"title": "Http/Https详解",
	"tags": ["http", "https"],
	"categories": [],
	"series": ["编程基础"],
	"description": "Http/Https详解",
	"content": "HTTP(HyperText Transfer Protocol) 超文本传输协议，虽然名字叫传输协议，但其其实是应用层的协议，是构建在传输层协议TCP之上的协议。\n   http版本 诞生年份      HTTP/0.9 1991 文本信息   HTTP/1.0 1996 文本、图像、视频、二进制文件   HTTP/1.1 1999 当前流行版本   HTTPS 2000    HTTP/2.0 2015 当前应用不多，主要用于API Service   HTTP/3.0 研发中 使用Quic(改进的UDP)取代TCP    HTTP 各版本区别 HTTP/1.0 HTTP/1.1 HTTP/1.1默认使用keep-alive长连接，解决了多次请求建立多次TCP连接的问题，但这个TCP长连接中的请求是串行的，某个请求耗时严重会阻塞后面的请求。\nHTTP/2.0 HTTP/2.0使用了头部压缩技术及多路复用。不同于HTTP/1.1的keep-alive长连接，HTTP/2.0允许多个请求并行执行。在 HTTP/2.0中，有两个非常重要的概念，分别是(二进制)帧（frame）和流（stream），帧是最小的数据单位，每个帧标识了自己属于哪个流，因此HTTP/2.0可以实现并行。\nHTTP请求方法   GET\nGET的请求应该只被用于获取给定的URL标识的服务端资源，GET请求不应有请求体也不应对请求数据造成影响。\n  POST\n创建或更新资源，请求数据包含在请求体中。POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是\u0026quot;key1=value1\u0026amp;key2=value2\u0026quot;这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。\n  PUT\n使用请求数据取代服务端目标资源。\n  DELETE\n请求服务端删除给定URL标识的资源。\n  HEAD\n和GET的唯一区别是不返回响应体。使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。通常用于测试超链接的有效性或下载前查看文件有多大，服务器是否支持断点下载等。\n  CONNECT\nHTTP/1.1协议中预留给能够将连接改为隧道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。方法名称是区分大小写的。\n当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。\n  OPTIONS\n这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用\u0026rsquo;*\u0026lsquo;来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\n  TRACE\n回显服务器收到的请求，主要用于测试或诊断。\n  PATCH\n用于对资源应用部分修改。\n  状态码(Status Code)   1xx 消息\n100 - 服务器已经接收到请求头，并且客户端应继续发送请求主体，或者如果请求已经完成，忽略这个响应。服务器在请求完成后向客户端发送一个最终响应。\n  2xx 成功，操作被成功接收并处理\n200 - 请求成功\n201 - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回'202 Accepted\u0026rsquo;。\n202 - 服务器已接受请求，但尚未处理完成。\n203 - 服务器是一个转换代理服务器（如网络加速器），请求获得了源服务器的状态码为 200 (OK)的响应，但经过了转换代理服务器的修改。\n  3xx 重定向，需要进一步的操作以完成请求\n301 - 资源（网页等）被永久转移到其它URI，新的永久性的URI应当在响应的Location域中返回。\n302 - Found，请求资源已被临时转移到其它URI，新的临时性的URI应当在响应的Location域中返回。由于这个重定向是临时的，只有在Cache-Control或Expires中进行了指定的情况下，这个临时URI才是有效可缓存的，之后客户端应当继续向原有地址发送以后的请求。\n  4xx 客户端错误，请求包含语法错误或无法完成请求\n400 - Bad Request，由于明显的客户端错误（如请求语法格式错误，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。\n401 - Unauthorized，该状态码表示当前请求需要用户验证但用户没有必要的凭证。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。\n403 - Forbidden，服务器端有能力处理该请求，但是拒绝授权访问。这个状态类似于 401，但进入该状态后不能再继续进行验证。该访问是长期禁止的，并且与应用逻辑密切相关。\n404 - 请求的资源（网页等）不存在\n  5xx 服务器错误，服务器在处理请求的过程中发生了错误\n500 - 服务器遇到了一个未曾预料的状况导致了它无法完成对请求的处理\n  这里就不啰嗦了，详细解释见参考维基百科-HTTP状态码\nHTTP头字段 更多详情解释见参考维基百科-HTTP头字段\n缓存头字段及缓存策略 =Last-Modified则标识未改变返回304，否则返回改变后的资源 2. Etag/If-None-Match etag：当前资源在服务器端的唯一标识，生成规则由服务器决定。客户端再次请求资源时带上etag -- 详情见参考HTTP 缓存- HTTP | MDN、最佳Cache-Control 策略 - Google Developers\n断点续传 Range\nAccept-Range\nContent-Range\nIf-Range\n检测服务器是否支持断点续传 Response的Headers能够找到 Content-Range，则表明服务器支持断点续传。有些服务器还会返回 Accept-Ranges，输出结果 Accept-Ranges: bytes ，说明服务器支持按字节下载。\nHTTP报文结构 请求报文结构 请求报文主要包含三部分：请求行，请求头部，请求体\nGET请求报文结构：\n① GET /dshcao/dshcao.github.io HTTP/1.1 ② Host: github.com ③ Connection: keep-alive ④ Upgrade-Insecure-Requests: 1 ⑤ User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 ⑥ Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 ⑦ Sec-Fetch-Site: none ⑧ Sec-Fetch-Mode: navigate ⑨ Sec-Fetch-Dest: document ⑩ Accept-Encoding: gzip, deflate, br ⑪ Accept-Language: zh-CN,zh;q=0.9 ⑫ Cookie: _ga=GA1.2.464683002.1544702315; _octo=GH1.1.1103713911.1544702315; _device_id=6dcac799610fe64ac0c51f9f73ff2ab5; ① 请求行：请求方法+请求path+协议及版本\n②～⑫ 请求头部\nPOST请求报文结构：\n① POST /xx/yy/zz HTTP/1.1 ② Host: github.com ③ Connection: keep-alive ④ Upgrade-Insecure-Requests: 1 ⑤ User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 ⑥ Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 ⑦ Sec-Fetch-Site: none ⑧ Sec-Fetch-Mode: navigate ⑨ Sec-Fetch-Dest: document ⑩ Accept-Encoding: gzip, deflate, br ⑪ Accept-Language: zh-CN,zh;q=0.9 ⑫ Content-Length: 18 ⑬ Content-Type: application/x-www-form-urlencoded ⑭ Cookie: _ga=GA1.2.464683002.1544702315; _octo=GH1.1.1103713911.1544702315; _device_id=6dcac799610fe64ac0c51f9f73ff2ab5; ⑮ ⑯ name=jack\u0026amp;q=domety ① 请求行：请求方法+请求path+协议及版本\n②～⑭ 请求头部\n⑮ 请求头部和请求体之间需要的空行\n⑯ 请求体\n响应报文结构 响应报文主要包含三部分：状态行，响应头部，响应体\n① HTTP/1.1 200 OK ② Bdpagetype: 2 ③ Bdqid: 0xeaa4231b000d977f ④ Cache-Control: private ⑤ Connection: keep-alive ⑥ Content-Encoding: gzip ⑦ Content-Type: text/html;charset=utf-8 ⑧ Date: Sat, 30 May 2020 09:06:17 GMT ⑨ Expires: Sat, 30 May 2020 09:06:17 GMT ⑩ Server: BWS/1.1 ⑪ Set-Cookie: BDSVRTM=502; path=/ ⑫ Set-Cookie: BD_HOME=1; path=/ ⑬ Set-Cookie: H_PS_PSSID=31727_1456_21114_31110_31589_31463_30823_26350; path=/;domain=.baidu.com ⑭ Strict-Transport-Security: max-age=172800 ⑮ Traceid: 1590829577071592193016907677499927664511 ⑯ X-Ua-Compatible: IE=Edge,chrome=1 ⑰ Transfer-Encoding: chunked ⑱ ⑲ \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt; ... \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; ① 状态行：协议及版本+状态码+状态信息\n②～⑰ 响应头部\n⑱ 响应头部与响应体之间所需的空行\n⑲ 响应体\n一次完整的HTTP请求过程  首先进行DNS域名解析（本地浏览器缓存、操作系统缓存或者DNS服务器） 三次握手建立 TCP 连接 客户端向服务器发送请求命令 Get /www.xx.com/ http/1.1 客户端发送请求头信息 服务器应答 Http/1.1 200 OK 返回响应头信息 服务器向客户端发送数据 服务器关闭 TCP 连接  HTTPS(Hyper Text Transfer Protocol over SecureSocket Layer) HTTPS本质上就是客户端和服务端使用非对称密钥协商出一个对称密钥，在后面双方发收的数据时使用这个对称密钥加密解密，从而保证数据的安全传输。\n 对称加密\n速度高，可加密内容较大，用来加密会话过程中的消息。  常见的对称加密算法有：DES、3DES、AES、Blowfish、IDEA、RC5、RC6\n2. 公钥加密\n加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥。\n常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）\n建立连接时，SSL使用非对称加密的公钥加密对称密钥，连接建立完成后使用对称密钥对数据进行加密传输。\nHttps分为单向认证和双向认证，单向认证即客户端需要验证服务端，服务端不需要验证客户端。双向认证则是客户端需要验证服务端，服务端也需要验证客户端。\n非对称加密与签名 非对称加密中公钥加密的数据私钥可以解密，同样的私钥加密的数据公钥也可以解密，但公钥和私钥却不是可以互换的，你不能将公钥当私钥使用，也不能将私钥当公钥使用，这听起来有点奇怪，为什么可以互相加解密却不能互换身份？因为可以使用私钥推理出公钥相对容易，但使用公钥推理出私钥却比较困难。你可能继续问这是怎么做到的？这设计非对称加密原理，参阅非对称加密原理\n签名 签名是非对称加密的反过程，即使用私钥加密，使用公钥解密。实际使用中的签名一般都是对原数据的hash签名，因为一般数据的hash长度远小于消息原文，使得签名（非对称加密）的效率大大提高。\n签名数据的传递一般是：原数据 + 私钥加密的原数据的hash。\n对签名后的数据验证：通过公钥对签名解密出原数据的hash与原数据的hash对比。\nSSL(Secure Socket Layer)和TLS(Transport Layer Secure) SSL是早期的叫法，TLS是现在规范的叫法。\nHTTPS单向认证 HTTPS双向认证 参考：\n 维基百科-HTTP状态码 MDN web docs HTTP 响应代码 维基百科-HTTP头字段 最佳Cache-Control 策略 - Google Developers HTTP 缓存- HTTP | MDN Https单向认证和双向认证  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/https/",
	"title": "https",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/jetpack/",
	"title": "jetpack",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/jetpack/",
	"title": "jetpack",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-jobservice/",
	"title": "Jetpack-JobService详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件JobService详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-lifecycles/",
	"title": "Jetpack-Lifecycles",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件Lifecycles详解",
	"content": "原理 ReportFragment\nProcessLifecycleOwner ActivityInitializationListener\nLifecycleOwner\u0026amp;LifecycleObserver LifecycleRegistry\u0026amp;Lifecycle LiveData既是观察者也是被观察者\n作为观察者可以观察Activity和Fragment的生命周期\n通常将LiveData包在ViewModel中使用\nLiveData使用mVersion表示数据是否有变化，并判断Activity是否在前台，在前台则回调通知\n LiveData   MutableLiveData\n MediatorLiveData SavingStateLiveData LoaderInfo    SliceLiveDataImpl\n  CachedLiveDataImpl\n  PublisherLiveData\n    ComputableLiveData\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-navigation/",
	"title": "Jetpack-Navigation详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件Navigation详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-roomlivedataviewmodel%E8%AF%A6%E8%A7%A3/",
	"title": "Jetpack-Room&amp;LiveData&amp;ViewModel详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack-Room&amp;LiveData&amp;ViewModel详解",
	"content": "Room升级 当数据表结构变化时如何直接修改version会导致数据库数据被清空\n1 2 3 4 5 6 7 8  return Room.databaseBuilder(context, AppDatabase::class.java, \u0026#34;dsh\u0026#34;).allowMainThreadQueries().addMigrations(Migration1000To1001()).build() class Migration1000To1001 : Migration(1000, 1001) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(\u0026#34;alter table user add column vip integer not null default 0\u0026#34;) } }   这样就不会升级时就不会清空数据库数据\n屏幕旋转过程中会回调\nonRetainNonConfigurationInstance\ngetLastNonConfigurationInstance\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public final Object onRetainNonConfigurationInstance() { Object custom = onRetainCustomNonConfigurationInstance(); ViewModelStore viewModelStore = mViewModelStore; if (viewModelStore == null) { // No one called getViewModelStore(), so see if there was an existing  // ViewModelStore from our last NonConfigurationInstance  NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { viewModelStore = nc.viewModelStore; } } if (viewModelStore == null \u0026amp;\u0026amp; custom == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = viewModelStore; return nci; }   这也是ViewModel包装后的数据可以在屏幕旋转过程依然可以正常的原因\n当Activity或Fragment onDestroy时ViewModel会被datch\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-workmanager/",
	"title": "Jetpack-WorkManager详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件WorkManager详解",
	"content": "谷歌使用Room数据库保存任务及Alarm来保证\nWorkManager是一定会执行的，最小间隔是15min\n"
},
{
	"uri": "https://dshcao.github.io/zh/categories/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/kotlin-%E8%AF%AD%E6%B3%95/",
	"title": "Kotlin语法",
	"tags": ["kotlin", "android"],
	"categories": [],
	"series": ["kotlin"],
	"description": "Kotlin语法",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/renderscript/",
	"title": "renderscript",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B/",
	"title": "写在开始",
	"tags": ["生活"],
	"categories": [],
	"series": ["生活"],
	"description": "写在开始写博客的开始",
	"content": "工作已经很多年，但基本没写过博客。为什么？！！！当然是懒了！！！\n难道工作这么多年就没有想记录或者没有想写的内容吗？当然有！平时把记录的内容都放在了txt文件中。CSDN？当然早就注册了，但总觉得CSDN网站有些潦草。后来，至少是四年前在博客园申请过开博客，当时申请的理由大概是记录生活和学习内容，转载和保存别人的精品文章，结果，emmm\u0026hellip;很明显，被拒绝了，加上懒散，然后很久没有在写文章上花心思了。一晃不知道多久过去了，无意发现简书，支持当时很流行很火的markdown，自己也很想尝试，然后申请了一个账号，才发现写文章真的不是一件很轻松的事\u0026hellip;至少对于我这种先天性缺陷不会组织语言又追求完美的人。然而工作中又有很多东西需要记录，怎么办?于是我把简书当作了草稿箱，只有自己看的明白的杂乱排版，一篇一篇下来也不少了。\n最近准备找工作，写博客当然是加分项，加上自己这个年纪，很多小年轻在上学的时候就开始写了，当然有些唏嘘和忐忑！所以准备再次起航！\n为什么又搭建这个博客而不是继续简书，主要是我觉得简书软文和鸡汤太多，已不如当初，技术氛围已经快丧失完了。就像人：若只如初见！\n当然还有其他技术氛围不错的掘金等，但搭建自己的博客和网站一直是我想做的事，那就干脆就自己搭建一个吧。服务器我已经买，环境也已搭建好，想自己一个一个页面写出来，写了一部分页面，效果并不满意，觉得写页面这事对我还是有点吃力，况且域名还没有备案。于是选择了先在github搭建，比想象简单，两小时通关。\n选择hugo主要是因为是golang写的，虽然搭建又不用写golang ^_-。本人是golang爱好者，在我看来，golang最接近我对编程语言的幻想。\n开始就不会晚！好吧，我承认自己都感觉这话有点虚了，但开始总比没开始好。\n"
},
{
	"uri": "https://dshcao.github.io/zh/series/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-nestedscrolling%E8%A7%A3%E6%9E%90/",
	"title": "Android源码解析-NestedScrolling",
	"tags": ["android", "嵌套", "滑动"],
	"categories": [],
	"series": ["源码解析"],
	"description": "android 嵌套发动NestedScrollingXXX.",
	"content": "嵌套滑动实现原理及执行过程 嵌套滑动其实就是一套嵌套滑动回调。难的是嵌套滑动是如何回调的。理解嵌套滑动应该试着从嵌套滑动API的设计者思考。如果你明白了设计思路就可以很简单的在嵌套滑动回调做相应的处理。\n嵌套原理 我们知道触摸事件被父控件拦截后子控件无法收到后续的事件。同样的如果子控件决定了消费触摸事件父控件的onTouchEvent也无法继续收到后续的触摸事件。嵌套滑动如何实现的呢？答案是通过requestDisallowInterceptTouchEvent(true)请求父控件不要拦截触摸事件，触摸事件传递到子控件并在子控件onTouchEvent中调用startNestedScroll开启整个嵌套滚动。startNestedScroll会检测支持嵌套滚动的父控件并持有该父控件。然后通过嵌套滚动API的回调方法实现子控件和父控件的通信\n执行过程 NestedChild NestedParent\nstartNestedScroll(TYPE_TOUCH) onStartNestedScroll(TYPE_TOUCH)\nonNestedScrollAccepted(TYPE_TOUCH)\ndispatchNestedPreScroll(TYPE_OUCH) onNestedPreScroll(TYPE_TOUCH)\ndispatchNestedScroll(TYPE_TOUCH) onNestedScroll(TYPE_TOUCH)\ndispatchNestedPreFling onNestedPreFling\ndispatchNestedFling onNestedFling\nstartNestedScroll(TYPE_NON_TOUCH) onStartNestedScroll(TYPE_NON_TOUCH)\nonNestedScrollAccepted(TYPE_NON_TOUCH)\nstopNestedScroll(TYPE_TOUCH) onStopNestedScroll(TYPE_NON_TOUCH)\ndispatchNestedPreScroll(TYPE_NON_TOUCH) onNestedPreScroll(TYPE_NON_TOUCH)\ndispatchNestedScroll(TYPE_NON_TOUCH) onNestedScroll(TYPE_NON_TOUCH) stopNestedScroll(TYPE_NON_TOUCH) onStopNestedScroll(TYPE_NON_TOUCH)\n执行顺序从左到右，从上到下\nNestedScrollingChild/NestedScrollingChild2/NestedScrollingChild3 NestedScrollingChild2继承自NestedScrollingChild并重载部分方法。为什么重载？增强实现。NestedScrollingChild3继承自NestedScrollingChild2并重载部分方法进一步增强实现。详情看下面源码解析注释。\n主要方法：\n  setNestedScrollingEnabled\n设置是否配合父控件嵌套滚动，前提是该控件实现相应的嵌套滚动功能。View默认实现和NestedScrollingChildHelper默认实现类似，只是NestedScrollingChildHelper做了兼容处理\n1 2 3 4 5 6 7 8  public void setNestedScrollingEnabled(boolean enabled) { if (enabled) { mPrivateFlags3 |= PFLAG3_NESTED_SCROLLING_ENABLED; } else { stopNestedScroll(); mPrivateFlags3 \u0026amp;= ~PFLAG3_NESTED_SCROLLING_ENABLED; } }   如果是在嵌套滚动中调用setNestedScrollingEnabled禁用了嵌套滚动会主动调用stopNestedScroll()\n  isNestedScrollingEnabled\n返回的是setNestedScrollingEnabled设置的结果\n  hasNestedScrollingParent\n子控件是否有支持嵌套滑动父控件，由于ViewGroup继承了ViewParent，而新的ViewParent支持了嵌套滑动API，实际上就是判断是否有父控件。嵌套滑动父控件的设置是在startNestedScroll执行的时候设置的\n  startNestedScroll\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public boolean startNestedScroll(int axes) { if (hasNestedScrollingParent()) { // Already in progress  return true; } if (isNestedScrollingEnabled()) { ViewParent p = getParent(); View child = this; while (p != null) { try { if (p.onStartNestedScroll(child, this, axes)) { //设置嵌套滑动父控件，mNestedScrollingParent是hasNestedScrollingParent判断的依据  mNestedScrollingParent = p; p.onNestedScrollAccepted(child, this, axes); return true; } } catch (AbstractMethodError e) { Log.e(VIEW_LOG_TAG, \u0026#34;ViewParent \u0026#34; + p + \u0026#34; does not implement interface \u0026#34; + \u0026#34;method onStartNestedScroll\u0026#34;, e); // Allow the search upward to continue  } if (p instanceof View) { child = (View) p; } p = p.getParent(); } } return false; }   子控件发起嵌套滚动动作，触摸模式嵌套滑动通常应该在ACTION_DOWN时调用该方法触发嵌套滚动。如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Override public boolean onTouchEvent(MotionEvent e) { switch (action) { case MotionEvent.ACTION_DOWN: int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE; if (canScrollHorizontally) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL; } if (canScrollVertically) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL; } startNestedScroll(nestedScrollAxis, TYPE_TOUCH); break; ... } }   startNestedScroll源码可知返回true表示找到了支持嵌套滑动的父控件\n  dispatchNestedPreScroll\n分发嵌套滑动事件。在嵌套滑动子控件消费嵌套滑动前调用该方法。View默认实现源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  /** * 控件消费之前调用该方法 * * @param dx 水平方向滚动的像素 * @param dy 垂直方向滚动的像素 * @param consumed 输出参数. 如果不为null, consumed[0] 表示消费的 dx consumed[1] 表示消费的 dy.默认实现这里是被父控件消费 * @param offsetInWindow 可选项. 如果不是 null, 返回的是当前控件在该方法操作前后的视图坐标偏移。使用这个来调整预期的输入坐标跟踪 * @return true 表示父控件消费了部分或全部 */ public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable @Size(2) int[] consumed, @Nullable @Size(2) int[] offsetInWindow) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { if (dx != 0 || dy != 0) { int startX = 0; int startY = 0; if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; } if (consumed == null) { if (mTempNestedScrollConsumed == null) { mTempNestedScrollConsumed = new int[2]; } consumed = mTempNestedScrollConsumed; } consumed[0] = 0; consumed[1] = 0; //调用嵌套父控件处理  mNestedScrollingParent.onNestedPreScroll(this, dx, dy, consumed); if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; } return consumed[0] != 0 || consumed[1] != 0; } else if (offsetInWindow != null) { offsetInWindow[0] = 0; offsetInWindow[1] = 0; } } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。综上即：在嵌套滑动子控件消费嵌套滑动前调用该方法让嵌套滑动父控件先处理。\n  dispatchNestedScroll\n子控件消费后再次向父控件分发嵌套滑动事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /** * 支持嵌套滑动的控件应该调用该方法报告父控件的滑动信息。 * * @param dxConsumed Horizontal distance in pixels consumed by this view during this scroll step * @param dyConsumed Vertical distance in pixels consumed by this view during this scroll step * @param dxUnconsumed Horizontal scroll distance in pixels not consumed by this view * @param dyUnconsumed Horizontal scroll distance in pixels not consumed by this view * @param offsetInWindow Optional. If not null, on return this will contain the offset * in local view coordinates of this view from before this operation * to after it completes. View implementations may use this to adjust * expected input coordinate tracking. * @return true if the event was dispatched, false if it could not be dispatched. * @see #dispatchNestedPreScroll(int, int, int[], int[]) */ public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable @Size(2) int[] offsetInWindow) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { if (dxConsumed != 0 || dyConsumed != 0 || dxUnconsumed != 0 || dyUnconsumed != 0) { int startX = 0; int startY = 0; if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; } mNestedScrollingParent.onNestedScroll(this, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; } return true; } else if (offsetInWindow != null) { // No motion, no dispatch. Keep offsetInWindow up to date.  offsetInWindow[0] = 0; offsetInWindow[1] = 0; } } return false; }     dispatchNestedPreFling\n子控件消费fling事件前向父控件分发fling事件，若父控件消费则子控件将无法再消费。有一定局限性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * 不同于scroll，如果父控件消费了fling，该控件不应再消费。即要么父控件要么该子控件消费fling。不应该两者都消费 * 为了获得更好的用户体验，嵌套滑动链中一次应该只有一个view消费fling事件。自定义视图实现应该以两种方式考虑这一点： * 1.如果自定义视图是分页的，并且需要固定到一个固定的页面点，请不要调用dispatchNestedPreFling；使用fling并固定到一个有效的位置 * 2.如果嵌套的父级确实消耗了fling，则该视图根本不应该滚动，甚至不应该回到有效的空闲位置 * * 视图也不应该向当前不支持滚动的轴上的嵌套父视图提供滚动速度 * * @param velocityX Horizontal fling velocity in pixels per second * @param velocityY Vertical fling velocity in pixels per second * @return true 嵌套滑动父控件消费了fling */ public boolean dispatchNestedPreFling(float velocityX, float velocityY) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { return mNestedScrollingParent.onNestedPreFling(this, velocityX, velocityY); } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。综上即：在嵌套滑动子控件消费嵌套fling前调用该方法让嵌套滑动父控件先处理。\n  dispatchNestedFling\n若父控件未消费会调用该方法再次向父控件分发fling事件，之后会再此交给子控件处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * 该方法表示达到了fling条件。如：fling速度大于ViewConfiguration#getScaledMinimumFlingVelocity() * * 如果嵌套滑动子控件fling并达到了内容边缘可以使用此方法将fling委托给嵌套滑动父控件消费或观察 * * @param velocityX Horizontal fling velocity in pixels per second * @param velocityY Vertical fling velocity in pixels per second * @param consumed true if the child consumed the fling, false otherwise * @return true if the nested scrolling parent consumed or otherwise reacted to the fling */ public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { return mNestedScrollingParent.onNestedFling(this, velocityX, velocityY, consumed); } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。\n  stopNestedScroll\n停止嵌套滚动\n1 2 3 4 5 6 7 8 9  /** * 嵌套滚动未开始时调用该方法是没有影响的 */ public void stopNestedScroll() { if (mNestedScrollingParent != null) { mNestedScrollingParent.onStopNestedScroll(this); mNestedScrollingParent = null; } }     NestedScrollingChild 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public interface NestedScrollingChild { void setNestedScrollingEnabled(boolean enabled); boolean isNestedScrollingEnabled(); boolean startNestedScroll(@ScrollAxis int axes); void stopNestedScroll(); boolean hasNestedScrollingParent(); boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow); boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow); boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed); boolean dispatchNestedPreFling(float velocityX, float velocityY); }   NestedScrollingChild2 NestedScrollingChild2相比NestedScrollingChild主要增加了fling消费的支持。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public interface NestedScrollingChild2 extends NestedScrollingChild { boolean hasNestedScrollingParent(@NestedScrollType int type); boolean startNestedScroll(@ScrollAxis int axes, @NestedScrollType int type); //当type=ViewCompat.TYPE_NON_TOUCH时，此方法是设计被fling状态时分发  boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow, @NestedScrollType int type); //当type=ViewCompat.TYPE_NON_TOUCH时，此方法是设计被fling状态时分发  boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow, @NestedScrollType int type); void stopNestedScroll(@NestedScrollType int type); }   NestedScrollingChild3 1 2 3 4 5 6  public interface NestedScrollingChild3 extends NestedScrollingChild2 { void dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow, @ViewCompat.NestedScrollType int type, @NonNull int[] consumed); }   NestedScrollingParent/NestedScrollingParent2/NestedScrollingParent3 NestedScrollingParent2继承自NestedScrollingParent并重载部分方法。为什么重载？增强实现。NestedScrollingParent3继承自NestedScrollingParent2并重载部分方法进一步增强实现。详情看下面源码解析注释。\n主要方法：\n  onStartNestedScroll\n该方法被子控件startNestedScroll(int)方法调用的。返回true表示该父控件将在嵌套滚动期间成为支持子控件嵌套滚动的父控件并接受嵌套滑动操作。当嵌套滚动结束后会收到onStopNestedScroll(View)的回调\n1 2 3 4  @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) { return false; }   由上面ViewGroup源码可知默认实现是不会成为嵌套滚动父控件，不接受子控件传递嵌套滑动操作的。一般如果需要支持作为嵌套滑动父控件需要重写此方法。\n1 2 3 4  @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) { return (nestedScrollAxes \u0026amp; View.SCROLL_AXIS_VERTICAL) != 0; }     onNestedScrollAccepted\n此方法将在onStartNestedScroll返回true后调用。它为视图及其超类提供了执行嵌套滚动的初始配置的机会。此方法的实现应始终调用其超类的此方法的实现（如果存在的话）。\n1 2 3 4  @Override public void onNestedScrollAccepted(View child, View target, int axes) { mNestedScrollAxes = axes; }   ViewGroup的默认实现是记录嵌套滚动的方向。\n  getNestedScrollAxes\n1 2 3  public int getNestedScrollAxes() { return mNestedScrollAxes; }     onNestedPreScroll\n目标视图嵌套滚动前调用该方法。因为嵌套滑动父控件可能想在子控件滚动前有机会消费滚动。onNestedPreScroll是在嵌套滑动子控件调用dispatchNestedPreScroll是被调用的。该方法应该报告消费了多少像素。\n1 2 3 4 5 6 7 8 9 10 11  /** * @param target View that initiated the nested scroll * @param dx Horizontal scroll distance in pixels * @param dy Vertical scroll distance in pixels * @param consumed Output. The horizontal and vertical scroll distance consumed by this parent */ @Override public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) { // Re-dispatch up the tree by default  dispatchNestedPreScroll(dx, dy, consumed, null); }     onNestedScroll\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * * 嵌套滑动子控件分发滑动事件时调用此方法。要想调用到该方法之前的onStartNestedScroll必须返回true * 滚动的消费部分和未消费部分都应该通过此方法报告给父控件。如果有未消耗的部分可以在此方法让父控件继续消费 * * @param target The descendent view controlling the nested scroll * @param dxConsumed Horizontal scroll distance in pixels already consumed by target * @param dyConsumed Vertical scroll distance in pixels already consumed by target * @param dxUnconsumed Horizontal scroll distance in pixels not consumed by target * @param dyUnconsumed Vertical scroll distance in pixels not consumed by target */ Override public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) { // Re-dispatch up the tree by default  dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, null); }     onNestedPreFling\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * 目标视图消费fling之前父控件对嵌套滑动的相应 * 该方法被调用表示子控件发起了一个fling事件，通常是滑动速度大于ViewConfiguration#getScaledMinimumFlingVelocity() * * 如果父控件通过onNestedPreScroll消费了部分滑动，那么可能也需要通过onNestedPreFling完成通常的动作 * 返回true表示父控件消费了fling，此时子控件不应滚动内容 * * @param target View that initiated the nested scroll * @param velocityX Horizontal velocity in pixels per second * @param velocityY Vertical velocity in pixels per second * @return true if this parent consumed the fling ahead of the target view */ public boolean onNestedPreFling(View target, float velocityX, float velocityY) { // Re-dispatch up the tree by default  return dispatchNestedPreFling(velocityX, velocityY); }     onNestedFling\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /** * 如果嵌套滑动子控件fling并达到了内容边缘可以使用此方法将fling委托给嵌套滑动父控件消费或观察 * * @param target View that initiated the nested scroll * @param velocityX Horizontal velocity in pixels per second * @param velocityY Vertical velocity in pixels per second * @param consumed true if the child consumed the fling, false otherwise * @return true if this parent consumed or otherwise reacted to the fling */ @Override public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed) { // Re-dispatch up the tree by default  return dispatchNestedFling(velocityX, velocityY, consumed); }     onStopNestedScroll\n对嵌套滚动结束的响应\n1 2 3 4 5 6 7 8 9 10 11 12  /** * 当嵌套滚动停止时，将调用此方法，在嵌套滚动操作之后执行清理。默认实现调用stopNestedScroll()来停止正在进行的任何递归嵌套滚动 * 例如当嵌套触摸滚动以{@link MotionEvent{ACTION_UP}或{@link MotionEvent{ACTION_CANCEL}事件结束时。 * 此方法的实现应始终调用其超类的此方法的实现（如果存在）。 * */ @Override public void onStopNestedScroll(View child) { // Stop any recursive nested scrolling.  stopNestedScroll(); mNestedScrollAxes = 0; }     NestedScrollingParent\u0026amp;ViewParent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public interface NestedScrollingParent { boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes); void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes); void onStopNestedScroll(@NonNull View target); void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed); void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed); boolean onNestedFling(@NonNull View target, float velocityX, float velocityY, boolean consumed); boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY); @ScrollAxis int getNestedScrollAxes(); }   NestedScrollingParent2 NestedScrollingParent2相比NestedScrollingParent主要增加了对fling消费的支持。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public interface NestedScrollingParent2 extends NestedScrollingParent { boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); void onStopNestedScroll(@NonNull View target, @NestedScrollType int type); //当type=ViewCompat.TYPE_NON_TOUCH时，此方法是设计被fling状态时回调的  void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type); //当type=ViewCompat.TYPE_NON_TOUCH时，此方法是设计被fling状态时回调的  void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type); }   NestedScrollingParent3 1 2 3 4 5  public interface NestedScrollingParent3 extends NestedScrollingParent2 { void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @ViewCompat.NestedScrollType int type, @NonNull int[] consumed); }   NestedScrollingChildHelper\u0026amp;NestedScrollingParentHelper 具体看下RecyclerView实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151  @Override public boolean onTouchEvent(MotionEvent e) { switch (action) { case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: final int x = (int) (e.getX(index) + 0.5f); final int y = (int) (e.getY(index) + 0.5f); int dx = mLastTouchX - x; int dy = mLastTouchY - y; mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; if (dispatchNestedPreScroll( canScrollHorizontally ? dx : 0, canScrollVertically ? dy : 0, mReusableIntPair, mScrollOffset, TYPE_TOUCH )) { dx -= mReusableIntPair[0]; dy -= mReusableIntPair[1]; // Updated the nested offsets  mNestedOffsets[0] += mScrollOffset[0]; mNestedOffsets[1] += mScrollOffset[1]; // Scroll has initiated, prevent parents from intercepting  getParent().requestDisallowInterceptTouchEvent(true); } mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset, TYPE_TOUCH, mReusableIntPair); dx -= mReusableIntPair[0] dy -= mReusableIntPair[1] if (consumed[0] != 0 || consumed[1] != 0) { ... parent.requestDisallowInterceptTouchEvent(true) } break; case MotionEvent.ACTION_UP: if (!((xvel != 0 || yvel != 0) \u0026amp;\u0026amp; fling((int) xvel, (int) yvel))) { setScrollState(SCROLL_STATE_IDLE); } stopNestedScroll(TYPE_TOUCH); break; case MotionEvent.ACTION_CANCEL: stopNestedScroll(TYPE_TOUCH); break; } } public boolean fling(int velocityX, int velocityY) { ... //分发Fling事件，若父控件消费，子控件不再消费  if (!dispatchNestedPreFling(velocityX, velocityY)) { final boolean canScroll = canScrollHorizontal || canScrollVertical; //子控件消费之前分发父控件消费  dispatchNestedFling(velocityX, velocityY, canScroll); if (mOnFlingListener != null \u0026amp;\u0026amp; mOnFlingListener.onFling(velocityX, velocityY)) { return true; } if (canScroll) { int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE; if (canScrollHorizontal) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL; } if (canScrollVertical) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL; } //开始fling事件分发前置处理  startNestedScroll(nestedScrollAxis, TYPE_NON_TOUCH); velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity)); velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity)); mViewFlinger.fling(velocityX, velocityY); return true; } } return false; } class ViewFlinger implements Runnable { ViewFlinger() { mOverScroller = new OverScroller(getContext(), sQuinticInterpolator); } @Override public void run() { stop(); final OverScroller scroller = mOverScroller; if (scroller.computeScrollOffset()) { final int x = scroller.getCurrX(); final int y = scroller.getCurrY(); int unconsumedX = x - mLastFlingX; int unconsumedY = y - mLastFlingY; mLastFlingX = x; mLastFlingY = y; int consumedX = 0; int consumedY = 0; // Nested Pre Scroll  mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; //子控件未消费前分发fling事件询问父控件是否消费  if (dispatchNestedPreScroll(unconsumedX, unconsumedY, mReusableIntPair, null, TYPE_NON_TOUCH)) { unconsumedX -= mReusableIntPair[0]; unconsumedY -= mReusableIntPair[1]; } //子控件消费fling事件  scrollStep(unconsumedX, unconsumedY, mReusableIntPair); consumedX = mReusableIntPair[0]; consumedY = mReusableIntPair[1]; unconsumedX -= consumedX; unconsumedY -= consumedY; mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; //子控件消费完再次分发询问父控件消费fling事件  dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, null, TYPE_NON_TOUCH, mReusableIntPair); unconsumedX -= mReusableIntPair[0]; unconsumedY -= mReusableIntPair[1]; if (consumedX != 0 || consumedY != 0) { dispatchOnScrolled(consumedX, consumedY); } ... postOnAnimation(); } mEatRunOnAnimationRequest = false; if (mReSchedulePostAnimationCallback) { internalPostOnAnimation(); } else { setScrollState(SCROLL_STATE_IDLE); //分发结束fling事件  stopNestedScroll(TYPE_NON_TOUCH); } } public void stop() { removeCallbacks(this); mOverScroller.abortAnimation(); } }   由RecyclerView源码可知nestedchild的dispatchNestedPreScroll(TYPE_NON_TOUCH)/dispatchNestedScroll(TYPE_NON_TOUCH)/stopNestedScroll(TYPE_NON_TOUCH)等方法及nestedparent的onNestedPreScroll(TYPE_NON_TOUCH)/onNestedScroll(TYPE_NON_TOUCH)/onStopNestedScroll(TYPE_NON_TOUCH)等方法均是针对fling增加的分发回调方法。因为之前针对fling的事件分发只有dispatchNestedPreFling/dispatchNestedFling及onNestedPreFling/onNestedFling。但这几个方法相对有局限性。比如dispatchNestedPreFling被父控件消费后子控件无法再次消费。dispatchNestedFling是在子控件消费fling事件之前分发给父控件处理，若想子控件处理fling事件后再次交给父控件处理则无能为力了。因此SDK新增了NestedScrollingXXX2，增加type区别touch和fling事件。\n总的来说NestedScrolling相关是SDK提供的一套有一定使用规则的接口api。其使用具体还看实现。具体可以参考文档.\n参考：\n 10分钟带你入门NestedScrolling机制  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%B5%8C%E5%A5%97/",
	"title": "嵌套",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%BB%91%E5%8A%A8/",
	"title": "滑动",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-scroller%E8%A7%A3%E6%9E%90/",
	"title": "Android Scroller解析及应用",
	"tags": ["android", "scroller", "源码解析", "滑动"],
	"categories": [],
	"series": ["源码解析"],
	"description": "Scroller 源码解析",
	"content": "OverScroller简介 OverScroller中两个重要属性：\n mMode有两个滚动模式：SCROLL_MODE FLING_MODE SplineOverScroller\nmState有三个滚动状态：SPLINE CUBIC BALLISTIC，查看源码可知： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void fling(int start, int velocity, int min, int max, int over) { ... if (start \u0026gt; max || start \u0026lt; min) { startAfterEdge(start, min, max, velocity); return; } mState = SPLINE; ... } private void onEdgeReached() { ... mState = BALLISTIC; ... } private void startSpringback(int start, int end, int velocity) { ... mState = CUBIC; ... }     OverScroller API解析   overScroller.setFriction()\nfriction是fling或者scroll时的摩擦系数标量值\n  overScroller.startScroll()\n开始滚动指定的距离，需要调用invalidate()触发重绘\n  overScroller.computeScrollOffset()\n先判断滚动是否结束，结束返回false，否则返回true，并计算出下一次的新位置\n  overScroller.currVelocity\n当前速度\n  overScroller.fling()\n以初始速度velocity滚动，滚动的距离取决于初始速度velocity，当滚动到minX/maxX和minY/maxY范围内时若velocity不为0会根据当前velocity计算滚动的距离和时间，并确保在minX/maxX和minY/maxY范围内为前提再滚动一定距离，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  void fling(int start, int velocity, int min, int max, int over) { mOver = over; mFinished = false; mCurrVelocity = mVelocity = velocity; mDuration = mSplineDuration = 0; mStartTime = AnimationUtils.currentAnimationTimeMillis(); mCurrentPosition = mStart = start; if (start \u0026gt; max || start \u0026lt; min) { startAfterEdge(start, min, max, velocity); return; } mState = SPLINE; double totalDistance = 0.0; if (velocity != 0) { mDuration = mSplineDuration = getSplineFlingDuration(velocity); totalDistance = getSplineFlingDistance(velocity); } mSplineDistance = (int) (totalDistance * Math.signum(velocity)); mFinal = start + mSplineDistance; // Clamp to a valid final position  if (mFinal \u0026lt; min) { adjustDuration(mStart, mFinal, min); mFinal = min; } if (mFinal \u0026gt; max) { adjustDuration(mStart, mFinal, max); mFinal = max; } }     overScroller.abortAnimation()\n停止滚动动画直接将当前位置置为finalX/finalY\n  overScroller.forceFinished()\n停止滚动，停留在当前滚动位置，只是简单将滚动结束标志置为true\n  overScroller.isFinished\n是否结束\n  overScroller.isOverScrolled\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Returns whether the current Scroller is currently returning to a valid position. * Valid bounds were provided by the * {@link #fling(int, int, int, int, int, int, int, int, int, int)} method. * * One should check this value before calling * {@link #startScroll(int, int, int, int)} as the interpolation currently in progress * to restore a valid position will then be stopped. The caller has to take into account * the fact that the started scroll will start from an overscrolled position. * * @return true when the current position is overscrolled and in the process of * interpolating back to a valid value. */ public boolean isOverScrolled() { return ((!mScrollerX.mFinished \u0026amp;\u0026amp; mScrollerX.mState != SplineOverScroller.SPLINE) || (!mScrollerY.mFinished \u0026amp;\u0026amp; mScrollerY.mState != SplineOverScroller.SPLINE)); }     overScroller.notifyHorizontalEdgeReached()\n  overScroller.notifyVerticalEdgeReached()\n  overScroller.springBack() 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public boolean springBack(int startX, int startY, int minX, int maxX, int minY, int maxY){ mMode = FLING_MODE; // Make sure both methods are called.  final boolean spingbackX = mScrollerX.springback(startX, minX, maxX); final boolean spingbackY = mScrollerY.springback(startY, minY, maxY); return spingbackX || spingbackY; } boolean springback(int start, int min, int max) { mFinished = true; ... if (start \u0026lt; min) { startSpringback(start, min, 0); } else if (start \u0026gt; max) { startSpringback(start, max, 0); } return !mFinished; } private void startSpringback(int start, int end, int velocity) { // mStartTime has been set  mFinished = false; }   可以看出，当(minX \u0026lt;= startX \u0026lt;= maxX) || (minY \u0026lt;= startY \u0026lt;= maxY)时返回false，否则返回true。当调用springBack(int startX, int startY, int minX, int maxX, int minY, int maxY)返回true时，调用invalidate()，然后在computeScroll()中调用OverScroller.computeScrollOffset()计算是否结束，而computeScrollOffset()会调用continueWhenFinished()，continueWhenFinished()再次调用startSpringback实现不断刷新\n  OverScroller 使用 通常自定义view中，在构造函数中初始化OverScroller，然后在onTouchEvent()的ACTION_UP中调用OverScroller的startScroll()或fling() 方法并调用invalidate()，然后在view的computeScroll()方法中调用OverScroller的computeScrollOffset()，若返回true，则做相应处理并再次调用invalidate()实现循环处理\nScroll 相关API View方法view.scrollBy()/view.scrollTo()/view.overScrollBy()  view.scrollBy()\n增量滚动，相对当前滚动位置再滚动x/y距离，最终调用scrollTo() 1 2 3  public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); }    view.scrollTo()\n滚动到指定的x/y位置 1 2 3 4 5 6 7 8 9 10 11 12 13  public void scrollTo(int x, int y) { if (mScrollX != x || mScrollY != y) { int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) { postInvalidateOnAnimation(); } } }    view.overScrollBy()\n  computeVerticalScrollOffset/computeVerticalScrollRange/computeVerticalScrollExtent/canScrollVertically 一般来说:computeVerticalScrollRange()=computeVerticalScrollOffset()+computeVerticalScrollExtent()+未显示部分的高度。canScrollVertically利用该算式实现的API\n  computeVerticalScrollOffset\nview垂直方向已滚动的距离，源码：\n1 2 3  protected int computeVerticalScrollOffset() { return mScrollY; }     computeVerticalScrollExtent\n当前view垂直方向上滑块在整个滚动范围代表的长度，其实就是滚动控件显示出来的这部分内容的高度，一般来说整个滚动控件都会用来显示内容，，即默认实现是滚动控件的高度\n1 2 3  protected int computeVerticalScrollExtent() { return getHeight(); }     computeVerticalScrollRange\n垂直滚动条代表的整个滚动范围。如果是View一般代表的是整个内容的高度，非滚动控件则是控件本身的高度。在ViewGroup(如：NestedScrollView)中即其所有子控件的总高度。\nNestedScrollView的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public int computeVerticalScrollRange() { final int count = getChildCount(); final int parentSpace = getHeight() - getPaddingBottom() - getPaddingTop(); if (count == 0) { return parentSpace; } View child = getChildAt(0); NestedScrollView.LayoutParams lp = (LayoutParams) child.getLayoutParams(); int scrollRange = child.getBottom() + lp.bottomMargin; final int scrollY = getScrollY(); final int overscrollBottom = Math.max(0, scrollRange - parentSpace); //如果是overscroll算上overscroll的距离  if (scrollY \u0026lt; 0) { scrollRange -= scrollY; } else if (scrollY \u0026gt; overscrollBottom) { scrollRange += scrollY - overscrollBottom; } return scrollRange; }     canScrollVertically\n是否可以垂直某个方向上滚动，下面源码可以看出是利用上面三个API实现的\n1 2 3 4 5 6 7 8 9 10  public boolean canScrollVertically(int direction) { final int offset = computeVerticalScrollOffset(); final int range = computeVerticalScrollRange() - computeVerticalScrollExtent(); if (range == 0) return false; if (direction \u0026lt; 0) { return offset \u0026gt; 0; } else { return offset \u0026lt; range - 1; } }     VelocityTracker  VelocityTracker\n跟踪触摸事件的速度，实现fling和类似手势的助手类。通常的使用如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @Override public boolean onTouchEvent(MotionEvent event) { int action = event.getActionMasked(); switch (action) { case MotionEvent.ACTION_DOWN: if (velocityTracker == null) { velocityTracker = VelocityTracker.obtain(); } else { velocityTracker.clear(); } break; case MotionEvent.ACTION_MOVE: velocityTracker.addMovement(event); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: velocityTracker.computeCurrentVelocity(1000); float velocity = velocityTracker.getYVelocity(); //todo  if (velocityTracker != null) { velocityTracker.recycle(); velocityTracker = null; } break; } return super.onTouchEvent(event); }    computeCurrentVelocity\n基于addMovement收集的触摸点计算当前速度，调用getYVelocity/getYVelocity获取速度前必须先调用这个方法    view.offsetLeftAndRight()/view.offsetTopAndBottom() 自定义 参考：\n 使用Fling动画移动视图 以动画方式显示滚动手势  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/scroller/",
	"title": "scroller",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/dir/fourth/",
	"title": "Fourth",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My fourth presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/",
	"title": "展厅",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Presentation list with reveal.js",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/third/",
	"title": "Third",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My third presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/second/",
	"title": "Second",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My second presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/first/",
	"title": "First",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My first presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/archive/",
	"title": "存档",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Archive Page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/adroid/",
	"title": "adroid",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app-bundle/",
	"title": "Android AppBundle",
	"tags": ["android", "AppBundle"],
	"categories": [],
	"series": ["android"],
	"description": "Android AppBundle",
	"content": "ClassLoader,java的ClassLoader双亲委托机制 干预Android加载，既然要干预那就要首先了解其原加载过程 ## 双亲委托 简单说类加载器的双亲委托就是在当前类加载器加载某个类之前先逐级向上询问父类加载器是否已加载过(是否已有类的缓存)，如果已加载就返回，如果未加载则有当前类加载器加载该类。你可能会问ClassLoader本身也是一个类，它是怎么被加载的呢？在jvm启动的时候就有一个根ClassLoader,即：bootstrapclassloader\n设计双亲委托模式的好处： 1.避免重复加载 2.安全，避免核心api被修改 ## PathClassLoader和DexClassLoader源码分析 要做热更新就要用`ClassLoader`加载hotfix dex中的类,用哪个`ClassLoader`呢？我们在Activity中打印`classLoader::class.java.name`可以看到是`dalvik.system.PathClassLoader` 查看`PathClassLoader` ``` java public PathClassLoader(String dexPath, ClassLoader parent) { super(dexPath, null, null, parent); } public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) { super(dexPath, null, librarySearchPath, parent); } ``` 只有几个构造方法，但`PathClassLoader`继承自`BaseDexClassLoader`，继续进入`BaseDexClassLoader`查看 ``` java protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { // 首先检查是否已经加载过 Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //parent.loadClass可鞥在此抛出异常 } if (c == null) { c = findClass(name); } } return c; } ``` `loadClass`首先检查是不是已加载过这个类，若没有，调用父ClassLoader的`loadClass`，以此上推检查父ClassLoader是否加载过此类，若都没有加载则调用`findClass` ``` java @Override protected Class findClass(String name) throws ClassNotFoundException { // First, check whether the class is present in our shared libraries. if (sharedLibraryLoaders != null) { for (ClassLoader loader : sharedLibraryLoaders) { try { return loader.loadClass(name); } catch (ClassNotFoundException ignored) { } } } // Check whether the class in question is present in the dexPath that // this classloader operates on. List suppressedExceptions = new ArrayList(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( \"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; } ``` 最终执行到`Class c = pathList.findClass(name, suppressedExceptions);`，再继续查看`DexPathList`的`findClass`方法 ``` java public Class findClass(String name, List suppressed) { for (Element element : dexElements) { Class clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } ``` 再继续进入`Element`的`findClass`方法 ``` java public Class findClass(String name, ClassLoader definingContext,List suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed): null; } ``` 参考： [Android N混合编译与对热补丁影响解析](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==\u0026mid=2649286341\u0026idx=1\u0026sn=054d595af6e824cbe4edd79427fc2706\u0026scene=0%23wechat_redirect)\n[安卓App热补丁动态修复技术介绍](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==\u0026mid=400118620\u0026idx=1\u0026sn=b4fdd5055731290eef12ad0d17f39d4a) --  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/",
	"title": "Android-App启动流程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android-App启动流程",
	"content": "Android启动流程 ROM/RAM ROM(Read-Only Memory)\nRAM(Random Access Memory)\nBoot ROM 它负责加载引导程序Boot Loader。\nBoot Loader 固化在ROM中的引导程序，主要是检查RAM，初始化系统参数等功能。\nAndroid内核(Kernel)层 Kernel层即是Android系统的内核层。Kernel层通过系统调用(SysCall)调用\n系统调用(SysCall)层 SysCall是内核层提供的用户空间程序与内核空间进行交互的一套标准接口。是连接用户态和内核态的桥梁，它提供了用户态程序受限访问系统内核空间资源的能力。用户空间通过向内核空间发起SysCall产生软中断让用户程序陷入内核态执行相应的操作。\nNative层 Native层主要包括用户守护进程、开机动画(bootanim)、ServiceManager及硬件抽象层(HAL)。\n内核态通过SysCall创建Native层init进程，init进程是所有用户进程的鼻祖。init进程主要做了：\n 孵化出用户守护进程、 启动开机动画(bootanim)及ServiceManager等重要服务。 孵化Zygote进程。Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程。  Framework层 SystemServer是Zygote fork的第一个进程，SystemServer中会启动各种服务(Android中服务包括引导服务、核心服务、其他服务)，包括AMS、WMS、PMS等重要服务(这些服务都运行在SystemServer进程，比如AMS运行在SystemServer进程的一个单独线程中)。\nSystemServer进程 SystemServer#run()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private void run() { ... // Start services.  try { traceBeginAndSlog(\u0026#34;StartServices\u0026#34;); startBootstrapServices();//引导服务，包括AMS、WMS、PMS等  startCoreServices();//核心服务  startOtherServices();//其他服务  SystemServerInitThreadPool.shutdown(); } catch (Throwable ex) { Slog.e(\u0026#34;System\u0026#34;, \u0026#34;******************************************\u0026#34;); Slog.e(\u0026#34;System\u0026#34;, \u0026#34;************ Failure starting system services\u0026#34;, ex); throw ex; } finally { traceEnd(); } }   SystemService\nSystemService是一个抽象类，Android中有一类继承自SystemService的系统服务。在系统启动时由SystemServiceManager负责实例化并启动各个SystemService，SystemService会被保存在SystemServiceManager中，大部分SystemService在启动执行到onStart时会调用自己的publishBinderService将自己的IBinder添加到ServiceManager中管理。你可能会问为什么SystemService的对象添加到SystemServiceManager，IBinder对象又添加到ServiceManager中呢？我们要明白Binder机制是设计用于跨进程通信的，所以SystemServiceManager持有SystemService对象主要是同在SystemServer进程的其他系统服务，如AMS使用的，ServiceManager持有SystemService的IBinder对象是为了方便跨进程获取的服务的IBinder对象进行通信的。当然ServiceManager并不只有SystemService这一类服务的IBinder对象。\nSystemService#publishBinderService\n1 2 3 4  protected final void publishBinderService(String name, IBinder service, boolean allowIsolated, int dumpPriority) { ServiceManager.addService(name, service, allowIsolated, dumpPriority); }   SystemServiceManager\nSystemServiceManager是一个专门用于启动管理(继承自)SystemService(系统服务)的类。SystemServiceManager中有一个ArrayList集合：\n1  private final ArrayList\u0026lt;SystemService\u0026gt; mServices = new ArrayList\u0026lt;SystemService\u0026gt;();   当SystemServer#run()中调用startBootstrapServices()时，startBootstrapServices()内部会调用一些列的SystemServiceManager#startService方法启动各个SystemService(比如：Installer、PowerManagerService、DisplayManagerService等)并将启动的SystemService添加到mServices集合。\nSystemServiceManager#startService\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  public \u0026lt;T extends SystemService\u0026gt; T startService(Class\u0026lt;T\u0026gt; serviceClass) { try { final String name = serviceClass.getName(); Slog.i(TAG, \u0026#34;Starting \u0026#34; + name); Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \u0026#34;StartService \u0026#34; + name); // Create the service.  if (!SystemService.class.isAssignableFrom(serviceClass)) { throw new RuntimeException(\u0026#34;Failed to create \u0026#34; + name + \u0026#34;: service must extend \u0026#34; + SystemService.class.getName()); } final T service; try { Constructor\u0026lt;T\u0026gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); } catch (InstantiationException ex) { throw new RuntimeException(\u0026#34;Failed to create service \u0026#34; + name + \u0026#34;: service could not be instantiated\u0026#34;, ex); } catch (IllegalAccessException ex) { throw new RuntimeException(\u0026#34;Failed to create service \u0026#34; + name + \u0026#34;: service must have a public constructor with a Context argument\u0026#34;, ex); } catch (NoSuchMethodException ex) { throw new RuntimeException(\u0026#34;Failed to create service \u0026#34; + name + \u0026#34;: service must have a public constructor with a Context argument\u0026#34;, ex); } catch (InvocationTargetException ex) { throw new RuntimeException(\u0026#34;Failed to create service \u0026#34; + name + \u0026#34;: service constructor threw an exception\u0026#34;, ex); } startService(service); return service; } finally { Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); } } public void startService(@NonNull final SystemService service) { // Register it.  mServices.add(service); // Start it.  long time = SystemClock.elapsedRealtime(); try { service.onStart(); } catch (RuntimeException ex) { throw new RuntimeException(\u0026#34;Failed to start service \u0026#34; + service.getClass().getName() + \u0026#34;: onStart threw an exception\u0026#34;, ex); } warnIfTooLong(SystemClock.elapsedRealtime() - time, service, \u0026#34;onStart\u0026#34;); }   ServiceManager\nServiceManager\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public final class ServiceManager { private static IServiceManager sServiceManager; /** * Cache for the \u0026#34;well known\u0026#34; services, such as WM and AM. */ private static HashMap\u0026lt;String, IBinder\u0026gt; sCache = new HashMap\u0026lt;String, IBinder\u0026gt;(); private static IServiceManager getIServiceManager() { if (sServiceManager != null) { return sServiceManager; } // Find the service manager  sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager; } public static void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) { try { getIServiceManager().addService(name, service, allowIsolated, dumpPriority); } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in addService\u0026#34;, e); } } }   App启动 经过上面的步骤，系统已经启动完成，各种系统服务也已经启动好，环境已经就绪。于是你点击了桌面应用图标启动一个应用程序。Launcher进程会想SystemServer进程中的AMS发起请求启动应用程序，AMS会向Zygote进程请求创建应用程序进程，Zygote进程接收到请求fork一个应用程序进程。当应用进程准备好后，AMS会想应用进程请求创建根Activity，最终执行到ActivityThread#ApplicationThread创建启动根Activity。\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-apt/",
	"title": "Android-APT",
	"tags": ["apt"],
	"categories": [],
	"series": ["android"],
	"description": "Android-APT详解",
	"content": "APT(Annotation Processor Tool) 注解处理器(APT)它是Java提供的帮我们处理注解的。要实现我们自己的处理注解的逻辑就需要继承Processor接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13  public interface Processor { Set\u0026lt;String\u0026gt; getSupportedOptions(); Set\u0026lt;String\u0026gt; getSupportedAnnotationTypes(); SourceVersion getSupportedSourceVersion(); void init(ProcessingEnvironment var1); boolean process(Set\u0026lt;? extends TypeElement\u0026gt; var1, RoundEnvironment var2); Iterable\u0026lt;? extends Completion\u0026gt; getCompletions(Element var1, AnnotationMirror var2, ExecutableElement var3, String var4); }   Processor还有个抽象类AbstractProcessor，我们自定义注解处理器一般都是继承AbstractProcessor，AbstractProcessor提供的默认实现主要是读取自定义Processor类的注解SupportedOptions、SupportedAnnotationTypes、SupportedSourceVersion，分别对应getSupportedOptions()、getSupportedAnnotationTypes()、getSupportedSourceVersion()三个方法，用配置的形式让我们写起来更方便。\n如果 APT 处理 Annotation 时产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。\n辅助类库 AutoService auto-service是谷歌提供的工具库，可以帮我们自动注册Processor，即自动生成 META-INF/services/javax.annotation.processing.Processor 文件，并注册我们自定义的Processor。如果不使用auto-service就需要我们手动添加。\nJavapoet Javapoet是让我们可以使用面向对象的方式生成Java源码的库且不需要自己导包，我们当然可以使用字符串拼接的方式，但这样容易出错，不能自动导包。\n向注解处理器传递参数 1 2 3 4 5 6 7 8 9 10 11 12  android { ... defaultConfig { ... javaCompileOptions { annotationProcessorOptions { argument \u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34; argument \u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34; } } } }   或者\n1 2 3 4 5 6 7 8 9 10 11  android { ... defaultConfig { ... javaCompileOptions { annotationProcessorOptions { arguments = [key1: value1, key2: value2] } } } }   使用示例 使用自定义APT实现自己的一个简版ARouter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187  @AutoService(Processor.class) @SupportedSourceVersion(SourceVersion.RELEASE_8) @SupportedAnnotationTypes({Config.AX_ROUTER_ANN_NAME}) @SupportedOptions({Config.OPTIONS_MODULE_KEY, Config.AX_ROUTER_OPTIONS_PACKAGE}) public class AxRouterProcessor extends AbstractProcessor { private Map\u0026lt;String, Set\u0026lt;RouteMeta\u0026gt;\u0026gt; groupMap = new HashMap\u0026lt;\u0026gt;(); private Map\u0026lt;String, String\u0026gt; rootMap = new TreeMap\u0026lt;\u0026gt;(); //Element工具类(类、函数、属性、包名都是Element)  private Elements elementUtils; private Types typeUtils; //用来打印Log信息  private Messager messager; //文件生成器  private Filer filer; //gradle中传递过来的参数  private String routerModule; TypeElement iRouteGroup; TypeElement iRouteRoot; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) { super.init(processingEnvironment); elementUtils = processingEnvironment.getElementUtils(); typeUtils = processingEnvironment.getTypeUtils(); messager = processingEnvironment.getMessager(); filer = processingEnvironment.getFiler(); Map\u0026lt;String, String\u0026gt; options = processingEnvironment.getOptions(); routerModule = options.get(Config.OPTIONS_MODULE_KEY); messager.printMessage(Diagnostic.Kind.NOTE, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; AxRouterProcessor init routerModule:\u0026#34; + routerModule); iRouteGroup = elementUtils.getTypeElement(Config.I_ROUTE_GROUP); iRouteRoot = elementUtils.getTypeElement(Config.I_ROUTE_ROOT); } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; set, RoundEnvironment roundEnvironment) { messager.printMessage(Diagnostic.Kind.NOTE, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; AxRouterProcessor process:\u0026#34;); if (set.isEmpty()) { messager.printMessage(Diagnostic.Kind.NOTE, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 没有发现 被@Router 注解的地方\u0026#34;); return false; } TypeMirror activityMirror = elementUtils.getTypeElement(RouteMeta.Type.ACTIVITY.getClassName()).asType(); Set\u0026lt;? extends Element\u0026gt; AxRouters = roundEnvironment.getElementsAnnotatedWith(Route.class); messager.printMessage(Diagnostic.Kind.NOTE, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; AxRouterProcessor processxxxx:\u0026#34; + AxRouters.size()); for (Element element : AxRouters) { String pkg = elementUtils.getPackageOf(element).getQualifiedName().toString(); String clazz = element.getSimpleName().toString(); Route router = element.getAnnotation(Route.class); RouteMeta routeMeta = new RouteMeta.Builder() .setGroup(router.group()) .setPath(router.path()) .setElement(element) .build(); TypeMirror elementMirror = element.asType(); if (typeUtils.isSubtype(elementMirror, activityMirror)) { routeMeta.setType(RouteMeta.Type.ACTIVITY); } else { throw new IllegalArgumentException(\u0026#34;@Router目前仅支持Activity\u0026#34;); } if (!checkRoute(routeMeta)) { messager.printMessage(Diagnostic.Kind.ERROR, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + pkg + \u0026#34;.\u0026#34; + clazz + \u0026#34;的@Router的配置不符合规范\u0026#34;); } else { Set\u0026lt;RouteMeta\u0026gt; routeMetas = groupMap.get(routeMeta.getGroup()); if (routeMetas == null) { routeMetas = new HashSet\u0026lt;\u0026gt;(); groupMap.put(routeMeta.getGroup(), routeMetas); } routeMetas.add(routeMeta); } try { createRouteGroups(); } catch (IOException e) { e.printStackTrace(); } try { createRouteRoots(); } catch (IOException e) { e.printStackTrace(); } } return true; } /** * 检查routeMeta的合法性 * * @param routeMeta * @return */ boolean checkRoute(RouteMeta routeMeta) { return true; } private void createRouteGroups() throws IOException { TypeName routerGroupPT = ParameterizedTypeName.get( ClassName.get(Map.class), ClassName.get(String.class), ClassName.get(RouteMeta.class) ); ParameterSpec routerGroupPS = ParameterSpec.builder(routerGroupPT, Config.ROUTE_GROUP_LOAD_INTO_PARAM_VAR).build(); MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(Config.LOAD_INTO_METHOD) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(routerGroupPS); for (Map.Entry\u0026lt;String, Set\u0026lt;RouteMeta\u0026gt;\u0026gt; entry : groupMap.entrySet()) { Set\u0026lt;RouteMeta\u0026gt; routeMetas = entry.getValue(); for (RouteMeta routeMeta : routeMetas) { // atlas.put(\u0026#34;/app/MainActivity\u0026#34;,RouteMeta.build(group,path, type,destination))  methodBuilder.addStatement( \u0026#34;$N.put($S, $T.build($S, $S, $T.\u0026#34; + routeMeta.getType() + \u0026#34;, $T.class))\u0026#34;, Config.ROUTE_GROUP_LOAD_INTO_PARAM_VAR, routeMeta.getPath(), ClassName.get(RouteMeta.class), routeMeta.getGroup(), routeMeta.getPath(), ClassName.get(RouteMeta.Type.class), ClassName.get((TypeElement) routeMeta.getElement())); } String fileName = Config.AX_ROUTER_APT_ROUTE_GROUP_FILE + entry.getKey(); JavaFile.builder(Config.AX_ROUTER_APT_GEN_PACKAGE, TypeSpec.classBuilder(fileName) .addSuperinterface(ClassName.get(iRouteGroup)) .addJavadoc(Config.WARNING_TIPS) .addModifiers(PUBLIC) // public修饰符  .addMethod(methodBuilder.build()) // 方法的构建（方法参数 + 方法体）  .build()) // 类构建完成  .build() // JavaFile构建完成  .writeTo(filer); // 文件生成器开始生成类文件  rootMap.put(entry.getKey(), fileName); } } private void createRouteRoots() throws IOException { if (rootMap.isEmpty()) { return; } ParameterizedTypeName routerRootPT = ParameterizedTypeName.get( ClassName.get(Map.class), ClassName.get(String.class), ParameterizedTypeName.get( ClassName.get(Class.class), WildcardTypeName.subtypeOf(ClassName.get(iRouteGroup)) ) ); ParameterSpec routerRootPS = ParameterSpec.builder(routerRootPT, Config.ROUTE_ROOT_LOAD_INTO_PARAM_VAR).build(); MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(Config.LOAD_INTO_METHOD) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(routerRootPS); for (Map.Entry\u0026lt;String, String\u0026gt; entry : rootMap.entrySet()) { methodBuilder.addStatement(\u0026#34;$N.put($S, $T.class)\u0026#34;, Config.ROUTE_ROOT_LOAD_INTO_PARAM_VAR, entry.getKey(), ClassName.get(Config.AX_ROUTER_APT_GEN_PACKAGE, entry.getValue())); } String fileName = Config.AX_ROUTER_APT_ROUTE_ROOT_FILE + routerModule; JavaFile.builder(Config.AX_ROUTER_APT_GEN_PACKAGE, TypeSpec.classBuilder(fileName) .addJavadoc(Config.WARNING_TIPS) .addSuperinterface(ClassName.get(iRouteRoot)) .addModifiers(PUBLIC) .addMethod(methodBuilder.build()) .build() ).build().writeTo(filer); } }   参考：\n 添加注释处理器 AutoService JavaPoet  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-arouter%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/",
	"title": "Android-ARouter原理简析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android-ARouter原理简析",
	"content": "前言 阿里ARouter是组件开发所需的路由框架。由于组件开发中的类(尤其是Activity)不能直接相互引用，无法使用通常的跳转方式。\n隐式跳转：需要AndroidManifest.xml中配置，不便维护，也无法集中管理\nClass.forName：报名容易出错，业务逻辑修改将难以维护。\n阿里ARouter ARouter中有几个重要概念：Router、IInterceptor\u0026amp;IInterceptorGroup、IProvider\u0026amp;IProviderGroup。需要明白的是路由框架本质就是提供路由功能，其他的都是为路由功能服务的，是为了更好的控制路由的过程，所以IInterceptor\u0026amp;IInterceptorGroup、IProvider\u0026amp;IProviderGroup都是为Router服务的。\nARouter的主要原理和功能：使用APT，实现对路由信息的分组(模块)的懒加载。\nRouter、IInterceptor、IProvider相关的信息保存在仓库类Warehouse中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Warehouse { // Cache route and metas  static Map\u0026lt;String, Class\u0026lt;? extends IRouteGroup\u0026gt;\u0026gt; groupsIndex = new HashMap\u0026lt;\u0026gt;(); static Map\u0026lt;String, RouteMeta\u0026gt; routes = new HashMap\u0026lt;\u0026gt;(); // Cache provider  static Map\u0026lt;Class, IProvider\u0026gt; providers = new HashMap\u0026lt;\u0026gt;(); static Map\u0026lt;String, RouteMeta\u0026gt; providersIndex = new HashMap\u0026lt;\u0026gt;(); // Cache interceptor  static Map\u0026lt;Integer, Class\u0026lt;? extends IInterceptor\u0026gt;\u0026gt; interceptorsIndex = new UniqueKeyTreeMap\u0026lt;\u0026gt;(\u0026#34;More than one interceptors use same priority [%s]\u0026#34;); static List\u0026lt;IInterceptor\u0026gt; interceptors = new ArrayList\u0026lt;\u0026gt;(); static void clear() { routes.clear(); groupsIndex.clear(); providers.clear(); providersIndex.clear(); interceptors.clear(); interceptorsIndex.clear(); } }   Router ARouter会根据@Router注解的path和group(如果group为空，则使用配置的的AROUTER_MODULE_NAME)，使用APT技术为我们生成\nARouter$$Group$$group和ARouter$$Root$$group两个类，我这里没有配置group，使用了AROUTER_MODULE_NAME配置，即项目的Module名。\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class ARouter$$Group$$app implements IRouteGroup { @Override public void loadInto(Map\u0026lt;String, RouteMeta\u0026gt; atlas) { atlas.put(\u0026#34;/app/MainActivity\u0026#34;, RouteMeta.build(RouteType.ACTIVITY, MainActivity.class, \u0026#34;/app/mainactivity\u0026#34;, \u0026#34;app\u0026#34;, null, -1, -2147483648)); } } public class ARouter$$Root$$app implements IRouteRoot { @Override public void loadInto(Map\u0026lt;String, Class\u0026lt;? extends IRouteGroup\u0026gt;\u0026gt; routes) { routes.put(\u0026#34;app\u0026#34;, ARouter$$Group$$app.class); } }   RouteMeta是对@Router配置的封装，但并不仅仅包含@Router配置的path和group，在APT处理过程中还加入了RouteType等。\nIRouteGroup 记录当前group有哪些路由信息。\nIRouteRoot 记录每个group的路由信息由哪个IRouteGroup实现类加载。\n上面ARouter$$Group$$app和ARouter$$Root$$app中的方法loadInto的参数实际上就是Warehouse中的routes和groupsIndex\nARouter拦截器的使用 使用拦截器需要继承IInterceptor，且添加@Interceptor注解，注意@Interceptor注解中的优先级priority是不能相同的，当有多个拦截器时，拦截器的执行顺序是按照priority排序的。priority值越小优先级越高。\ncallback.onContinue表示继续执行，callback.onInterrupt表示拦截当前跳转。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  @Interceptor(name = \u0026#34;login\u0026#34;, priority = 3) public class LoginInterceptor implements IInterceptor { @Override public void process(Postcard postcard, InterceptorCallback callback) { if (\u0026#34;/order/MainActivity\u0026#34;.equals(postcard.getPath())) { callback.onContinue(postcard); } else { callback.onInterrupt(new Exception(\u0026#34;没有登陆\u0026#34;)); } } @Override public void init(Context context) { } }   自定义拦截器ARouter会帮我们生成ARouter$$Interceptors$$app类，帮我们自动将自定义的拦截器添加到Warehouse仓库。\nARouter$$Interceptors$$app：\n1 2 3 4 5 6  public class ARouter$$Interceptors$$app implements IInterceptorGroup { @Override public void loadInto(Map\u0026lt;Integer, Class\u0026lt;? extends IInterceptor\u0026gt;\u0026gt; interceptors) { interceptors.put(3, LoginInterceptor.class); } }   ARouter中的Service ARouter的Service需要继承IProvider。\nService一般定义在base模块，比如在其他子模块我们想获取登陆用户信息就可以一定一个Service用于获取用户信息。\n1 2 3 4 5 6 7 8 9 10 11 12  public interface UserService extends IProvider { UserInfo getUserInfo(); } @Route(path = \u0026#34;/ax/service/user\u0026#34;) public interface UserServiceImpl implements UserService { public UserInfo getUserInfo(){ ... } } UserInfo info = ARouter.getInstance().navigation(UserService.class).getUserInfo();   以上自定义Service后ARouter会自动生成ARouter$$Group$$ax和ARouter$$Providers$$app两个类帮我们将自定义Service添加到Warehouse仓库。\n1 2 3 4 5 6 7 8 9 10 11 12  public class ARouter$$Group$$ax implements IRouteGroup { @Override public void loadInto(Map\u0026lt;String, RouteMeta\u0026gt; atlas) { atlas.put(\u0026#34;/ax/service/user\u0026#34;, RouteMeta.build(RouteType.PROVIDER, UserServiceImpl.class, \u0026#34;/ax/service/user\u0026#34;, \u0026#34;ax\u0026#34;, null, -1, -2147483648)); } } public class ARouter$$Providers$$app implements IProviderGroup { @Override public void loadInto(Map\u0026lt;String, RouteMeta\u0026gt; providers) { providers.put(\u0026#34;com.osshare.ax.UserService\u0026#34;, RouteMeta.build(RouteType.PROVIDER, UserServiceImpl.class, \u0026#34;/ax/service/user\u0026#34;, \u0026#34;ax\u0026#34;, null, -1, -2147483648)); } }   我们看以下ARouter中自带的Service实现。\nInterceptorService是ARouter中调用拦截器逻辑的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public interface InterceptorService extends IProvider { /** * Do interceptions */ void doInterceptions(Postcard postcard, InterceptorCallback callback); } @Route(path = \u0026#34;/arouter/service/interceptor\u0026#34;) public class InterceptorServiceImpl implements InterceptorService { private static boolean interceptorHasInit; private static final Object interceptorInitLock = new Object(); @Override public void doInterceptions(final Postcard postcard, final InterceptorCallback callback) { ... } ... }   AutowiredService是ARouter中调用拦截器逻辑的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public interface AutowiredService extends IProvider { /** * Autowired core. * @param instance the instance who need autowired. */ void autowire(Object instance); } @Route(path = \u0026#34;/arouter/service/autowired\u0026#34;) public class AutowiredServiceImpl implements AutowiredService { private LruCache\u0026lt;String, ISyringe\u0026gt; classCache; private List\u0026lt;String\u0026gt; blackList; @Override public void init(Context context) { classCache = new LruCache\u0026lt;\u0026gt;(66); blackList = new ArrayList\u0026lt;\u0026gt;(); } @Override public void autowire(Object instance) { String className = instance.getClass().getName(); try { if (!blackList.contains(className)) { ISyringe autowiredHelper = classCache.get(className); if (null == autowiredHelper) { // No cache.  autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance(); } autowiredHelper.inject(instance); classCache.put(className, autowiredHelper); } } catch (Exception ex) { blackList.add(className); // This instance need not autowired.  } } }   参考： * [ARouter解析五：IoC与依赖注入](https://www.jianshu.com/p/31a1c2c3ee72) -- "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-ffmpeg%E4%BD%BF%E7%94%A8/",
	"title": "Android-FFmpeg使用",
	"tags": ["ffmpeg", "音视频", "android"],
	"categories": [],
	"series": [""],
	"description": "Android中FFmpeg的使用",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-ffmpeg%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8/",
	"title": "Android-FFmpeg打造自己的播放器",
	"tags": ["ffmpeg", "音视频"],
	"categories": [],
	"series": ["音视频"],
	"description": "Android-FFmpeg打造自己的播放器",
	"content": "如何实现 播放音频  SDL2 AudioTrack OpenSLES ijksdl  播放视频  SDL2 SurfaceView ANativeWindow ijksdl  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-flutter/",
	"title": "Android-Flutter",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android-Flutter使用",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-jnindk/",
	"title": "Android-JNI&amp;NDK",
	"tags": ["adroid", "ndk"],
	"categories": [],
	"series": ["ndk"],
	"description": "Android JNI&amp;NDK",
	"content": "前言 Linux系统Native动态库(.so)、静态库(.a)及目标文件(.o)。\nWindows系统Native动态库(.dll)、静态库(.lib)及目标文件(.obj)。\n目标文件(.o/.obj)是与源代码对应的二进制文件。静态库(.a/.lib)是多个目标文件的集合。\nJNI JNI是Java实现的Java代码与本地代码的交互规范和API。\nJNI的方法使用native修饰且没有方法体，如：public native int nativeMethod(String s);\n类型对应关系\njava类型 | jni类型 | 描述\n\u0026mdash;\u0026mdash;\u0026mdash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nboolean | jboolean | unsigned 8 bits\nbyte | jbyte | signed 8 bits\nchar | jchar | unsigned 16 bits\nshort | jshort | signed 16 bits\nint | jint | signed 32 bits\nlong | jlong | signed 64 bits\nfloat | jfloat | signed 32bit\ndouble | jdouble | signed 64 bits\nClass | jcalss | class类对象\nString | jstring | 字符串对象\nObject | jobject | 任何java对象\nbyte[] | jbyteArray | byte数组\nJNI C++的实现和C的实现 JNI 并没有完全使用C++实现，而是通过对C对JNI实现的包装来实现，即C++的实现是通过调用C的实现来完成的，因此C++中的JNI函数的JNIEnv实际上是(JNINativeInterface的)二级指针。\nJNI注册 JNI注册分静态注册和动态注册两种。\n静态注册 编写Java类JNITest.java，添加JNI(本地)方法。\n在将JNITest.java编译成class文件夹后使用javah path/to/JNITest生成头文件。然后添加.c/.cpp源文件，include头文件实现相应的方法。\n另外还有一种是在项目cpp文件夹添加一个源文件按相应规则可以将项目中所有JNI方法添加到这个文件。\n静态注册简单，但编写不方便，步骤也多，还需要遵循相应的命名规范，名字比较长。另外由于初次调用native函数时需要根据函数名在JNI层搜索对应的JNI(本地)函数建立对应关系的过程会比较耗时影响运行效率。\n动态注册 在JNI_OnLoad中注册，JNI_OnUnload中卸载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #define AUDIO_RECORDER_CLASS_PATH \u0026#34;com/osshare/media/record/AudioRecorder\u0026#34; JNINativeMethod audioRecorderMethods[] = { {\u0026#34;nativeEncode\u0026#34;, \u0026#34;([B)I\u0026#34;, (void *) audioEncode}, {\u0026#34;nativeStart\u0026#34;, \u0026#34;(Ljava/lang/String;)I\u0026#34;, (void *) audioStart}, {\u0026#34;nativeStop\u0026#34;, \u0026#34;()I\u0026#34;, (void *) audioStop} }; jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = NULL; jint ret = vm-\u0026gt;GetEnv((void **) \u0026amp;env, JNI_VERSION_1_6); if (ret != JNI_OK) { return ret; } jclass audioRecorderClazz = env-\u0026gt;FindClass(AUDIO_RECORDER_CLASS_PATH); ret = env-\u0026gt;RegisterNatives(audioRecorderClazz, audioRecorderMethods, sizeof(audioRecorderMethods) / sizeof(audioRecorderMethods[0])); if (ret != JNI_OK) { return ret; } return JNI_VERSION_1_6; } void JNI_OnUnload(JavaVM *vm, void *reserved) { JNIEnv *env = NULL; jint ret = vm-\u0026gt;GetEnv((void **) \u0026amp;env, JNI_VERSION_1_6); if (ret != JNI_OK) { return; } jclass audioRecorderClazz = env-\u0026gt;FindClass(AUDIO_RECORDER_CLASS_PATH); env-\u0026gt;UnregisterNatives(audioRecorderClazz); }   JNI签名    数据类型 签名     boolean Z   byte B   char C   short S   int I   long J   float F   double D   void V   object L + 以/分割的完整类型 + ;   Array [ + 数据元素类型的签名    示例：\nString \u0026ndash;\u0026gt; Ljava/lang/String;\nint[] \u0026ndash;\u0026gt; [I\nString[] \u0026ndash;\u0026gt; [Ljava/lang/String;\nint[][] \u0026ndash;\u0026gt; [[I\nJNI引用 在 JNI 规范中定义了三种引用:局部引用(Local Reference)、全局引用(Global Reference)、弱全局引用(Weak Global Reference)。\n  局部引用\n局部引用在本地方法执行完毕后一般会自动释放，但如果局部引用还被其他引用引用着就需要调用env-\u0026gt;DeleteLocalRef(jobject localRef)手动释放。\nenv-\u0026gt;NewLocalRef(jobject ref)\nenv-\u0026gt;DeleteLocalRef(jobject localRef)\n  全局引用\n全局变量需要调用env-\u0026gt;DeleteGlobalRef(jobject globalRef)手动释放。全局引用可以跨线程。\nenv-\u0026gt;NewGlobalRef(jobject obj)\nenv-\u0026gt;DeleteGlobalRef(jobject globalRef)\n  弱全局引用\n弱全局引用和全局引用在使用上是一致的(可以跨线程)，只是在JVM认为应该回收它的时候(比如内存紧张的时候)进行回收而被释放。或调用 DeleteWeakGlobalRef手动释放。\nenv-\u0026gt;NewWeakGlobalRef(jobject obj)\nenv-\u0026gt;DeleteWeakGlobalRef(jweak obj)\n  JNI常用方法介绍   GetXXX()和Releasexxx()\n对于构造方法的name是\u0026rdquo;\u0026lt;init\u0026gt;\u0026rdquo;\nGetMethodID()获取构造方法：GetMethodID(clazz,\u0026ldquo;\u0026rdquo;,\u0026quot;()V\u0026rdquo;);\n  env-\u0026gt;CallXXXMethod()、env-\u0026gt;CallXXXMethodA()和env-\u0026gt;CallXXXMethodV()\n  env-\u0026gt;Throw(jthrowable obj)和env-\u0026gt;ThrowNew(jclass clazz, const char* message)\n  env-\u0026gt;FindClass()、env-\u0026gt;DefineClass()、env-\u0026gt;GetObjectClass()、env-\u0026gt;GetSuperclass()\n  env-\u0026gt;AllocObject()\n  ExceptionCheck()、ExceptionClear()、ExceptionDescribe()、ExceptionOccurred()、FatalError()、Throw()和ThrowNew()\n ExceptionOccurred() 检查是否发生JNI异常 ExceptionClear() 清空JNI异常 ThrowNew() ThrowNew向Java抛出异常，让Java处理。    env-\u0026gt;FromReflectedField()、env-\u0026gt;FromReflectedMethod()、env-\u0026gt;ToReflectedField()和env-\u0026gt;ToReflectedMethod()\n  env-\u0026gt;NewXXX()  env-\u0026gt;RegisterNatives()和env-\u0026gt;UnregisterNatives()\n  env-\u0026gt;PopLocalFrame()和env-\u0026gt;PushLocalFrame()\n  env-\u0026gt;SetXXX()\n  野指针 异常处理 JNI的异常和Java中的异常处理流程是不一样的，Java遇到异常如果没有捕获，程序会立即停 止运行。而JNI遇到未决的异常不会改变程序的运行流程，也就是程序会继续往下走。\nJNI缓存机制 静态局部变量会缓存。\n1 2 3 4 5 6 7 8 9  extern \u0026#34;C\u0026#34; JNIEXPORT jint JNICALL Java_com_osshare_lcc_media_MMediaPlayer_nativeSetSurface(JNIEnv *env, jobject thiz,jobject surface){ static jfieldID fieldID = NULL; if(fieldID == NULL){ env-\u0026gt;GetFieldID(...); printf(\u0026#34;-----GetFieldID-----\\n\u0026#34;); } }   上面示例中静态局部变量是会缓存的，当在Java中多次调用Java_com_osshare_lcc_media_MMediaPlayer_nativeSetSurfaceJNI方法时，GetFieldID只会调用一次(\u0026mdash;\u0026ndash;GetFieldID\u0026mdash;\u0026ndash;只会打印一次)。\n什么是NDK NDK是Android提供的一个Native开发工具包。它实现了在Android中的JNI功能。它还提供了交叉编译器，将Native代码编译生成动态(.so)/静态(.a)库并打包到Apk的能力。\nC/C++编译器  gcc\nGNU C编译器。原本只能处理C语言，很快扩展，变得可处理C++ g++\nGNU c++编译器，后缀为.c的源文件，gcc把它当作是C程序，而g++当作是C++程序；后缀为.cpp的，两者都会认为是c++程序，g++会自动链接c++标准库stl，gcc不会，gcc不会定义__cplusplus宏，而g++会 clang\n一个C、C++、Object-C的轻量级编译器，基于LLVM（用于开发编译器相关的库），速度相比 gcc/g++更快。 GDB(GNU Project debugger)\nGUN开源组织发布的Unix/Linux下功能强大的基于命令行的程序调试工具。  静态库/动态库  静态库\n编译期链接函数库。即把所有用到的对象文件和函数库打包进来，运行时不在需要这些函数库一起使用，因此通常编译出来的文件会比较大。 动态库\n运行时链接函数库。这样不需要把函数库都提前打包进来。这可以实现进程间资源的共享，共享库编译出来的文件比较小。在Android中可以显著减小Apk大小。  本地编译/交叉编译  本地编译\n当前机器编译，当前机器使用，无法运行到其他类型的机器上 交叉编译\n当前机器编译目标机器使用的程序，比如编译FFmpeg，在Mac OS上编译Android可以使用的库需要交叉编译。  ABI(应用程序二进制接口)    ABI 支持的指令集 备注     armeabi ARMV5TE和更高版本 Thumb-1 在r16中已弃用，在r17中已移除。无硬浮点数   armeabi-v7a armeabi TThumb-2 TVFPv3-D16 与ARMv5、ARMv6设备不兼容   arm64-v8a AArch64    x86 x86(IA-32) MMX SSE/2/3 SSSE3 不支持MOVBE或SSE4   x86_64 x86-64 MMX SSE/2/3 SSSE3 SSE4.1、4.2 POPCNT     System.load(filename)和System.loadLibrary(libname)  System.load(filename) 加载native库，必须是native库文件的绝对路径 System.loadLibrary(libname) 通过库名加载native库，需要配置native库  linux shell脚本基础 ndk-build 在CMake之前Android基本都是通过编写Application.mk和Android.mk文件，使用ndk-build命令来完C/C++成编译。\n关于Application.mk和Android.mk的内容及规范见Android NDK指南的ndk-build部分。\n编写好Application.mk和Android.mk后进入到相应文件夹下(Android一般为jni)执行ndk-build命令\nAndroid CMake CMake使用见Android NDK\n参考：\n Android NDK Simpleperf Using the GNU Compiler Collection (GCC) 3.19.5 ARM Options  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-lottie/",
	"title": "Android-lottie",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android lottie动画",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-mvcmvp%E5%8F%8Amvvm/",
	"title": "Android-MVC、MVP及MVVM",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": "MVC Model+View+Controller\nModel：Java bean\nView：视图层\nController：控制器\nMVC在Java Web开发中很常见，但并不适合Android中使用。因为Androi中dActivity既是View又是Controller，达不到分层解耦的目的。\nMVP Model+View+Presenter\nModel：数据\nView：视图\nPresenter：业务逻辑控制，是Model和View的桥梁\nMVP是将Activity的业务逻辑部分抽象出来放到Presenter处理，Activity尽量只负责显示。Model则负责数据部分，如请求网络或查找缓存以及对请求数据的缓存策略及其他数据管理。三者通过接口回调相互关联。View接口中定义几个状态的方法回调，Activity实现在定义的状态回调中展示相应状态页面。\nMVVM Model+View+ViewModel\nMVVM并不是M+V+V+M，而是M+V+VM\nModel：业务数据模型\nView：视图\nViewModel：联系Model和View，实现双向绑定\nMVVM相比MVP的优势是实现了数据的双向绑定，动态感知，不像MVP需要一堆回调。然而在Android界面通常是一个XML，实现双向绑定并不易。\nGoogle推出了DataBing来支持MVVM模式。\nDataBinding DataBinding使用 Module下的build.gradle中\ndataBinding { enabled true } 进入xml页面，选中根元素，mac下option+回车，点击Convert to data binding layout\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;data class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;import alias=\u0026#34;\u0026#34; type=\u0026#34;com.osshare.dsh.dm.Chapter\u0026#34; /\u0026gt; \u0026lt;variable name=\u0026#34;chapter\u0026#34; type=\u0026#34;Chapter\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tvText\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/aqua\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;@{chapter.name}\u0026#34; android:textColor=\u0026#34;@color/white\u0026#34; android:textSize=\u0026#34;@dimen/textSize16\u0026#34; /\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; \u0026lt;/layout\u0026gt;    data\n默认情况下DataBinding会按照布局文件名的驼峰格式+Binding为类名生成Binding类，如：activity_main.xml，Binding类即为：ActivityMainBinding\n如果你想自定义这个类名可以使用data节点有个class属性设置自己想要的类名。 import\ntypes属性是绑定数据的全限定名，alias属性指定别名，如果不指定默认是不包含包路径的类名 variable\nname属性是绑定到xml中时所使用的名字，type是该变量的类型，如果import设置了alias属性即是alias，如果不设置即为不包含包路径的类名  Activity中\n1 2 3 4 5 6 7 8  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) mBinding = DataBindingUtil.setContentView(this, getLayoutId()) val chapter=... //数据绑定  mBinding.chapter=chapter }   Fragment中可以使用mBinding= DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)\n另外还可以绑定单击长按等事件\n 定义事件发生要执行的方法\nclass MyHandlers {\nfun onClickFriend(view: View) { \u0026hellip; }\n} xml中注册 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;data class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;import alias=\u0026#34;\u0026#34; type=\u0026#34;com.osshare.dsh.dm.Chapter\u0026#34; /\u0026gt; \u0026lt;variable name=\u0026#34;chapter\u0026#34; type=\u0026#34;Chapter\u0026#34; /\u0026gt; \u0026lt;variable name=\u0026#34;handlers\u0026#34; type=\u0026#34;com.example.MyHandlers\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tvText\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/aqua\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;@{chapter.name}\u0026#34; android:onClick=\u0026#34;@{handlers::onClickFriend}\u0026#34; android:textColor=\u0026#34;@color/white\u0026#34; android:textSize=\u0026#34;@dimen/textSize16\u0026#34; /\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; \u0026lt;/layout\u0026gt;    实现MVVM双向绑定\n只需要将android:text=\u0026quot;@{chapter.name}\u0026quot;改成android:text=\u0026quot;@={chapter.name}\u0026quot;\n双向绑定的情况下当我们调用dataBinding.tvText.text = \u0026quot;yyyyyyxxxxxx\u0026quot;时，dataBinding中的chapter的name也会被修改  另外结合ViewModel LiveData Room\nViewModel 确保数据在设备配置更改(如横竖屏切换导致的销毁重建)后仍然存在。\nRoom 在数据库发生更改时通知 LiveData，LiveData 进而使用修订后的数据更新界面。\nLiveData 具有生命周期感知的组件，并且可以感知数据的变化\n一般是ViewModel持有LiveData。\nRoom + ViewModel + LiveData + DataBinding 是比较完美的MVVM框架\nDataBinding原理 使用DataBinding后layout的xml文件会被拆分为两部分：\n build/intermediates/data_binding_layout_info_type_merge下的layout_info文件 xx  当 xml使用@{xx.xx}或使用@Bindable注解属性的get方法时，DataBinding会生成相应的BR文件属性\n0) { mBinding.setVariable(variableId, mViewModel) -- } "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-vrarmr/",
	"title": "Android-VR&amp;AR",
	"tags": ["vr", "ar", "mr"],
	"categories": [],
	"series": [""],
	"description": "Android-VR&amp;AR",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/",
	"title": "Android-事件分发机制",
	"tags": ["android"],
	"categories": [],
	"series": ["android", "自定义view"],
	"description": "Android-事件分发机制详解",
	"content": "View mAttachInfo初始化 查看View源码可以知道mAttachInfo是在dispatchAttachedToWindow中赋值的\nView#dispatchAttachedToWindow\n1 2 3 4 5 6 7  @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P) void dispatchAttachedToWindow(AttachInfo info, int visibility) { mAttachInfo = info; ... onAttachedToWindow(); ... }   继续追踪可以知道View的dispatchAttachedToWindow是在ViewGroup的dispatchAttachedToWindow调用的。\nViewGroup#dispatchAttachedToWindow\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Override @UnsupportedAppUsage void dispatchAttachedToWindow(AttachInfo info, int visibility) { mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; super.dispatchAttachedToWindow(info, visibility); mGroupFlags \u0026amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i \u0026lt; count; i++) { final View child = children[i]; child.dispatchAttachedToWindow(info, combineVisibility(visibility, child.getVisibility())); } final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size(); for (int i = 0; i \u0026lt; transientCount; ++i) { View view = mTransientViews.get(i); view.dispatchAttachedToWindow(info, combineVisibility(visibility, view.getVisibility())); } }   那么ViewGroup#dispatchAttachedToWindow最初是在哪调用的呢？答案是：Activity启动是执行ActivityThread.handleResumeActivity最终会调用到ViewRootImpl中，mAttachInfo即是在ViewRootImpl的构造方法中创建，并在ViewRootImpl#performTraversals中由DecorView调用dispatchAttachedToWindow实现mAttachInfo依次向下传递。\nViewRootImpl#performTraversals\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public ViewRootImpl(Context context, Display display) { ... mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this, context); ... } private void performTraversals() { ... mAttachInfo.mUse32BitDrawingCache = true; mAttachInfo.mWindowVisibility = viewVisibility; mAttachInfo.mRecomputeGlobalAttributes = false; ... //这里的host即是DecorView  host.dispatchAttachedToWindow(mAttachInfo, 0); mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); ... }   上面是在Activiy生命周期中的调用，如果是动态添加的View其dispatchAttachedToWindow是怎么调用的呢？顺着ViewGroup#addView方法可以看到最终会在addViewInner中调用。\n1 2 3 4 5  private void addViewInner(View child, int index, LayoutParams params,boolean preventRequestLayout) { ... child.dispatchAttachedToWindow(mAttachInfo, (mViewFlags\u0026amp;VISIBILITY_MASK)); ... }   isInTouchMode/isFocusableInTouchMode()/setFocusableInTouchMode(boolean) 是否是触摸模式。因为android不仅支持屏幕触摸操作还支持键盘等设备操作。当使用键盘操作时需要对当前操作的UI元素高亮(聚焦)让用户知道当前操作的是哪个UI元素。触摸操作时不需要一直高亮某个UI元素，用户操作的是哪个UI元素就去触摸哪个元素。触摸模式下只需要在按下时高亮(聚焦)即可，此时的高亮(聚焦)是由设置的pressed状态决定的。为了区别两种模式就有了touchmode，isInTouchMode即是当前是否是触摸模式。\nView#isInTouchMode\n1 2 3 4 5 6 7  public boolean isInTouchMode() { if (mAttachInfo != null) { return mAttachInfo.mInTouchMode; } else { return ViewRootImpl.isInTouchMode(); } }   上面说过触摸模式下不需要高亮(聚焦)，但某些特殊控件如：EditText需要在触摸模式下也能获取焦点。isFocusableInTouchMode()/setFocusableInTouchMode(boolean)判断/设置View在触摸模式下是否可以获取焦点\nonFilterTouchEventForSecurity 过滤TouchEvent应对安全策略。可以在这里过滤TouchEvent，false则丢弃TouchEvent，true则不过滤继续分发这个TouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * Filter the touch event to apply security policies. * * @param event The motion event to be filtered. * @return True if the event should be dispatched, false if the event should be dropped. * * @see #getFilterTouchesWhenObscured */ public boolean onFilterTouchEventForSecurity(MotionEvent event) { //noinspection RedundantIfStatement  if ((mViewFlags \u0026amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 \u0026amp;\u0026amp; (event.getFlags() \u0026amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) { // Window is obscured, drop this touch.  return false; } return true; }   什么是FILTER_TOUCHES_WHEN_OBSCURED和MotionEvent.FLAG_WINDOW_IS_OBSCURED呢，看View源码的一段注释：\n1 2 3 4 5 6 7 8 9 10  * To enable touch filtering, call {@link #setFilterTouchesWhenObscured(boolean)} or set the * android:filterTouchesWhenObscured layout attribute to true. When enabled, the framework * will discard touches that are received whenever the view\u0026#39;s window is obscured by * another visible window. As a result, the view will not receive touches whenever a * toast, dialog or other window appears above the view\u0026#39;s window. * \u0026lt;/p\u0026gt;\u0026lt;p\u0026gt; * For more fine-grained control over security, consider overriding the * {@link #onFilterTouchEventForSecurity(MotionEvent)} method to implement your own * security policy. See also {@link MotionEvent#FLAG_WINDOW_IS_OBSCURED}. * \u0026lt;/p\u0026gt;   说的清楚FILTER_TOUCHES_WHEN_OBSCURED是setFilterTouchesWhenObscured(boolean)设置的表示可以过滤模糊不清楚的TouchEvent，MotionEvent#FLAG_WINDOW_IS_OBSCURED表示当前TouchEvent是模糊不清楚的。什么是模糊不清楚呢？当toast dialog等显示在这个view上时在这个view区域上的TouchEvent对这个view来说即是模糊不清楚的，这个TouchEvent会被添加MotionEvent#FLAG_WINDOW_IS_OBSCUREDflag，view默认会过滤这样的TouchEvent。\nrequestDisallowInterceptTouchEvent 当子控件不想父控件及其祖先控件拦截TouchEvent时可以调用此方法，该方法会逐级调用父控件requestDisallowInterceptTouchEvent通知父控件及其祖先控件不要拦截\nViewGroup#requestDisallowInterceptTouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * Called when a child does not want this parent and its ancestors to * intercept touch events with * {@link ViewGroup#onInterceptTouchEvent(MotionEvent)}. * * \u0026lt;p\u0026gt;This parent should pass this call onto its parents. This parent must obey * this request for the duration of the touch (that is, only clear the flag * after this parent has received an up or a cancel.\u0026lt;/p\u0026gt; * * @param disallowIntercept True if the child does not want the parent to * intercept touch events. */ @Override public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We\u0026#39;re already in this state, assume our ancestors are too  return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags \u0026amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent  if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); } }   dispatchTouchEvent Android触摸事件的生成、传递和分发见深入理解Android之Touch事件的分发。最终会传递到ViewRootImpl调用ViewRootImpl#processPointerEvent处理。ViewRootImpl#processPointerEvent中会调用DecorView#dispatchPointerEvent处理。DecorView#dispatchPointerEvent会调用父类View#dispatchPointerEvent，该方法中判断event.isTouchEvent()，若是TouchEvent，调用DecorView#dispatchTouchEvent。DecorView#dispatchTouchEvent最终会调用Window#Callback#dispatchTouchEvent或者ViewGroup#dispatchTouchEvent。\nDecorView#dispatchTouchEvent \nViewRootImpl#processPointerEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  private int processPointerEvent(QueuedInputEvent q) { final MotionEvent event = (MotionEvent)q.mEvent; mAttachInfo.mUnbufferedDispatchRequested = false; mAttachInfo.mHandlingPointerEvent = true; boolean handled = mView.dispatchPointerEvent(event); maybeUpdatePointerIcon(event); maybeUpdateTooltip(event); mAttachInfo.mHandlingPointerEvent = false; if (mAttachInfo.mUnbufferedDispatchRequested \u0026amp;\u0026amp; !mUnbufferedInputDispatch) { mUnbufferedInputDispatch = true; if (mConsumeBatchedInputScheduled) { scheduleConsumeBatchedInputImmediately(); } } return handled ? FINISH_HANDLED : FORWARD; }   View#dispatchPointerEvent\n1 2 3 4 5 6 7 8  @UnsupportedAppUsage public final boolean dispatchPointerEvent(MotionEvent event) { if (event.isTouchEvent()) { return dispatchTouchEvent(event); } else { return dispatchGenericMotionEvent(event); } }   DecorView#dispatchTouchEvent\n1 2 3 4 5 6 7 8 9 10  /** The feature ID of the panel, or -1 if this is the application\u0026#39;s DecorView */ private final int mFeatureId; @Override public boolean dispatchTouchEvent(MotionEvent ev) { final Window.Callback cb = mWindow.getCallback(); //如果当前window#Callback不为null，window也没有销毁，且window的panel是DecorView则调用window#Callback的dispatchTouchEvent，否则调用ViewGroup#dispatchTouchEvent  return cb != null \u0026amp;\u0026amp; !mWindow.isDestroyed() \u0026amp;\u0026amp; mFeatureId \u0026lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); }   Activity#dispatchTouchEvent Activity是继承Window.Callback的，由上面DecorView#dispatchTouchEvent源码可知Activity中DecorView#dispatchTouchEvent会走Window.Callback#dispatchTouchEvent。即Activity#dispatchTouchEvent。\n从ViewRootImpl开始到Activity的调用链：ViewRootImpl#processPointerEvent -\u0026gt; DecorView#dispatchPointerEvent -\u0026gt; View#dispatchPointerEvent -\u0026gt; DecorView#dispatchTouchEvent -\u0026gt; Activity#dispatchTouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { // 回调表示当前activity进入和用户互动状态，与之对应的是onUserLeaveHint，该方法由performUserLeaving方法调用，而performUserLeaving是在ActivityThread#handlePauseActivity中满足userLeaving参数为true时调用。那么userLeaving什么情况下为true呢？大致是用户主动操作导致activity进入pause状态时。非用户主动操作如来电导致当前activity进入pasuse时userLeaving=false，performUserLeaving不会被调用。需要注意的是performUserLeaving不只调用onUserLeaveHint还会再次调用onUserInteraction。所以onUserInteraction可能会被调用两次。onUserInteraction回调旨在帮助activities智能地管理状态栏通知；特别是帮助activities确定取消通知的正确时间  onUserInteraction(); } //调用window的superDispatchTouchEvent分发事件。最终是PhoneWindow#superDispatchTouchEvent调用DecorView#superDispatchTouchEvent，再由DecorView#superDispatchTouchEvent调用DecorView#dispatchTouchEvent实现逐级下发询问子控件  if (getWindow().superDispatchTouchEvent(ev)) { return true; } //如果没有view消费TouchEvent，则调用activity的onTouchEvent处理  return onTouchEvent(ev); } public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; }   View#dispatchTouchEvent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  public boolean dispatchTouchEvent(MotionEvent event) { ... boolean result = false; //开启本view检查器检查事件的连续性  if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); //如果是ACTION_DOWN事件，通知可能存在的上一次嵌套滚动停止  if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture  stopNestedScroll(); } //如果事件没有被过滤丢弃  if (onFilterTouchEventForSecurity(event)) { //控件是enable状态且事件被scrollbar消费  if ((mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement  ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnTouchListener != null \u0026amp;\u0026amp; (mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } //如果事件没有被scrollbar/OnTouchListener消费询问控件本身是否消费  if (!result \u0026amp;\u0026amp; onTouchEvent(event)) { result = true; } } //通知事件连续性验证器事件未被本view消费，不再做事件连续性验证  if (!result \u0026amp;\u0026amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } // Clean up after nested scrolls if this is the end of a gesture;  // also cancel it if we tried an ACTION_DOWN but we didn\u0026#39;t want the rest  // of the gesture.  //如果事件结束或者当前view没有消费事件，通知嵌套滚动通知滚动  if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; !result)) { stopNestedScroll(); } return result; }   ViewGroup#dispatchTouchEvent 分析源码前我们首先要了解一个变量：mFirstTouchTarget。它是一个链表的结构将TouchTargets链接起来。而这个mFirstTouchTarget就是链表的首个元素。其初始化是在ViewGroup#dispatchTouchEvent中调用的addTouchTarget中初始化的。addTouchTarget唯一被ViewGroup#dispatchTouchEvent调用。\ndispatchTouchEvent流程：\n如果是ACTION_DOWN事件，先清除之前可能因为app切换/ANR或者其他一些状态改变导致的未完成的事件序列，正常的时间序列应该是ACTION_DOWN-\u0026gt;ACTION_UP/ACTION_CANCEL。如果有未完成的事件序列则发送一个ACTION_CANCEL事件结束这个事件序列以便开始当前ACTION_DOWN事件触发的事件序列。清除动作包括清除相关flag，释放TouchTargets，将mFirstTouchTarget置为null\n1 2 3  // First touch target in the linked list of touch targets. @UnsupportedAppUsage private TouchTarget mFirstTouchTarget;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347  public boolean dispatchTouchEvent(MotionEvent ev) { //开启ViewGroup EventConsistency检查器检查事件的连续性  if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } ... boolean handled = false; //如果事件没有被过滤丢弃  if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action \u0026amp; MotionEvent.ACTION_MASK; // Handle an initial down.  if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture.  // The framework may have dropped the up or cancel event for the previous gesture  // due to an app switch, ANR, or some other state change.  //1.清除View(target.child)暂不接受TouchEvent的标志：PFLAG_CANCEL_NEXT_UP_EVENT以便接收新的事件序列  //2.如果mFirstTouchTarget不为null则会合成cancel event或者将ev暂时设置成ACTION_CANCEL传递给TouchTargets完成事件序列或者叫做清除上次的事件序列目的是以此次ACTION_DOWN event事件作为新的事件序列。  //3.mFirstTouchTarget重置为null  cancelAndClearTouchTargets(ev); //清除相关flag  resetTouchState(); // private void resetTouchState() {  // clearTouchTargets();  // resetCancelNextUpFlag(this);  // mGroupFlags \u0026amp;= ~FLAG_DISALLOW_INTERCEPT;  // mNestedScrollAxes = SCROLL_AXIS_NONE;  // }  } // Check for interception.  final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { //检查子控件是否调用了requestDisallowInterceptTouchEvent通知父控件不要拦截  //由于ACTION_DOWN时前面的resetTouchState会被调用，而resetTouchState方法中有 mGroupFlags \u0026amp;= ~FLAG_DISALLOW_INTERCEPT;，所以当ACTION_DOWN时此处的disallowIntercept肯定为false，即ACTION_DOWN时肯定会执行onInterceptTouchEvent，若在ACTION_DOWN时当前ViewGroup#onInterceptTouchEvent就返回true，那么子控件调用mParent.requestDisallowInterceptTouchEvent也是没用的。  final boolean disallowIntercept = (mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); //由于在上面的cancelAndClearTouchTargets-\u0026gt;dispatchTransformedTouchEvent方法中action有可能被临时设置为ACTION_CANCEL，在这里对其恢复  ev.setAction(action); // restore action in case it was changed  } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down  // so this view group continues to intercept touches.  intercepted = true; } // If intercepted, start normal event dispatch. Also if there is already  // a view that is handling the gesture, do normal event dispatch.  if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // Check for cancelation.  final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed.  final boolean split = (mGroupFlags \u0026amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //既不是ACTION_CANCEL事件且当前ViewGroup又不拦截  if (!canceled \u0026amp;\u0026amp; !intercepted) { // If the event is targeting accessibility focus we give it to the  // view that has accessibility focus and if it does not handle it  // we clear the flag and dispatch the event to all children as usual.  // We are looking up the accessibility focused host to avoid keeping  // state since these events are very rare.  View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down  final int idBitsToAssign = split ? 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they  // have become out of sync.  //清除此pointer id的早期touch targets，以防它们不同步。比如之前这个pointers作用的是A view，先在的ACTION_DOWN事件序列即将作用在B view上，需要先清除，防止同时对A view/B view都有效果  removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026amp;\u0026amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event.  // Scan children from front to back.  //buildTouchDispatchChildList是一个按View Z值排序的list。  final ArrayList\u0026lt;View\u0026gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026amp;\u0026amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i \u0026gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it  // to get the event first and if not handled we will perform a  // normal dispatch. We may do a double iteration but this is  // safer given the timeframe.  if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //canReceivePointerEvents:child可见或者child执行动画中  //isTransformedTouchPointInView:触摸点在child范围内  if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds.  // Give it the new pointer in addition to the ones it is handling.  newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); //向child传递触摸事件，如果消费了事件执行下面内容  if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds.  mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index  for (int j = 0; j \u0026lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn\u0026#39;t handle the event, so clear  // the flag and do a normal dispatch to all children.  ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null \u0026amp;\u0026amp; mFirstTouchTarget != null) { // Did not find a child to receive the event.  // Assign the pointer to the least recently added target.  newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets.  if (mFirstTouchTarget == null) {//事件被自己拦截或没有view消费事件导致mFirstTouchTarget==null  // No touch targets so treat this as an ordinary view.  //handled:true 自己消费了事件  //handled:false 自己未消费事件  handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else {//有view消费事件  // Dispatch to touch targets, excluding the new touch target if we already  // dispatched to it. Cancel touch targets if necessary.  TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026amp;\u0026amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed.  if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } //通知事件连续性验证器事件未被本view消费，不再做事件连续性验证  if (!handled \u0026amp;\u0026amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } } /** * Cancels and clears all touch targets. */ private void cancelAndClearTouchTargets(MotionEvent event) { //如果已经有TouchTarget就构造一个取消触摸事件传递给TouchTarget用于完成整个事件序列  if (mFirstTouchTarget != null) { boolean syntheticEvent = false; if (event == null) { final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; } for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) { //PFLAG_CANCEL_NEXT_UP_EVENT 意为自这次打上该标志起不再接受后面的TouchEvent事件  //清除TouchTarget中被打上暂不接受TouchEvent的标志：PFLAG_CANCEL_NEXT_UP_EVENT以便重新开始接受触摸事件序列。  resetCancelNextUpFlag(target.child); //分发取消TouchEvent完成整个事件序列  dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); } //循环释放TouchTargets对象，将mFirstTouchTarget重置为null  clearTouchTargets(); if (syntheticEvent) { event.recycle(); } } } /** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ //将MotionEvent转换为特定子视图的坐标空间，过滤掉不相关的指针ID，并根据需要覆盖其操作。如果child为空，则假定MotionEvent将被发送到此ViewGroup private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don\u0026#39;t need to perform any transformations  // or filtering. The important part is the action, not the contents.  final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver.  final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits \u0026amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we  // might produce a motion event with no pointers in it, then drop the event.  if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don\u0026#39;t need to perform any fancy  // irreversible transformations, then we can reuse the motion event for this  // dispatch as long as we are careful to revert any changes we make.  // Otherwise we need to make a copy.  final MotionEvent transformedEvent; //多点触控情况判断是否是同一个触控点或者手指  if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); //向child传递分发  handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } //如果child不为null且child经过缩放/平移/旋转变换则构建一个新的event供后面根据child的缩放做相应的transform处理  transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch.  //当ACTION_DOWN事件被自己拦截时child==null  if (child == null) { //super.dispatchTouchEvent即是View#dispatchTouchEvent，逻辑最终是调用自己的onTouchEvent，即自己处理  handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); //如果child经过缩放/平移/旋转变换那么transformedEvent也做相应变化  if (! child.hasIdentityMatrix()) { //getInverseMatrix反变换操作  transformedEvent.transform(child.getInverseMatrix()); } //向下传递事件  handled = child.dispatchTouchEvent(transformedEvent); } // Done.  transformedEvent.recycle(); return handled; }   ViewGroup#onInterceptTouchEvent 一般自定义view都需要重写该方法\n1 2 3 4 5 6 7 8 9 10  public boolean onInterceptTouchEvent(MotionEvent ev) { //默认实现只拦截来自鼠标的作用在滚动滑块的ACTION_DOWN事件  if (ev.isFromSource(InputDevice.SOURCE_MOUSE) \u0026amp;\u0026amp; ev.getAction() == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) \u0026amp;\u0026amp; isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; }   View#onTouchEvent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237  /** * Implement this method to handle touch screen motion events. * \u0026lt;p\u0026gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * {@link #performClick()}. This will ensure consistent system behavior, * including: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;obeying click sound preferences * \u0026lt;li\u0026gt;dispatching OnClickListener calls * \u0026lt;li\u0026gt;handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when * accessibility features are enabled * \u0026lt;/ul\u0026gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */ public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags \u0026amp; CLICKABLE) == CLICKABLE || (viewFlags \u0026amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //view DISABLED状态下如果是clickable则默认消费了事件但不做任何事情，如果是非clickable状态则返回false，不消费事件  if ((viewFlags \u0026amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch  // events, it just doesn\u0026#39;t respond to them.  return clickable; } //如果设置了TouchDelegate，则完全走TouchDelegate的处理逻辑  if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //clickable的view默认消费事件  if (clickable || (viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { handleTooltipUp(); } if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } boolean prepressed = (mPrivateFlags \u0026amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don\u0026#39;t have it already and we should in  // touch mode.  boolean focusTaken = false; if (isFocusable() \u0026amp;\u0026amp; isFocusableInTouchMode() \u0026amp;\u0026amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually  // showed it as pressed. Make it show the pressed  // state now (before scheduling the click) to ensure  // the user sees it.  setPressed(true, x, y); } if (!mHasPerformedLongPress \u0026amp;\u0026amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check  removeLongPressCallback(); // Only perform take click actions if we were in the pressed state  if (!focusTaken) {//当前有焦点触发onclick事件  // Use a Runnable and post this rather than calling  // performClick directly. This lets other visual state  // of the view update before click actions start.  if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClickInternal(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now  mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } mHasPerformedLongPress = false; if (!clickable) { checkForLongClick( ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); break; } if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we\u0026#39;re inside a scrolling container.  boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for  // a short period in case this is a scroll.  if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away  setPressed(true, x, y); checkForLongClick( ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); } break; case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) { drawableHotspotChanged(x, y); } final int motionClassification = event.getClassification(); final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE; int touchSlop = mTouchSlop; if (ambiguousGesture \u0026amp;\u0026amp; hasPendingLongPressCallback()) { final float ambiguousMultiplier = ViewConfiguration.getAmbiguousGestureMultiplier(); if (!pointInView(x, y, touchSlop)) { // The default action here is to cancel long press. But instead, we  // just extend the timeout here, in case the classification  // stays ambiguous.  removeLongPressCallback(); long delay = (long) (ViewConfiguration.getLongPressTimeout() * ambiguousMultiplier); // Subtract the time already spent  delay -= event.getEventTime() - event.getDownTime(); checkForLongClick( delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); } touchSlop *= ambiguousMultiplier; } // Be lenient about moving outside of buttons  if (!pointInView(x, y, touchSlop)) { // Outside button  // Remove any future long press/tap checks  removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; } final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS; if (deepPress \u0026amp;\u0026amp; hasPendingLongPressCallback()) { // process the long click action immediately  removeLongPressCallback(); checkForLongClick( 0 /* send immediately */, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS); } break; } return true; } return false; }   MotionEvent  key event 键盘、遥控器按键，鼠标点击会生成按键事件（key event） hover event 鼠标在屏幕上的停留、滑动会产生hover event scroll event 鼠标滚轮的滚动会生成scroll event touch event 对触屏设备，当用户用手指或触控笔在设备屏幕上操作时会产生触屏事件（touch event）\n其中MotionEvent是对hover event\u0026amp;scroll event\u0026amp;touch event的封装\nKeyEvent是对key event的封装  ACTION说明 event.getAction() action中0~7存储类别，8~15存储pointerIndex，这从getAction、getActionMasked和getActionIndex源码就可以看出来。pointerIndex和pointerId都是从0开始的整数。\n指针id(pointerId)和指针index(pointerIndex)\npointerId在整个手势操作过程中是不会变化的，可以根据pointerId跟踪某个pointer\npointerIndex在整个手势操作过程中会随着手指的增减变化\n ACTION_DOWN 多点触控第一个指针按下，如果当前触摸设备已经有存在pointer则 ACTION_UP 多点触控最后指针抬起，不一定是ACTION_DOWN对应的指针，可能是ACTION_POINTER_DOWN对应的指针 ACTION_MOVE 指针移动 ACTION_CANCEL 触摸取消，可以视为ACTION_UP事件，但不要做ACTION_UP的任何操作。ACTION_CANCEL发生的时机通常有几种：1.主动发送 2.重新开始一个事件序列时可能被程序触发 3.当接收过ACTION_DOWN事件的view在后面的ACTION_MOVE被父控件拦截时会触发ACTION_CANCEL事件，具体实现在ViewGroup#dispatchTouchEvent源码中： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view.  handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already  // dispatched to it. Cancel touch targets if necessary.  TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026amp;\u0026amp; target == newTouchTarget) { handled = true; } else { //被拦截后cancelChild为true  final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; //dispatchTransformedTouchEvent会向子view分发ACTION_CANCEL事件  if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } }    ACTION_OUTSIDE 在UI元素之外发生的触摸事件 ACTION_POINTER_DOWN 多点触控使用，非第一个指针按下 ACTION_POINTER_UP 多点触控使用，非最后一个指针抬起  其余如：ACTION_SCROLL/ACTION_BUTTON_PRESS/ACTION_BUTTON_RELEASE/ACTION_HOVER_ENTER/ACTION_HOVER_MOVE/ACTION_HOVER_EXIT 非触摸事件action，这些事件传递到onGenericMotionEvent(MotionEvent)处理\n getDeviceId() 返回event来源设备的id，通常是触摸屏。可用于InputDevice.getDevice(deviceId)获取InputDevice后进一步获取相关信息 getActionIndex() 获取当前event的pointerIndex getPointerId(pointerIndex) 获取指定pointerIndex的pointerId findPointerIndex(pointerId) 获取指定pointerId的pointerIndex，其和getActionIndex()的返回值意义是一样的，区别在于一个是获得当前event的pointerIndex，一个是获取指定pointerId pointer的pointerIndex getHistorySize() 获取event的历史触控点数，仅适用于ACTION_MOVE getRawX(int pointerIndex) 返回未经过接受触摸事件窗口和视图调整的相对于屏幕的原始坐标 getX(pointerIndex) 获取指定pointerIndex pointer当前触控点的相对于接受触摸事件窗口和视图的x坐标 getHistoricalX(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点的x坐标，pos小于getHistorySize() getSize(pointerIndex) 获取指定pointerIndex pointer当前触控点与触摸设备的按压接触面积大小。范围是0~1，至于0~1代表具体像素范围和触摸设备有关 getHistoricalSize(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点与触摸设备的按压接触面积大小 getPressure(pointerIndex) 获取指定pointerIndex pointer当前触控点的压力值。通常压力值是0(毫无压力)~1(正常压力)，但根据具体的输入设备校准，压力也可能是大于1的值 getHistoricalPressure(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点的压力值 getOrientation()/getHistoricalOrientation() (历史)触控点的方向，范围-PI/2~PI/2。可以将手指或触控笔与屏幕接触点的接触面积类似的看作一个椭圆。那么以长轴向上弧度为0，是垂直方向；长轴指向左边则是正值0~PI/2，长轴指向右边则是负值0~-PI/2。当然手指或触控笔与屏幕接触点的接触面积可能是一个正圆形。那么此时的方向是未知的 getTouchMajor()/getHistoricalTouchMajor() 将手指或触控笔与屏幕接触点的接触面积类似的看作一个椭圆。返回该椭圆长轴的长度 setEdgeFlags(flags)/getEdgeFlags() 触摸的是否是edge。getEdgeFlags仅在ACTION_DOWN事件中使用。 getFlags() 见：FLAG_WINDOW_IS_OBSCURED/FLAG_WINDOW_IS_PARTIALLY_OBSCURED  FLAG_WINDOW_IS_OBSCURED 表示接受触摸事件的窗口被其上另一个可见的窗口部分或全部遮挡。如果该触摸事位置是其上可见的窗口区域则返回true。安全敏感的应用程序可以检查此标志，以确定恶意应用程序可能为了误导用户或劫持操作而掩盖其部分内容的情况。 FLAG_WINDOW_IS_PARTIALLY_OBSCURED 类似FLAG_WINDOW_IS_OBSCURED，但触摸事位置不一定是在其上可见窗口的区域。   getXPrecision() 返回X坐标的精度。你可以用getX()乘以这个数字来找到X坐标的实际硬件值   setLocation(x, y)/offsetLocation(deltaX, deltaY) 设置/调整触摸事件的位置 transform(matrix) 使用矩阵转换event所有触控点  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public final int getAction() { return nativeGetAction(mNativePtr); } //取低八位ACTION类别信息 public final int getActionMasked() { //取低八位有效值，去除8~15位的pointerIndex信息  return nativeGetAction(mNativePtr) \u0026amp; ACTION_MASK; } //为ACTION_POINTER_DOWN/ACTION_POINTER_UP操作使用的，返回的是pointer index。当getPointerId(int)/getX(int)/getY(int)/getPressure(int)/getSize(int)时使用 public final int getActionIndex() { //取高8~16位有效值，然后右移8位  return (nativeGetAction(mNativePtr) \u0026amp; ACTION_POINTER_INDEX_MASK) \u0026gt;\u0026gt; ACTION_POINTER_INDEX_SHIFT; }   View如何实现longclick事件的 参考：\n 深入理解Android之Touch事件的分发 getEdgeFlags always returning 0? MotionEvent 详解  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "Android-热更新",
	"tags": ["android", "插件化", "热更新"],
	"categories": [],
	"series": ["插件化", "热更新"],
	"description": "Syntax highlighting test",
	"content": "热修复方案介绍 AndFix Native层函数指针替换，即时生效\nQQ控件超级补丁 类加载/multidex，重启生效\nRobust 字节码插桩/Instant Run 即时生效\nTinker 类加载，重启生效\nSophix 号称目前最优秀的热修复方案。融合Native层函数指针替换和类加载两种技术\n由于官方不支持插件化和热更新（理由是安全问题）导致原生插件化和热更新只能另辟蹊径\n热更新分两种，一种是重启生效，一种是即时生效\n即时生效的原理是：这个过程相当复杂不易控制\n这里主要讲喜爱重启生效热更新模式的原理：\nClassLoader,java的ClassLoader双亲委托机制\n干预Android加载，既然要干预那就要首先了解其原加载过程\n双亲委托 简单说类加载器的双亲委托就是在当前类加载器加载某个类之前先逐级向上询问父类加载器是否已加载过(是否已有类的缓存)，如果已加载就返回，如果未加载则有当前类加载器加载该类。你可能会问ClassLoader本身也是一个类，它是怎么被加载的呢？在jvm启动的时候就有一个根ClassLoader,即：bootstrapclassloader\n设计双亲委托模式的好处：\n1.避免重复加载 2.安全，避免核心api被修改\nAndroid ClassLoader  BootClassLoader\n加载Framwork/SDK类的ClassLoader PathClassLoader\n加载第三方库包括AndroidX支持库的ClassLoader DexClassLoader\n这个应该原本是谷歌留给开发者使用的ClassLoader，与PathClassLoader基本没区别。  类的生命周期 加载 -\u0026gt; 验证 -\u0026gt; 准备 -\u0026gt; 解析 -\u0026gt; 初始化 -\u0026gt; 使用 -\u0026gt; 卸载\n其中 验证 -\u0026gt; 准备 -\u0026gt; 解析 又叫连接，即：加载 -\u0026gt; 连接 -\u0026gt; 初始化 -\u0026gt; 使用 -\u0026gt; 卸载\n加载阶段虚拟机主要做三件事：\n 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区域的运行时数据结构 在Java堆中生成一个代表这个类的Class对象，作为方法区域数据的问入口  PathClassLoader和DexClassLoader源码分析 要做热更新就要用ClassLoader加载hotfix dex中的类,用哪个ClassLoader呢？我们在Activity中打印classLoader::class.java.name可以看到是dalvik.system.PathClassLoader\n查看PathClassLoader\n1 2 3 4 5 6  public PathClassLoader(String dexPath, ClassLoader parent) { super(dexPath, null, null, parent); } public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) { super(dexPath, null, librarySearchPath, parent); }   只有几个构造方法，但PathClassLoader继承自BaseDexClassLoader，继续进入BaseDexClassLoader查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // 首先检查是否已经加载过  Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //parent.loadClass可鞥在此抛出异常  } if (c == null) { c = findClass(name); } } return c; }   loadClass首先检查是不是已加载过这个类，若没有，调用父ClassLoader的loadClass，以此上推检查父ClassLoader是否加载过此类，若都没有加载则调用findClass\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { // First, check whether the class is present in our shared libraries.  if (sharedLibraryLoaders != null) { for (ClassLoader loader : sharedLibraryLoaders) { try { return loader.loadClass(name); } catch (ClassNotFoundException ignored) { } } } // Check whether the class in question is present in the dexPath that  // this classloader operates on.  List\u0026lt;Throwable\u0026gt; suppressedExceptions = new ArrayList\u0026lt;Throwable\u0026gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( \u0026#34;Didn\u0026#39;t find class \\\u0026#34;\u0026#34; + name + \u0026#34;\\\u0026#34; on path: \u0026#34; + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; }   最终执行到Class c = pathList.findClass(name, suppressedExceptions);，再继续查看DexPathList的findClass方法\n1 2 3 4 5 6 7 8 9 10 11 12 13  public Class\u0026lt;?\u0026gt; findClass(String name, List\u0026lt;Throwable\u0026gt; suppressed) { for (Element element : dexElements) { Class\u0026lt;?\u0026gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; }   再继续进入Element的findClass方法\n1 2 3  public Class\u0026lt;?\u0026gt; findClass(String name, ClassLoader definingContext,List\u0026lt;Throwable\u0026gt; suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed): null; }   我们只需要获取热更新补丁的dexElements与原dexElements合并，app再次重新启动就会完成修复\n使用d8编译热修复补丁   将java/kotlin文件编译成class文件\n  javac path/to/HotfixTest.java\n或\n  kotlinc path/to/HotfixTest.kt\n    d8是dex编译器，是dx的升级版，用于取代dx。路径：sdk/build_tools/buildtToolsVersion(如：28.0.3)/d8\n使用d8将class文件编译成dex\n./path/to/d8 path/to/HotfixTest.class\n  Android N热修复问题 由于Android N以后采用混合编译运行即：AOT编译，解释执行与JIT编译，见参考Android N混合编译与对热补丁影响解析。热点代码会缓存到base.art中，而且这个缓存是没法干预的，在程序启动前我们在Application干预前就已经存在了。如果我们要打补丁的类被优化到了base.art缓存就导致我们插入到dexElements并不会起作用，因为会优先从base.art查找。为此我们需要使用自定义的ClassLoader绕过。自定义一个PatchClassLoader并实例一个对象，再实例一个PathClassLoader，并将实例的PatchClassLoader设为PathClassLoader的父类加载器。使用该PathClassLoader替代App原有的PathClassLoader。为什么不直接用自定义的PatchClassLoader呢？看看DexFile类的注释文档你就会明白了。\n另外Android5.0之前Android的一个优化是会将没有直接引用其他dex的类打上CLASS_ISPREVERIFIED标志，如果被打上CLASS_ISPREVERIFIED标志的类不在同一个dex会导致崩溃。这个问题可以从字节码插桩来解决。即将一个空类编译成单独的dex文件，然后利用ASM操作字节码给需要热修复的类的无参构造方法中插入对这个空类的引用。这样所有需要修复的类都引用另外一个dex的类阻止被打上CLASS_ISPREVERIFIED标志。操作字节码可以利用Gradle插件。\n混淆的问题 读取混淆mapping文件将patch.dex中的类也按mapping混淆。\n如何知道哪些文件修改了需要编译进patch.dex呢？可以每次打包记录每个文件的MD5值，如果不相等即有改变就编译进patch.dex\n热修复中四大组件 1.利用代理activity启动插件化中的activity\n2.模仿系统加载启动activity\n总结 插件化在几年前火的一塌糊涂，由插件化延续到后来的热更新，近几年似乎没了当初的狂热\n插件化和热更新的意义在于动态化升级。不同于web只要后台发布用户前端的下次请求页面和逻辑都会改变，Android的UI及逻辑代码在手机上，发布需要经过各大市场，由审核时间，且就算发布到各大市场用户也不一定更新，强制用户更新的结果可能是被用户强制卸载。但是发布新功能/紧急修复bug的需求是巨大的。于是先有了\n 将web那一套搬到移动端的做法，但是web在移动端的性能让其体验很差，虽然出现了很多框架增强了许多，但还是有差距 原生的插件化和热更新 RectNative 热更新  RectNative用脚本语言js控制逻辑，使用c++桥接的形式控制原生控件显示，由于脚本语言不用编译，可以动态发布从而实现热更新\n参考：\nAndroid N混合编译与对热补丁影响解析\n安卓App热补丁动态修复技术介绍\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/",
	"title": "Android-音视频基础知识(一)",
	"tags": ["音视频", "android"],
	"categories": [],
	"series": ["音视频"],
	"description": "Android-音视频基础知识",
	"content": "RGB\u0026amp;YUV  RGB 红色(R)、绿色(G)、蓝色(B)三原色编码颜色。一般显示器上采用的标准。其中每个原色用一个字节(8bit)表示，一个像素点占用3字节(24bit)。 YUV YUV是一种颜色编码方式明亮度(Y)(Luminance/Luma)、色度(UV)(Chrominance/Chroma)，色度又包含色调、饱和度。YUV的出现是为了兼容黑白电视和彩色电视的显示，早期的黑白电视只有明亮度(Y)，出现彩色电视后为了兼容黑白电视和彩色电视发明了YUV颜色编码。YUV最大的优点就是占用极少宽带。  YUV\u0026amp;YCbCr YCbCr是YUV表示色彩信号的一种方式，Y是明亮度信息，Cb是蓝色偏移量，Cr是红色偏移量。一般我们将的YUV大多就是指YCbCr。\nYUV与RGB的转换 Y = 0.299 * R + 0.587 * G + 0.114 * B U = -0.147 * R - 0.289 * G + 0.436 * B V = 0.615 * R - 0.515 * G - 0.100 * B R = Y + 1.14 * V G = Y - 0.39 * U - 0.58 * V B = Y + 2.03 * U YUV的采样   YUV4:4:4\n其中YUV444P的码流及映射\n采样的码流：Y0 Y1 Y2 Y3 U0 U1 U2 U3 V0 V1 V2 V3 映射出的像素点 [Y0 U0 V0]、[Y1 U1 V1]、[Y2 U2 V2]、[Y3 U3 V3] 可以看出该采样方式和RGB编码大小一样的，并没有达到节省宽带的目的。\n  YUV4:2:2\n其中I422的码流及映射\n采样的码流：Y0 Y1 Y2 Y3 U0 U1 V0 V1 映射出的像素点 [Y0 U0 V0]、[Y1 U0 V0]、[Y2 U1 V1]、[Y3 U1 V1] 可以看出该采样方式相比RGB编码节省了三分之一宽带。\n  YUV4:2:0\n  其中NV21的码流及映射\n采样的码流：Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 V0 U0 V1 U1 映射出的像素点 [Y0 U0 V0]、[Y1 U0 V0]、[Y2 U0 V0]、[Y3 U0 V0]、[Y4 U1 V1]、[Y5 U1 V1]、[Y6 U1 V1]、[Y7 U1 V1] 可以看出该采样方式相比RGB编码节省了二分之一宽带。\n  YUV存储方式  planar 平面模式 先存储Y分量，再分别存储U、V分量。 packed 打包模式 Y、U、V分量连续交替存储。     类型 格式 码流 存储     YUV444P YUV444P YYYYUUUUVVVV planar   YUV422P I422 YYYYUUVV planar   YUV422 YUYV YUYVYUYV packed   YUV422 UYVY UYVYUYVY packed   YUV420P YU12(I420) YYYYYYYYUUVV planar   YUV420P YV12 YYYYYYYYVVUU planar   YUV420SP NV12 YYYYYYYYUVUV packed   YUV420SP NV21 YYYYYYYYVUVU packed    其中NV12是IOS摄像头采集数据默认格式\nNV21是Android摄像头采集数据默认格式\n封装格式 封装格式也叫容器，将已经编码压缩好的音频轨和视频轨按一定的格式放到一个文件中，封装格式仅是一个外壳\n   文件格式 封装格式     .avi AVI(Audio Video Interleaved)   .wmv .asf WMV(Windows Media Video)   .mpg .mpeg .vob .dat .3gp.mp4 MPEG(Moving Picture Experts Group)   .mkv Matroska   .rm .rmvb Real Video   .mov QuickTime File Format   .flv Flash Video    视频编码 视频编码是将视频像素数据(RGB/YUV等)压缩成视频码流从而降低视频数据量\n   名称 推出机构 推出时间 目前使用领域     HEVC(H265) MPEG/ITU-T 2013 研发中   H264 MPEG/ITU-T 2003 各个领域   MPEG4 MPEG 2001 不温不火   MPEG2 MPEG 1994 数字电视   VP9 Google 2013 研发中   VP8 Google 2008 不普及   VC-1 Microsoft Inc. 2006 微软平台    其中研发中并不代表还没有使用，比如H265因其压缩比高，还原度高，在部分领域(电影行业)已经开始使用\n音频编码 音频编码是将音频采样数据(PCM等)压缩成音频码流从而降低音频的数据量\n   名称 推出机构 推出时间 目前使用领域     AAC MPEG 1997 各个领域(新)   MP3 MPEG 1993 各个领域(旧)   WMV Microsoft Inc. 1999 微软平台   VC-3 Dolby Inc. 1992 电影    AAC相比MP3有更高的压缩比，同样大小的音频文件AAC质量更高\n音视频常见名词  dts(decoding timestamp) 解码时间戳，即一帧数据解码的时间 pts(presentation timestamp) 显示时间戳，即一帧数据显示/播放的时间 tb(timebase) 时间基，即时间单位。在FFmpeg中，很多时间并不是以自然时间为单位的。 tbr(timebase of rate) 帧率时间基 tbn(timebase of stream) 流时间基 tbc(timebase of codec) 解码时间基 帧率(fps) 单位kb/s(kbps) 码率(bitrate) 采样率 I帧 P帧 B帧 MB(macroblock) 巨图块，H.264/AVC的视讯编码机制是以图块(block-based)为基础单元，H264在编码时会将图像分割成许多矩形的小区域，称之为巨图块(macroblock，MB) NAL(Network Abstract Layer) 网络抽象层 NALU(Network Abstract Layer Units) 网络抽象层单元，一个NALU存储了一帧画面压缩编码后的数据。 VCL(Video Codec Layer) 视频编码层 SPS 序列参数集，profile、level、宽高及颜色空间等信息，SPS只在关键帧时出现 PPS 图像参数集，通常情况下PPS类似于SPS，PPS在任何一帧的头部出现 GOP(group of pictures) IDR(instantaneous decoding refresh) 即时解码刷新，IDR一定是I帧，但I帧不一定是IDR SODB(String Of Data Bits) 数据比特串，最原始编码数据，长度不一定是8的倍数，所以需要加补齐，即加RBSP尾部(RBSP trailing bit) RBSP(Raw Byte Sequence Payload) 原始字节序列载荷 EBSP(Encapsulated Byte Sequence Payload) 扩展字节序列载荷。H264文档并没有EBSP这一名词，但官方的JM使用了EBSP。EBSP的出现主要是是防止竞争，RBSP经过防竞争变换后成为EBSP。所以理论上：NALU = NALU Header + RBSP，实际上：NALU = NALU Header + EBSP。EBSP相较于RBSP，多了防止竞争的一个字节：0x03 SEI(Supplemental Enhancement Information) 补充增强信息，SEI可以存放影片简介、版权宣告、用户自行定义的数据等  编码及传输 JM H.264 视频编解码标准是由 ITU-T 的VCEG(视频编码专家组)和ISO/IEC 的MPEG(活动图像编码专家组)的联合视频组JVT开发的。JM是JVT发布的用C语言编写而成的源代码公开的H.264编解码软件，通常作为算法研究和实际应用的平台。简单说就是官方发布的H.264编解码范本。JM8.6是JM 的一个版本，JM8.6(下文简称JM)没有引进最新的一些运动搜索以及快速模式选择算法。但研究它的工作方式和程序结构对H.264算法研究和在JM 基础上的代码剪裁仍然很有意义。\n视频编码及传输 SODB + RBSP trailing bits = RBSP NAL header(1 byte) + RBSP = NALU Start Code Prefix(3 bytes) + NALU + Start Code Prefix(3 bytes) + NALU + ... + = H.264BitsStream 视频压缩的原理是利用影像在时间与空间上存有相似性。\nH.264/AVC的视讯编码机制是以图块(block-based)为基础单元，也就是说先将整张影像分割成许多矩形的小区域，称之为宏块(macroblock，MB)，再将这些巨图块进行编码，先使用画面内预测(intra-prediction)与画面间预测(inter-prediction)技术，以去除影像之间的相似性来得到所谓的差余影像(residual)，再将差余影像施以空间转换(transform)与量化(quantize)来去除视觉冗余，最后视讯编码层会输出编码过的比特流(bitstream)，之后再包装成网络提取层的单元封包(NAL-unit)，经由网络传送到远程或储存在储存媒体中。\n当NALU的NAL header中NAL unit type是1，2，3，4，5时NALU主体RBSP即是Slice，见下面图表NAL unit type\nSlice = Slice header + Slice data\nSlice data = MB + MB + \u0026hellip; + MB\nMB= mb_type(红块类型) + mb_pred(宏块预测数据) + coded_residual(残差数据)\nH.264/AVC的阶层架构由小到大依序是sub-block、block、macroblock、slice、slicegroup、frame/field-picture、sequence。\n对一个采用4:2:0取样的MB而言，它是由16x16点的Luma与相对应的2个8x8点Chroma来组成，而在H.264/AVC的规范中，MB可再分割成多个16x8、8x16、8x8、8x4、4x8、4x4格式的sub-blocks。\nslice时多个macroblock的集合，slice为H.264/AVC格式中的最小可译码单位(self-decodable unit)，也就是说一个slice单靠本身的压缩数据就能译码，而不必依靠其他slice\n一张图像由多个slice组成，\n  起始码\n一系列的起始码+NALU组成一个H264码流。H264码流中的起始码是固定的0x000001或0x00000001。如果NALU对应的Slice为一帧的开始则用4字节(0x00000001)表示，否则用3字节(0x000001)表示。那如果NALU内部出现0x000001或0x00000001怎么办？为了防止这种情况H264提出了防止竞争(emulation prevention)机制。在编码NALU时如果检测到连续两个0x00则插入一个0x03。当解码器在NALU检测到0x000003的数据时就把0x03抛弃，恢复原始数据。\n  编码及传输\n我们平时的每帧数据就是一个NAL单元（SPS与PPS除外）\n一般来说编码器编出的首帧数据是PPS于SPS\n  H264的码流的打包方式有两种,一种为annex-b byte stream format 的格式，这个是绝大部分编码器的默认输出格式，就是每个帧的开头的3~4个字节是H264的起始码(0x000001或0x00000001)。\n另一种是原始的NAL打包格式，就是开始的若干字节（1，2，4字节）是NAL的长度，而不是起始码,此时必须借助某个全局的数据来获得编 码器的profile,level,PPS,SPS等信息才可以解码。\nH264的功能分为两层\n VCL 视频编码层，负责有效表示视频数据的内容 NAL 网络抽象层，负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输\nVCL数据是数据编码压缩后的视频序列，在VCL数据传输和存储之前这些编码的VCL数据再映射封装到NAL单元(NALU)中。每个NALU由一个NALU头信息和一个RBSP组成。\nNALU头信息占一个字节，其中高位开始第：\n1bit是禁止位F(forbidden_zero_bit)，必须是0，如果是1表示语法出错。\n2～3bit是参考级别NRI(nal_ref_idc)，表示该NALU的重要性\n4～8bit是NALU类型Type(nal_unit_type)，1～12由H264使用，24～31由H264以外的应用使用。  图表NAL unit type\n   NAL unit type NAL类型     0 未定义   1 不分区，非IDR图像的片(非IDR Slice)   2 片分区A(Slice Partition A)   3 片分区B(Slice Partition B)   4 片分区C(Slice Partition C)   5 IDR图像中的片(IDR Slice)   6 SEI(补充增强信息单元)   7 SPS(序列参数集)   8 PPS(图像参数集)   9 分界符   10 序列结束   11 码流结束   12 填充   13~23 保留   24 STAP-A 单一时间的组合包   25 STAP-B 单一时间的组合包   26 MTAP16 多个时间的组合包   27 MTAP24 多个时间的组合包   28 FU-A 分片的单元   29 FU-B 分片的单元   30~31 未定义    Start Code Prefix为3个字节. 但是，为了寻址方便，要求数据流在长度上对齐，因此H264建议在Start Code Prefix前面加若干个0.\n音频编码及传输 H264在网络传输过程中会被编码成一系列的网络数据包\nNAL unit type都要与1F与运算转换，所以NAL unit type=7，在传输中实际传输的时67，67\u0026amp;1F=7\nHVS(人类视觉系统)由眼睛+神经+大脑构成，HVS特点：\n 对高(刷新)频信息不敏感，60Hz以下是低频，60Hz以上是高频。类似于声频，当刷新频率高于60Hz时人类并不能比60Hz感受到更多。 对高对比度更敏感 对亮度信息比色度信息更敏感 对运动的信息更敏感  针对HVS特点，数字视频系统设计考虑：\n 丢弃高频信息只编码低频信息 提高边缘信息的主观质量，即对比度 降低色度的解析度 对感兴趣区域(Region of Interesting,ROI)做特殊处理  分包 音频编码及传输 奈奎斯特采样定理：当采样频率fs.max大于信号中最高频率fmax的2倍时(fs.max\u0026gt;2fmax)，采样之后的数字信号就可以完整地保留原始信号中的信息，一般实际应用中保证采样频率为信号最高频率的2.56～4倍\n 采样频率： 每秒采集声音样本的次数。由于人耳所能听到的声音频率20Hz~20KHz，又由奈奎斯特采样定理可知当采样频率达到频率两倍时即可保留原始声波信号信息。因此采样率应该介于40~40K。一般的采样率有8K,11.025K,16K,22.05K,24K,44.1K,48K,96K，其中44.1K是CD音质，48K是DVD音质\n11.025K是AM调幅广播声音品质，而22.05K和24K是FM调频广播的声音品质 采样位数： 即所能表示声波的幅度。采样位数越大，所能表示的声波幅度越大，音质越好。一般又8bit，16bit，32bit。16bit已达CD音质 声道数：声道可以简单理解为采集/播放音频数据的麦克风/喇叭个数，但也有的处理会将两个喇叭输出同一声道的声音。有单声道/双声道/多声道，双声道是立体声，三声道是环绕立体声。 比特率：每秒传输的声音数据量。比特率=采样频率x采样位数x声道数 周期：音频设备一次处理所需的帧数，对于音频设备的访问和音频数据的存储都是以此为单位 交错模式：音频信号数据以连续帧的方式存储，即存储帧1的左、右声道样本，再存储帧2的左、右声道样本 非交错模式：先存储一个周期内所有帧的左声道样本再存储一个周期内所有帧的右声道样本。  AAC编码 ADTS Pkt + \u0026hellip; + ADTS Pkt = AACBitsStream\ndata[0], bytes, size); //Y for (j = 0; j data[2] + j) = *(bytes + size + j * 2); // V *(avFrame-data[1] + j) = *(bytes + size + j * 2 + 1); //U } FFMPEG 方法一： //1.根据格式获取缓存大小 int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align); //2.根据计算的缓存大小申请空间 int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],const uint8_t *src,enum AVPixelFormat pix_fmt, int width, int height, int align); 方法二： //根据格式申请缓存空间 int av_image_alloc(uint8_t *pointers[4], int linesizes[4],int w, int h, enum AVPixelFormat pix_fmt, int align); 方法二相当于方法一的两步 av_init_packet 将已经存在的packet初始化为默认值 av_packet_alloc 为packet分配内存并初始化为默认值 av_new_packet 按制定大小为packet分配内存并初始化为默认值 max_b_frames 两个非B帧之间最大B帧数 frame-best_effort_timestamp ffmpeg获取可以从AVPacket和AVFrame中获取pts，一般两者一致，但有时候AVFrame没有pts或者是0/-1，这时候可以利用ffmpeg的方法 av_frame_get_best_effort_timestamp推断出一个合适的pts时间戳，在ffmpeg已经不需要调用这个方法可以直接frame-best_effort_timestamp 访问pts时间戳，即判断AVFrame pts异常时，可以用AVFrame-best_effort_timestamp代替 av_q2d转换成时间 PTS=PTS*av_q2d(video_stream-time_base) int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat,const char *format_name, const char *filename); 作用在于当我们需要将编码后的数据写入文件的时候用该方法，并配合 int avio_open(AVIOContext **s, const char *url, int flags); AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c); int avformat_write_header(AVFormatContext *s, AVDictionary **options); int av_write_trailer(AVFormatContext *s); 让FFmpeg帮我们写文件，这样不用我们自己处理文件头文件尾格式问题 openGL: Shader(着色器) 在GPU上运行的小程序 android.hardware.Camera private String cameraFormatForPixelFormat(int pixel_format) { switch(pixel_format) { case ImageFormat.NV16: return PIXEL_FORMAT_YUV422SP; case ImageFormat.NV21: return PIXEL_FORMAT_YUV420SP; case ImageFormat.YUY2: return PIXEL_FORMAT_YUV422I; case ImageFormat.YV12: return PIXEL_FORMAT_YUV420P; case ImageFormat.RGB_565: return PIXEL_FORMAT_RGB565; case ImageFormat.JPEG: return PIXEL_FORMAT_JPEG; default: return null; } } https://blog.csdn.net/gb702250823/article/details/81627503 MediaCodec的基本调用流程是： createEncoderByType/createDecoderByType configure start while(true) { dequeueInputBuffer //从输入流队列中取数据进行编码操作 getInputBuffers //获取需要编码数据的输入流队列，返回的是一个ByteBuffer数组 queueInputBuffer //输入流入队列 dequeueOutputBuffer //从输出队列中取出编码操作之后的数据 getOutPutBuffers // 获取编解码之后的数据输出流队列，返回的是一个ByteBuffer数组 releaseOutputBuffer //处理完成，释放ByteBuffer数据 } stop release 相机拍摄预览文字有明显的闪烁纹，发现是设置了不支持的预览尺寸 opengl 像素缓冲区的作用：任何从 PBO 的读取或写入 PBO 的操作或任何缓冲区对象都用管线进行处理，这意味着 GPU 不需要完成所有其他操作，提高效率 缓冲区对象在处理需要经常访问、修改或更新数据的场合中具有重大优势，比如异步调用 glReadPixels。 将像素数据读取到 CPU 内存中需要 GPU 先完成正在进行的其它所有工作， 如果 GPU 忙于渲染 3D 图形，这将影响图形渲染的效率。这时候可以使用 PBO，因为读取操作是通过管线进行的， 所有对 glReadPixels 的调用能够立即返回。甚至可以多次调用， 使用不同的缓冲区对象来读取不同的区域。 如果不使用PBO而直接使用glReadPixels将是同步的，可能需要等待很久时间 利用GPU管线的好处是：不需要等待GPU工作完成（比如：GPU正在渲染3D模型） camera.addCallbackBuffer(data);//复用分配的数组空间，提高效率，如果不设置的话每一帧会重新分配内存 如果glReadPixels效率有问题可以用PBO AVPicture 存放yuv数据 av_free\u0026av_freep 1.从概念上说，都是释放指针所指的那块内存， 但是av_freep还多个功能，就是把当前指针置为NULL。 2.从使用上说，也是有区别的，举例说明如下： uint8_t *buf = av_malloc(16); av_free(buf); uint8_t *buf = av_malloc(16); av_freep(\u0026buf); AVPacket：存储压缩数据（视频对应H.264等码流数据，音频对应AAC/MP3等码流数据） AVFrame：存储非压缩的数据（视频对应RGB/YUV像素数据，音频对应PCM采样数据） memset是以字节为单位，初始化内存块 视频或音频数据存储的2种格式packed和planar: 假设有一路音频流，有左右两声道的数据。左声道用L表示，右声道用R表示。 存储时，如果是左右声道数据交替存储成一维数组，这种格式称为packed。格式为LRLRLR....LRLR 如果是分开存储成二维数组，这种格式称为planar。格式为LLLLLLLLLLLLLL和RRRRRRRRRRRRR 视频也是如此，但是对于YUV格式的数据，比音频多一种存储方法叫semi-planar，也就是半planar。一共2路存储，Y一路，UV一路，其中UV交叉存储。 c++声明即分配空间 一些常用的Signal ： https://blog.csdn.net/yockie/article/details/51729774 注意：如果是多线程程序，signal(SIGINT, sig_handler) 需要写在想要终止的那个线程里，只写在 main 函数不行。 ALSA是Advanced Linux Sound Architecture，高级Linux声音架构的简称,它在Linux操作系统上提供了音频和MIDI（Musical Instrument Digital Interface，音乐设备数字化接口）的支持。在2.6系列内核中，ALSA已经成为默认的声音子系统，用来替换2.4系列内核中的OSS（Open Sound System，开放声音系统）。 [1] ALSA的主要特性包括：高效地支持从消费类入门级声卡到专业级音频设备所有类型的音频接口，完全模块化的设计， 支持对称多处理（SMP）和线程安全，对OSS的向后兼容，以及提供了用户空间的alsa-lib库来简化应用程序的开发。 -- 参考：\n 一文读懂 YUV 的采样与格式 音视频开发的一系列科普教程  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-activityfragment/",
	"title": "Android四大组件-Activity/Fragment",
	"tags": ["四大组件", "android"],
	"categories": [],
	"series": ["四大组件"],
	"description": "Android四大组件-Activity/Fragment使用",
	"content": "Activity 生命周期  当用户打开新的Activity的时候或者切换到桌面的时候回调onPause-onStop，但是如果此Activity是透明主题，那么Activity不会回调onStop 当系统内存不足时可能会跳过onStop()直接onDestory，即不会回调onStop() 当Activity因异常终止时会回调onSaveInstanceState，被再次重建时会回调onRestoreInstanceState。但正常终止则不会调用这两个方法  当一个Activity进入/返回另一个Activity时总是先执行自己的onPause，再执行另一个Activity的相关生命周期，所以onPause中不能做耗时操作否则会影响另一个Activity的尽快显示。相应的当一个Activity进入/返回另一个Activity时若当前Activity执行到onStop时表示另一个Activity页面肯定是已展示的，所以onStop是可以做一些耗时操作的。Android为什么这么设计？从用户角度想肯定是想尽量先让新的页面展示自己再关闭当前页面。以上，通常在Splash页面可以在onStop中调用finish结束自己。\n生命周期实践(Android8.0)   当一个Activity(App Launcher Activity)启动另一个嵌套Fragment的Activity时生命周期调用过程：\nonCreate(Activity A)-\u0026gt;onStart(Activity A)-\u0026gt;onResume(Activity A)-\u0026gt;onPause(Activity A)-\u0026gt;onAttach(Activity B Fragment)-\u0026gt;onCreate(Activity B Fragment)-\u0026gt;onCreate(Activity B)-\u0026gt;onCreateView(Activity B Fragment)-\u0026gt;onActivityCreated(Activity B Fragment)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)-\u0026gt;onAttachedToWindow(Activity B)-\u0026gt;onSaveInstanceState(Activity A)-\u0026gt;onStop(Activity A)\n  (2.1)此时旋转屏幕，若Activity B Fragment retainInstance=false且Activity未配置android:configChanges=\u0026quot;orientation|screenSize\u0026rdquo;\nonPause(Activity B Fragment)-\u0026gt;onPause(Activity B)-\u0026gt;onSaveInstanceState(Activity B)-\u0026gt;onStop(Activity B)-\u0026gt;onDestroyView(Activity B Fragment)-\u0026gt;onDestroy(Activity B Fragment)-\u0026gt;onDetach(Activity B Fragment)-\u0026gt;onDestroy(Activity B)-\u0026gt;onDetachedFromWindow(Activity B)\nonAttach(Activity B Fragment)-\u0026gt;onCreate(Activity B Fragment)-\u0026gt;onCreate(Activity B)-\u0026gt;onCreateView(Activity B Fragment)-\u0026gt;onActivityCreated(Activity B Fragment)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onRestoreInstanceState(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)-\u0026gt;onAttachedToWindow(Activity B)\n(2.2)此时旋转屏幕，若Activity B Fragment retainInstance=true且Activity未配置android:configChanges=\u0026quot;orientation|screenSize\u0026rdquo;\nonPause(Activity B Fragment)-\u0026gt;onPause(Activity B)-\u0026gt;onSaveInstanceState(Activity B)-\u0026gt;onStop(Activity B)-\u0026gt;onDestroyView(Activity B Fragment)-\u0026gt;onDetach(Activity B Fragment)-\u0026gt;onDestroy(Activity B)-\u0026gt;onDetachedFromWindow(Activity B)\nonAttach(Activity B Fragment)-\u0026gt;onCreate(Activity B)-\u0026gt;onCreateView(Activity B Fragment)-\u0026gt;onActivityCreated(Activity B Fragment)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onRestoreInstanceState(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)-\u0026gt;onAttachedToWindow(Activity B)\n(2.3)此时旋转屏幕，若Activity配置android:configChanges=\u0026quot;orientation|screenSize\u0026rdquo;，无论Activity B Fragment retainInstance=true/false\nonConfigurationChanged(Activity B Fragment)-\u0026gt;onConfigurationChanged(Activity B)\n(2.4)此时息屏或Home键回到后台后：\nonPause(Activity B Fragment)-\u0026gt;onPause(Activity B)-\u0026gt;onSaveInstanceState(Activity B)-\u0026gt;onStop(Activity B)\n  (1)在息屏的情况下重新点亮屏幕或者：\n(2)在在后台的情况下点击任务键再点击相应App回到前台：\nonRestart(Activity B)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)\n(3)在后台的情况下点击图标回到前台：\nonDestroyView(Activity B Fragment)-\u0026gt;onDestroy(Activity B Fragment)-\u0026gt;onDetach(Activity B Fragment)-\u0026gt;onDestroy(Activity B)-\u0026gt;onDetachedFromWindow(Activity B)-\u0026gt;onNewIntent(Activity A)-\u0026gt;onRestart(Activity A)-\u0026gt;onStart(Activity A)-\u0026gt;onResume(Activity A)\n(4)如果在1这一步Activity A(App Launcher Activity)跳转到Activity B后finish掉Activity A，那么此时在后台的情况下点击图标回到前台：\nonCreate(Activity A)-\u0026gt;onStart(Activity A)-\u0026gt;onResume(Activity A)-\u0026gt;onPause(Activity A)-\u0026gt;onAttach(Activity B Fragment)-\u0026gt;onCreate(Activity B Fragment)-\u0026gt;onCreate(Activity B)-\u0026gt;onCreateView(Activity B Fragment)-\u0026gt;onActivityCreated(Activity B Fragment)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)-\u0026gt;onAttachedToWindow(Activity B)-\u0026gt;onSaveInstanceState(Activity A)-\u0026gt;onStop(Activity A)-\u0026gt;onDestroy(Activity A)\n  总结：\n 未配置android:configChanges=\u0026quot;orientation|screenSize\u0026quot;\n旋转屏幕会重走生命周期但不会走onConfigurationChanged，另外无论竖屏转横屏或者横屏转竖屏并未出现走两次生命周期的情况(8.0)，如果Activity中有Fragment，如果Fragment的retainInstance=false也会因重建而走整个生命周期，但如果设置了retainInstance=true，则Fragment不会销毁但会销毁所包含视图，因此其不会走Fragment的onDestroy和onCreate生命周期，但其他各个声明周期还都会重走。 配置android:configChanges=\u0026quot;orientation|screenSize\u0026quot;\n此时Activity不会销毁重新创建，Activity内的Fragment也不会销毁重新创建，因此此时只会回调onConfigurationChanged。 android:configChanges的配置\n需要注意的是单独配置android:configChanges=\u0026quot;orientation\u0026quot;或android:configChanges=\u0026quot;screenSize\u0026quot;都是不生效的，需要同时配置android:configChanges=\u0026quot;orientation|screenSize\u0026quot; 后台回到前台的问题\n由3(3)可知Activity B在回到前台时被回收并弹出Activity栈，只保留了App Launcher Activity。由3(4)可知如果跳转到Activity B时结束了Launcher Activity，点击图标回到前台时Activity B的onDestroy甚至没有回调而是直接重启了App。 以上部分在各个手机可能有不同表现，仅供参考。  onNewIntent回调的时机 当startActivity启动的是同一Activity实例intent发生变化都会走onNewIntent，当Activity的启动模式是stand时调用startActivity启动每次都会重新创建，所以该模式下不会走onNewIntent，其他启动模式都有可能。\n非stand模式下：\nstartActivity A-\u0026gt;startActivity B-\u0026gt;startActivity A\nActivity A的生命周期：onNewIntent-\u0026gt;onRestart-\u0026gt;onStart-\u0026gt;onResume\nstartActivity A-\u0026gt;startActivity A\nActivity A的生命周期：onPause-\u0026gt;onNewIntent-\u0026gt;onResume\ngetLastNonConfigurationInstance onRetainNonConfigurationInstance\nonRetainCustomNonConfigurationInstance\n可以在onRetainCustomNonConfigurationInstance中存储非配置信息(和Activity生命周期状态无关的信息)，然后使用getLastNonConfigurationInstance获取存储的信息。已经废弃，官方推荐使用ViewModel存储非配置信息\n这个方法最大的好处是：\n 当activity曾经通过某个网络资源得到一些图片或者视频信息，那么当再次恢复后，无需重新通过原始资源地址获取，可以快速的加载整个activity状态信息。 当activity包含有许多线程时，在变化后依然可以持有原有线程，无需通过重新创建进程恢复原有状态。 当activity包含某些connection instance时，同样可以在整个变化过程中保持连接状态。  横竖屏切换 见生命周期实践的第二部分。\n显式Intent和隐式Intent 隐式跳转有两种方式：\n 设置action 设置data  Activity窗口构成 Activity、PhoneWindow、DecorView、ViewRootImpl、WindowManagerImpl、WindowManagerGlobal、ActivityThread和Surface\n见参考Android Render(一)Activity窗口构成和绘制解析\nAPI解析   overridePendingTransition(int enterAnim, int exitAnim)\n在startActivity或finish时调用执行的转换动画\n   getCallingActivity()\n获取使用startActivityForResult启动当前Activity的Activity，即setResult()中的数据将发送到的Activity。\n  getCallingPackage()\n参见getCallingActivity()\n  onConfigurationChanged(Configuration)\nActivity配置configChanges时，当旋转屏幕等状态信息变化时回调\n  getChangingConfigurations()\n当onConfigurationChanged(Configuration)不能回调时可以使用此方法发现一些配置的更改，但不能保证准确性，因为获取的是一个成员变量值，这个值下一秒随时可能被更改。\n  isChangingConfigurations()\n检查是否正在销毁此Activity，以便用新配置重新创建。通常在onStop中使用，以确定状态是需要清理还是将通过onRetainNonConfigurationInstance()传递给Activity的重新创建的实例。\n  onPostCreate(@Nullable Bundle savedInstanceState)\nonStart()和onRestoreInstanceState()之后，onResume()之前调用。应用程序通常不会实现这个方法；它是为了让系统类在应用程序代码运行后进行最终初始化。\n  onCreateNavigateUpTaskStack(TaskStackBuilder builder)\n使用Navigation导航时回调\n  onPrepareNavigateUpTaskStack(TaskStackBuilder builder)\n  onNavigateUp()\n  onNavigateUpFromChild(Activity child)\n  startLocalVoiceInteraction(Bundle privateOptions)\n  onLocalVoiceInteractionStarted()\n  onLocalVoiceInteractionStopped()\n  getVoiceInteractor()\n  onPerformDirectAction(String actionId,Bundle arguments, CancellationSignal cancellationSignal,Consumer resultListener)\n  onGetDirectActions(CancellationSignal cancellationSignal,Consumer\u0026lt;List\u0026gt; callback)\n  onMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig)\nAndroid7.0支持了多窗口模式。当活动从全屏模式更改为多窗口模式或多窗口模式更改为全屏模式时由系统调用\n  onTopResumedActivityChanged(boolean isTopResumedActivity)\n在多窗口和多显示模式下，可以同时恢复多个活动。应该使用此回调而不是onResume()来指示活动可以尝试打开诸如camera之类的独占访问设备。\n  isInPictureInPictureMode()\n是否画中画模式\n  onPictureInPictureModeChanged(boolean isInPictureInPictureMode,Configuration newConfig)\n当前Activity变化到画中画模式或从画中画模式退出时回调\n  onUserInteraction()/onUserLeaveHint()\n用户与界面交互时回调onUserInteraction()，比如每次触摸Activity界面都会回调onUserInteraction()，当用户下拉通知并点击某个通知离开App界面跳转到其他如设置界面时回调onUserLeaveHint()。onUserInteraction回调旨在帮助activities智能地管理状态栏通知；特别是帮助activities确定取消通知的正确时间。详细请见Android-事件分发机制\n  onRetainNonConfigurationInstance/onRetainCustomNonConfigurationInstance\n可以在onRetainCustomNonConfigurationInstance中存储非配置信息(和Activity生命周期状态无关的信息)，然后使用getLastNonConfigurationInstance获取存储的信息。已经废弃，官方推荐使用ViewModel存储非配置信息\n  onEnterAnimationComplete()\n在窗口设置动画期间，活动无法绘制。为了知道何时开始绘制是安全的，他们可以重写此方法，当输入动画完成时将调用此方法。\n  onActivityReenter(int resultCode, Intent data)\nTransition转场动画时重进入的回调，只有当设置Window#FEATURE_ACTIVITY_TRANSITIONS且resultCode不是RESULT_CANCELED才会回调。目的是提前让Activity做一些准备\n  isActivityTransitionRunning()\n当前Activity是否还有Transition动画运行。\n  getContentScene()\n需要设置Window#FEATURE_CONTENT_TRANSITIONS\n  isChild()\n当前Activity是否嵌套在其他Activity中。\n  getCurrentFocus()\n返回当前Activity窗口上的焦点视图\n  isImmersive()/setImmersive(boolean i)\n是否是沉浸式，沉浸式尽快能不被通知打断。\n  startIntentSenderForResult\n和startActivityForResult类似，只是换成了IntentSender描述要启动的Activity\n  startLockTask()/stopLockTask()\n  isTaskRoot()\n是否是栈中的根Activity\n  moveTaskToBack(boolean nonRoot)\n  setShowWhenLocked(boolean showWhenLocked)\nAPI-27提供\n  setVrModeEnabled(boolean enabled, @NonNull ComponentName requestedComponent)\nAPI-24提供\n  onTrimMemory(int level)\n运行时的回调：\nTRIM_MEMORY_RUNNING_MODERATE  表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了\nTRIM_MEMORY_RUNNING_LOW 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能。\nTRIM_MEMORY_RUNNING_CRITICAL 表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。\n缓存的回调：\nTRIM_MEMORY_UI_HIDDEN\nUI组件全部不可见的时候才会触发，一旦触发了之后就说明用户已经离开了我们的程序\nTRIM_MEMORY_BACKGROUND 表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的。\nTRIM_MEMORY_MODERATE 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置。\nTRIM_MEMORY_COMPLETE 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置。\n  ActivityOptions   makeSceneTransitionAnimation(Activity activity,View sharedElement, String sharedElementName)\n  makeSceneTransitionAnimation(Activity activity,Pair\u0026lt;View, String\u0026gt;... sharedElements)\n  makeCustomAnimation(Context context,int enterResId, int exitResId)\n设置进入退出的转场动画\n  makeScaleUpAnimation(View source,int startX, int startY, int width, int height)\n创建ActivityOptions指定一个动画，在该动画中，新activity从屏幕的一个小的原始区域缩放到其最终完整状态。\n  makeClipRevealAnimation(View source,int startX, int startY, int width, int height)\n创建ActivityOptions指定一个揭露动画，在该动画中，新activity从屏幕的一个小的原始区域缩放到其最终完整状态。\n  makeThumbnailScaleUpAnimation(View source,Bitmap thumbnail, int startX, int startY)\n创建ActivityOptions指定一个动画，动画从指定位置的一个缩略图缩放到新窗口\n  makeTaskLaunchBehind()\n和Intent.FLAG_ACTIVITY_NEW_DOCUMENT一起使用，正在启动的任务将不会显示给用户，而是只能通过“最近者”任务列表使用。此外，新任务将与启动Activity的任务关联。关联的任务在“最近者”任务列表中分组在一起。不支持启动模式是singleInstance和singleTask的Activity。\n  makeBasic()\n创建一个ActivityOptions不包含任何动画。\n  Fragment Fragment的使用  静态使用\nxml中使用fragment标签关联绑定 1 2 3 4  \u0026lt;fragment android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:name=\u0026#34;com.osshare.dsh.ui.HomeFragment\u0026#34; /\u0026gt;   静态使用时fragment不能嵌套，一旦加载不能移除。\n 动态使用\n使用FragmentManager和FragmentTransaction。可以动态添加移除。  Fragment需要空构造方法 FragmentPagerAdapter和FragmentStatePagerAdapter   FragmentPagerAdapter\nFragmentPagerAdapter是一个不带状态的，一般用于少量界面的ViewPager，划过的Fragment会一直保存在内存中不会销毁。\n  FragmentStatePagerAdapter\nFragmentStatePagerAdapter是一个带状态的适用于界面较多的ViewPager，它会保存当前的界面及上一个界面、下一个界面，最多保存三个，其他的会在destroyItem()方法中被销毁，节省内存占用。  ViewPager和Fragment及懒加载 ViewPager和Fragment结合使用时默认会加载前两个Fragment，这样很容易造成网络丢包、阻塞等问题。\nFragment中有一个setUserVisibleHint(boolean isVisibleToUser)方法，可以通过参数isVisibleToUser判断Fragment是否可见，当Fragment可见时再进行懒加载。setUserVisibleHint的调用早于onCreateView，所以setUserVisibleHint中的操作要避险View变量的空指针。\nsetUserVisibleHint的调用时机：\n Fragment创建时调用，参数isVisibleToUser = false Fragment可见时调用，参数isVisibleToUser = true Fragment由可见变为不可见时调用，参数isVisibleToUser = false  最新的Android版本中setUserVisibleHint已被废弃，官方建议使用Lifecycle\n1 2 3 4 5  * @deprecated If you are manually calling this method, use * {@link FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)} instead. If * overriding this method, behavior implemented when passing in \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; should be * moved to {@link Fragment#onResume()}, and behavior implemented when passing in * \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; should be moved to {@link Fragment#onPause()}.   Fragment中getActivity为null的问题 原因是因为Fragment还未attach到Activity或者又一个耗时的延迟异步任务或Handler消息，当执行完时需要使用Activity，但此时界面已经跳转到其他页面不在这个Activity。\n 尽量不使用Activity而是使用Context 可以在onAttach保存调用Activity activity=getActivity;并保存。但要注意内存泄漏问题。  Fragment重叠 bug场景：\n Activity的onCreate中add fragment，当旋转屏幕时出现重叠。 内存重启导致的重叠（比如：接了个电话，系统内存不足，杀掉了你的activity ）。打开手机上的“开发者选项”中的“不保留活动”选项，模拟内存重启  这是因为fragment有自己的一套恢复，而旋转重走生命周期会再次add fragment 导致重叠。\n解决方案：\n Activity onSaveInstanceState中不自动保存Fragment状态 onCreate中判断 if(savedInstanceState == null){add fragment }  其他问题   transaction.commit()必须在onSaveInstanceState之前调用，否则会报错：Can not perform this action after onSaveInstanceState，因为onSaveInstanceState会在Activity销毁时保存状态数据，如果在onSaveInstanceState之后调用transaction.commit()，Fragment的commit状态数据可能丢失。在Android中当Activity被系统回收(界面已经不存在了)为了下次打开的时候恢复原来的样子，系统为我们保存界面的所有状态，这个时候再去修改界面理论上是肯定不允许的。解决方案：\n 使用transaction.commitAllowingStateLoss()允许丢失状态数据。 在onPostResume、onResumeFragments这两个方法中commit  另外注意不要在子线程调用transaction.commit()，因为在子线程很容易忽视Activity的生命周期而出现bug\n  低版本support库的bug support-v4版本小于24时有很多bug，比如重叠及嵌套时收不到回调等问题，但先26以后，尤其时28版本的support-v4库已经都解决了，所以使用时尽量使用28及以后的版本，最好是切换Jetpack(AndroidX)库。\nFragment API解析   Fragment\n setRetainInstance() 设置setRetainInstance(true)时若Activity重新创建Fragment的实例将不会销毁。因此onCreate(Bundle)/onDestroy()不会回调，但onDetach()(因为这时Fragment会从Activity detached)/onAttach(Activity)/onActivityCreated(Bundle)会回调。setRetainInstance()的意义是某些场景如：当我们加载图片/网络请求后旋转屏幕导致Activity重建不会导致Fragment重建，我们将图片/网络请求数据保存在Fragment不用再次请求 startPostponedEnterTransition()/postponeEnterTransition()\n见Android-转场动画Transition类比Activity setSharedElementEnterTransition(@Nullable Object transition)\n见Android-转场动画Transition类比Activity setAllowEnterTransitionOverlap(boolean allow)\n见Android-转场动画Transition类比Activity    FragmentManager\n executePendingTransactions()    FragmentTransaction\n  addToBackStack()\u0026amp;popBackStack() 当返回时想一步一步回退就需要在添加时调用addToBackStack，添加到回退栈中。如果是嵌套Fragment的回退addToBackStack无法做到先回退嵌套的子Fragment，这时可以重写Activity的onBackPressed自己管理。也可以使用Jetpack的Navigation来管理。\n  replace() 相当于remove()和add()两步操作合并  add()\u0026amp;remove() 添加/移除fragment，remove()需要先判断是否添加，否则可能会报错。\n  hide()\u0026amp;show() 隐藏/显示\n  commit()/commitNow()\n  commitAllowingStateLoss()/commitNowAllowingStateLoss()\n  runOnCommit()\n  setTransition(@Transit int transition)\n指定系统自带的转场动画\n  setCustomAnimations(@AnimatorRes @AnimRes int enter,@AnimatorRes @AnimRes int exit, @AnimatorRes @AnimRes int popEnter, @AnimatorRes @AnimRes int popExit)\n指定自定义的转场动画\n    Fragment-Fragment/Activity-Activity/Fragment-Activity之间的通信  接口 广播 第三方通信框架，如：EventBus RxBus、LiveDataBus  LiveDataBus是官方推荐的方式\n参考：\nAndroid Render(一)Activity窗口构成和绘制解析\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-service/",
	"title": "Android四大组件-Service",
	"tags": ["四大组件", "android"],
	"categories": [],
	"series": ["四大组件"],
	"description": "Android四大组件-Service",
	"content": "前言 Service Service默认运行在主线程，并不运行在单独线程，因此在Service执行耗时操作容易引起ANR。\nIntentService  可用于执行后台耗时的任务，任务执行后会自动停止 具有高优先级，适合高优先级的后台任务，且不容易被系统杀死 可以多次启动，每个耗时操作都会以工作队列的方式在IntentService的onHandleIntent回调方法中执行  参考：\nAndroid Render(一)Activity窗口构成和绘制解析\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/",
	"title": "Android属性动画",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android属性动画",
	"content": "帧动画 xml文件存放在res/drawable下面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;animation-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:oneshot=\u0026#34;true\u0026#34; android:variablePadding=\u0026#34;false\u0026#34; android:visible=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/drawable0\u0026#34; android:duration=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/drawable1\u0026#34; android:duration=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/drawable2\u0026#34; android:duration=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;/animation-list\u0026gt;   item是其每一帧的图片及播放时间\n实现类AnimationDrawable，在包android.graphics.drawable下面。其主要的方法void addFrame(@NonNull Drawable frame, int duration)，添加一帧。\nview动画（补间动画） xml文件存放在res/anim下面\n首先我们介绍view动画实现原理。说到其原理不能不提一个辅助类Transformation，正是Transformation保存了变换的状态。然后在view的draw方法中根据动画状态绘制\n  Transformation\n1 2 3 4 5 6 7  public class Transformation { ... protected Matrix mMatrix; protected float mAlpha; protected int mTransformationType; ... }   Transformation中最重要的是这三个变量。AlphaAnimation动画的状态保存在mAlpha变量中，TranslateAnimation\u0026amp;RotateAnimation\u0026amp;ScaleAnimation三个的动画状态则保存在mMatrix中。mTransformationType则是表示当前动画是通过变换mAlpha还是mMatrix实现的，或者两者同时都有变化。因为是利用Matrix变换来实现的缩放/平移/旋转，并没有真正改变view的位置大小，所以响应view点击事件的位置还在原处。\n具体看看View#draw(Canvas canvas, ViewGroup parent, long drawingTime)的源码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122  boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) { ... boolean more = false; ... Transformation transformToApply = null; boolean concatMatrix = false; final boolean scalingRequired = mAttachInfo != null \u0026amp;\u0026amp; mAttachInfo.mScalingRequired; final Animation a = getAnimation(); if (a != null) { more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired); concatMatrix = a.willChangeTransformationMatrix(); if (concatMatrix) { mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; } transformToApply = parent.getChildTransformation(); } else { if ((mPrivateFlags3 \u0026amp; PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) { // No longer animating: clear out old animation matrix  mRenderNode.setAnimationMatrix(null); mPrivateFlags3 \u0026amp;= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; } if (!drawingWithRenderNode \u0026amp;\u0026amp; (parentFlags \u0026amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) { final Transformation t = parent.getChildTransformation(); final boolean hasTransform = parent.getChildStaticTransformation(this, t); if (hasTransform) { final int transformType = t.getTransformationType(); transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null; concatMatrix = (transformType \u0026amp; Transformation.TYPE_MATRIX) != 0; } } } ... float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha()); if (transformToApply != null || alpha \u0026lt; 1 || !hasIdentityMatrix() || (mPrivateFlags3 \u0026amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) { if (transformToApply != null || !childHasIdentityMatrix) { int transX = 0; int transY = 0; if (offsetForScroll) { transX = -sx; transY = -sy; } if (transformToApply != null) { if (concatMatrix) { if (drawingWithRenderNode) { renderNode.setAnimationMatrix(transformToApply.getMatrix()); } else { // Undo the scroll translation, apply the transformation matrix,  // then redo the scroll translate to get the correct result.  canvas.translate(-transX, -transY); //从Animation的辅助类Transformation获取matrix执行concat  canvas.concat(transformToApply.getMatrix()); canvas.translate(transX, transY); } parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; } float transformAlpha = transformToApply.getAlpha(); if (transformAlpha \u0026lt; 1) { alpha *= transformAlpha; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; } } if (!childHasIdentityMatrix \u0026amp;\u0026amp; !drawingWithRenderNode) { canvas.translate(-transX, -transY); canvas.concat(getMatrix()); canvas.translate(transX, transY); } } // Deal with alpha if it is or used to be \u0026lt;1  if (alpha \u0026lt; 1 || (mPrivateFlags3 \u0026amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) { if (alpha \u0026lt; 1) { mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA; } else { mPrivateFlags3 \u0026amp;= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA; } parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; if (!drawingWithDrawingCache) { final int multipliedAlpha = (int) (255 * alpha); if (!onSetAlpha(multipliedAlpha)) { if (drawingWithRenderNode) { renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha()); } else if (layerType == LAYER_TYPE_NONE) { canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha); } } else { // Alpha is handled by the child directly, clobber the layer\u0026#39;s alpha  mPrivateFlags |= PFLAG_ALPHA_SET; } } } } else if ((mPrivateFlags \u0026amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) { onSetAlpha(255); mPrivateFlags \u0026amp;= ~PFLAG_ALPHA_SET; } ... if (a != null \u0026amp;\u0026amp; !more) { if (!hardwareAcceleratedCanvas \u0026amp;\u0026amp; !a.getFillAfter()) { onSetAlpha(255); } parent.finishAnimatingView(this, a); } if (more \u0026amp;\u0026amp; hardwareAcceleratedCanvas) { if (a.hasAlpha() \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) { // alpha animations should cause the child to recreate its display list  invalidate(true); } } ... return more; }     Animation\n AlphaAnimation TranslateAnimation RotateAnimation ScaleAnimation AnimationSet    API解析  fillBefore 动画结束后是否还原结束位置 fillAfter 动画结束后是否停留在结束位置 isFillEnabled true则会应用fillBefore设置，否则忽略fillBefore设置并始终应用动画转换，直到动画结束 backgroundColor 设置view动画背景色 repeatMode [RESTART|REVERSE] 重复模式。 repeatCount 重复次数。默认值0:不重复 \u0026gt;0:重复次数 \u0026lt;0：无限循环 startTime 设置动画开始时间 startNow startOffset 相对startTime的偏移时间。当使用AnimationSet执行多个动画，多个动画执行时间不一致时可以用该方法设置 zAdjustment [ZORDER_NORMAL|ZORDER_TOP|ZORDER_BOTTOM] 设置运行动画时Z轴位置 restrictDuration(long durationMillis) 根据参数做调整。动画时长不能超多durationMillis。超过限制时长durationMillis动画不会再执行，包括重复动画。 scaleCurrentDuration 按比例缩放动画时长 willChangeBounds 动画是否会改变view边界，上面说过除了AlphaAnimation其他三个Animation利用Matrix变换实现的动画，所以都会改变边界。故除了AlphaAnimation返回false，其他三个返回true。 willChangeTransformationMatrix 动画是否会改变Transformation matrix。上面说过Transformation是view动画的辅助类。Transformation中matrix的状态基本上可以等同后面view matrix要变换的状态。类似willChangeBounds，除了AlphaAnimation其他三个Animation利用Matrix变换实现的动画，所以都会改变边界。故除了AlphaAnimation返回false，其他三个返回true。 getTransformation(long currentTime, Transformation outTransformation) 获取动画辅助类Transformation  AnimationUtils  loadAnimation() 加载set/alpha/scale/rotate/translate/cliprect动画 loadLayoutAnimation() 加载layoutAnimation/gridLayoutAnimation动画。layoutAnimation并不是严格意义的动画，而是对animation实现控制的辅助类。是用在ViewGroup上控制子控件的动画控制器。可以通过layout文件android:layoutAnimation或者ViewGroup的setLayoutAnimation(LayoutAnimationController controller)设置。 makeInAnimation() 加载Android提供的com.android.internal.R.anim.slide_in_left/com.android.internal.R.anim.slide_in_right动画 makeInChildBottomAnimation() 加载Android提供的com.android.internal.R.anim.slide_in_child_bottom动画 makeOutAnimation() 加载Android提供的com.android.internal.R.anim.slide_out_left/com.android.internal.R.anim.slide_out_right动画  view动画部分xml属性设置：\npivotX取值\t含义\n10\t距离动画所在view自身左边缘10像素\n10%\t距离动画所在view自身左边缘 的距离是整个view宽度的10%\n10%p\t距离动画所在view父控件左边缘的距离是整个view宽度的10%\n属性动画 Android3.0后添加的新的动画。看名字就知道属性动画的原理就是修改对象的属性值来实现的。\nxml文件存放在res/animator。实现类在android.animation包下。\nAnimator\n ValueAnimator  TimeAnimator 继承自ValueAnimator，提供一个TimeListener监听器用来监听当前距动画开始的时间，以及当前距上一动画帧的时间 ObjectAnimator 通过反射改变对象的属性值控制动画，网上的用例太多这里就不举例了。需要注意的是这里所谓的属性是需要设置set方法的，属性本身不一定真的要存在。属性名字是以set方法名为准的。   AnimatorSet 类比AnimationSet  TimeInterpolator\u0026amp;TypeEvaluator  TimeInterpolator 插值器\ngetInterpolation(float input)的参数input[0,1]\n控制动画时间内某个时间点的fraction。不同插值器的在时间轴变化率不同。比如按正弦变化/指数变化\n例如加速插值器AccelerateInterpolator： 1 2 3 4 5 6 7 8 9 10 11  public class AccelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory{ ... public float getInterpolation(float input) { if (mFactor == 1.0f) { return input * input; } else { return (float)Math.pow(input, mDoubleFactor); } } ... }    TypeEvaluator 估值器\n通过fraction控制startValue变换到endValue。如控制argb/int/matrix/rect变换。不同类型的计算方式不同。  总的来说TimeInterpolator是和TypeEvaluator是配合使用的，插值器负责提供改变因子fraction，估值器负责根据改变因子fraction和不同的数据类型提供不同的计算方式得到直接影响或者使用在动画上的数据。\nViewAnimationUtils实现揭露动画 揭露动画是一种慢慢显示vie全貌的动画\n1 2 3 4 5 6 7 8 9 10  public final class ViewAnimationUtils { private ViewAnimationUtils() {} //startRadius 揭露动画结束时的半径  //endRadius 揭露动画结束时的半径  public static Animator createCircularReveal(View view, int centerX, int centerY, float startRadius, float endRadius) { return new RevealAnimator(view, centerX, centerY, startRadius, endRadius); } }   矢量动画 VectorDrawable\n约束布局的关键帧动画 转场动画Transition 移步Android-转场动画Transition\nlottie动画 使用简单，官方用例也详细，这里不再详述。主要将下原理。\n1 2 3 4 5 6 7 8  \u0026lt;com.airbnb.lottie.LottieAnimationView android:id=\u0026#34;@+id/animView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:lottie_fileName=\u0026#34;lottie/222-trail-loading.json\u0026#34; app:lottie_autoPlay=\u0026#34;true\u0026#34; app:lottie_repeatMode=\u0026#34;restart\u0026#34; app:lottie_repeatCount=\u0026#34;-1\u0026#34;/\u0026gt;   lottie有几个重要的类：LottieAnimationView/LottieComposition/LottieCompositionMoshiParser/LottieDrawable/LottieValueAnimator。\nLottieAnimationView继承自AppcompatImageView加载LottieDrawable；LottieDrawable继承自Drawable。LottieDrawable利用LottieCompositionMoshiParser解析资源(json/stream等)得到LottieComposition并配合LottieValueAnimator绘制自己\n  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/",
	"title": "Android打包流程",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android打包流程",
	"content": "前言 说打包流程前我们先了解几个名词和概念\nAAPT(Android Asset Packing Tool) AAPT是一种编译工具，用于Android Studio和Android Gradle Plugin 编译打包应用资源Android资源打包工具。build_toos下有两个版本AAPT工具:aapt和aapt2，Android Gradle Plugin 3.0.0以上版本默认使用aapt2。aapt2是在aapt之上做了优化，aapt2会解析资源，为资源编索引并将资源编译成针对Android平台进行过优化的二进制格式。\naapt2还支持通过启用增量编译实现更快的资源编译，将资源处理拆分为编译和链接两个步骤：\n  编译：将资源文件编译成后缀名为.flat(简单理解为相当于Java中的class文件)的中间二进制格式。\n编译资源示例：aapt2 compile project/module/src/main/res/values/strings.xml -o resoutputdir\nAS中编译出的.flat资源文件可以在build/intermediates/res/merged/debug中找到。\n  链接：合并所有已编译的文件并打包到一个软件包(.ap_文件)中。\n在链接阶段aapt2会合并在编译阶段生成的所有中间文件(例如ARSC_资源表、二进制XML文件和处理过的PNG文件)，并将它们打包成一个.ap_文件，此外还会生成其他辅助文件如：R.java和ProGuard规则文件。.ap_文件的结构和APK一致，只是缺少了dex文件，.ap_文件可以看作一个不包含dex文件且未签名的APK文件，它是.apk的前置文件，看后缀名就知道了。\n.ap_文件位于build/intermediates/processed_res/debug/out/resources-debug.ap_，低版本的AS可能位于build/intermediates/res/debug/resources-debug.ap_，我们解压resources-debug.ap_可以看到里面有AndroidManifest.xml、resources.arsc和res文件夹。\n链接示例：aapt2 link -o output.ap_ -I sdkdir/platforms/android-xx/android.jar resoutputdir/res/values_xxx.arsc.flat resoutputdir/res/drawable_xxx.flat resoutputdir/res/... --manifest path/to/AndroidManifest.xml -v\n另外aapt2 dump [subcommand] [options] xxx.ap_输出有关link命令生成的.ap_的资源和清单信息，具体命令可以使用aapt2 dump -h查看，上面说了.ap_就是个缺少dex的.apk，这里.ap_文件换成build/output/apk/debug/app_debug.apk是一样的\n  这种拆分有助于提高增量编译的性能，当一个文件发生改变只需要重新编译这个文件即可。\n打包流程 打包所需的工具基本都在\nsdk/build_tools/xx.x.x路径下，xx.x.x是版本号\n我们完全可以自己使用该路径下的工具一步一步打包。\n在Android Studio中开发Gradle构建工具帮我们做了这些事情，但Gradle不会自主选择哪个版本号下的打包工具打包，所以需要我们配置，即Module下的build.gradle中配置buildToolsVersion\n另外还需要使用到sdk/tools/lib下的sdklib.jar。\n 使用aapt/aapt2打包资源文件 生成R.java和resources.arsc文件 使用aidl读取.aidl文件生成对应Java文件 使用环境中的Java编译器将Java文件编译成.class文件 使用dx/d8将多个.class文件转换打包成.dex文件 使用sdklib.jar将.dex和其他资源文件打包成.apk 使用zipalign对.apk中未压缩文件对齐优化，减少运行应用时消耗的RAM容量\nZipalign是一个android平台上整理APK文件的工具，它对apk中未压缩的数据进行4字节对齐，对齐后就可以使用mmap函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。 使用apksigner对apk签名  老版本是先使用jarsigner对apk签名后再执行zipalign，现在需要先执行zipalign再使用jarsigner对apk签名，因为V2签名会校验归档中所有字节。否则签名会失效\n老版本使用apkbuilder打包apk，apkbuilder也是调用sdklib.jar完成打包，现在直接使用sdklib.jar打包apk，apkbuilder已被废弃。如果下载过AOSP，你可以在sdk目录中看到一个apkbuilder目录，里面存在apkbuilder，但阅读apkbuilder目录中的readme.txt你可以看到\nThe apkbuilder command line tool is deprecated, and is not maintained anymore. It is lacking recent build improvements such as support for Library Projects. Its source code has been moved into sdklib. It is recommended to directly use the com.android.sdklib.build.ApkBuilder class instead. 平时我们的AS运行，如果没有配置签名，会使用 当前用户目录下/.android/下的签名的。\nAndroid签名V1/V2/V3 见Android 签名机制 v1、v2、v3\nMF 文件清单\nSF：文件清单\nRAS:SF签名和公钥\n魔数 格式\neocd格式\nwallen\n先打未签名包，再加固，因为加固会导致签名失效\n参考：\n 命令行工具 Android 签名机制 v1、v2、v3  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "Android插件化",
	"tags": ["android", "插件化"],
	"categories": [],
	"series": ["插件化"],
	"description": "Syntax highlighting test",
	"content": "开源插件化框架 VirtualAPK、DroidPlugin、RePlugin\nHook 实现Hook的技术：1.反射 2.动态代理\n查找Hook点的原则  尽量静态变量或单例对象 尽量Hook public的对象和方法  插件化原理 启动插件Activity Android中Activity启动流程 应用程序进程想SystemServer进程的ASM请求创建Activity。\n  Activity.startActivity -\u0026gt; Activity.startActivityForResult -\u0026gt; Activity.startActivityFromChild\n-\u0026gt; AMS(ActivityManager).startActivity\n-\u0026gt; Instrumentation.execStartActivityFromAppTask\nThread.currentThread().contextClassLoader?\n  插件化实现启动插件中Activity思考 方式一 使用代理Activity 方式二 Hook AMS/Instrumentation 这种方式仍然需要一个注册的Activity帮我们欺骗AMS以通过验证。\n插件换肤 "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android%E7%94%BB%E4%B8%AD%E7%94%BB-pictureinpicture/",
	"title": "Android画中画-PictureInPicture",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android画中画-PictureInPicture详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%9B%B4%E6%92%AD-%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95/",
	"title": "Android直播-录制屏幕",
	"tags": ["android", "直播", "音视频"],
	"categories": [],
	"series": ["直播"],
	"description": "Syntax highlighting test",
	"content": "录屏的根本是怎么获取屏幕的显示数据\n屏幕录制的几种实现方式：  Linux+framebuffer+root权限 利用View.getDrawingCache() Android shell命令screencap/screenrecord+root权限 SurfaceFlinger+framebuffer VirtualDisplay+MediaProjection  一、Linux+framebuffer+root权限 Android 基于 Linux，所以可以通过读取 /dev/graphics/fb0 设备节点，即 framebuffer 中的帧数据来实现屏幕的录制。但是读取这个设备节点需要 root 权限\n二、View.getDrawingCache() 通过 View 的 cache 内容获取到 Bitmap 对象来达到录屏的效果。但是很多手机上面该方式会存在性能问题，另外该方式并不是一个真正意义上的录屏方式，另外部分 View 组件的内容并不能获取到，比如webview\n三、Android shell命令screencap/screenrecord+root权限 screencap/screenrecord 是 Android shell 的命令，需要root 权限\n creencap -p xxx.png/screenshot xxx.png adb shell screenrecord \u0026ndash;size 1280*720 \u0026ndash;bit-rate 6000000 \u0026ndash;time-limit 30 /sdcard/demo.mp4\n\u0026ndash;size 指定视频分辨率；\n\u0026ndash;bit-rate 指定视频比特率，默认为4M，该值越小，保存的视频文件越小；\n\u0026ndash;time-limit 指定录制时长，若设定大于180，命令不会被执行；  四、SurfaceFlinger + framebuffer 见参考 从surfaceflinger历史变更谈截屏\n五、VirtualDisplay + MediaProjection 在我的华为荣耀8 android8.0 手机上下载虎牙直播测试发现他们使用的是该方案\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  class ScreenCaptureActivity : AbsActivity() { lateinit var surface: Surface private lateinit var surfaceView: SurfaceView lateinit var projectionManager: MediaProjectionManager private var display: VirtualDisplay? = null private var projection: MediaProjection? = null // private var _resultCode: Int? = null  private var _resultData: Intent? = null private lateinit var capture: TextView companion object { const val REQUEST_PROJECTION = 2 const val STATE_RESULT_CODE = \u0026#34;result_code\u0026#34; const val STATE_RESULT_DATA = \u0026#34;result_data\u0026#34; } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_screen_capture) // _resultCode = savedInstanceState?.getInt(STATE_RESULT_CODE)  _resultData = savedInstanceState?.getParcelable(STATE_RESULT_DATA) surfaceView = findViewById(R.id.surface) surface = surfaceView.holder.surface projectionManager = getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager capture = findViewById(R.id.capture) capture.setOnClickListener { if (display == null) { startCapture() capture.text = \u0026#34;停止\u0026#34; } else { stopCapture() capture.text = \u0026#34;开始\u0026#34; } } } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) // if (_resultCode != null) { // outState.putInt(STATE_RESULT_CODE, _resultCode!!) // }  if (_resultData != null) { outState.putParcelable(STATE_RESULT_DATA, _resultData) } } override fun onPause() { super.onPause() stopCapture() } override fun onDestroy() { super.onDestroy() projection?.stop() projection = null } private fun startCapture() { if (/*_resultCode == null \u0026amp;\u0026amp;*/ _resultData == null) { startActivityForResult( projectionManager.createScreenCaptureIntent(), REQUEST_PROJECTION ) } else { setup() } } private fun stopCapture() { display?.release() display = null } private fun setup() { if (projection == null) { projection = projectionManager.getMediaProjection( /*_resultCode!!*/Activity.RESULT_OK, _resultData!! ) } if (projection != null) { display = projection!!.createVirtualDisplay( \u0026#34;ScreenCapture\u0026#34;, surfaceView.width, surfaceView.height, Getter.metrics().densityDpi, DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, surface, null, null ) } } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { REQUEST_PROJECTION -\u0026gt; { if (resultCode != Activity.RESULT_OK) { Toast.makeText(this, \u0026#34;User denied screen sharing permission\u0026#34;, Toast.LENGTH_LONG) .show() return } // _resultCode = resultCode  _resultData = data setup() } } } }   单纯在当前activity或app中实现录屏使用场景有限，实际使用中需要配合Service实现app退到后台继续录屏\n参考：\n 手机游戏直播中的录屏怎么实现 从surfaceflinger历史变更谈截屏  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%9B%B4%E6%92%AD-%E9%87%87%E5%BD%95%E6%91%84%E5%83%8F%E5%A4%B4/",
	"title": "Android直播-采录摄像头",
	"tags": ["android", "直播", "音视频"],
	"categories": [],
	"series": ["直播"],
	"description": "Syntax highlighting test",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/anr/",
	"title": "anr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/anr%E5%88%86%E6%9E%90/",
	"title": "ANR分析",
	"tags": ["anr"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/appbundle/",
	"title": "AppBundle",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/apt/",
	"title": "apt",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ar/",
	"title": "ar",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/camera/",
	"title": "camera",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ffmpeg/",
	"title": "ffmpeg",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/git/",
	"title": "git",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/git-%E8%AF%A6%E8%A7%A3/",
	"title": "git 详解",
	"tags": ["git"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": "[http]\nproxy = 127.0.0.1:1081\n[https]\nproxy = 127.0.0.1:1081\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/",
	"title": "HashMap源码分析",
	"tags": ["java"],
	"categories": [],
	"series": ["源码解析"],
	"description": "HashMap源码分析",
	"content": "以JDK8源码分析\n前言 HashMap是结合数组和链表，以Key-Value形式存储的集合。HashMap中有三个个概念：负载因子(loadFactor)、容量和阀值。默认阀值是0.75，阀值=当前容量*负载因子，如果元素个数超过这个阀值则HashMap容量翻倍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  public class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable { ... static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; Node(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \u0026#34;=\u0026#34; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry\u0026lt;?,?\u0026gt; e = (Map.Entry\u0026lt;?,?\u0026gt;)o; if (Objects.equals(key, e.getKey()) \u0026amp;\u0026amp; Objects.equals(value, e.getValue())) return true; } return false; } } static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } transient Node\u0026lt;K,V\u0026gt;[] table; ... }   可以看出HashMap的基本结构：\n数组table存储一组Node元素，而Node本身又是单向链表，因此table实际上存储的是一组链表的头节点。那么table的容量是多少？存储规则又是什么呢？\n源码分析 put逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果数组tab[i]的位置还没有节点则新建节点存入  //注意这里计算下标i的算法：(n - 1) \u0026amp; hash相当于hash%(n-1)，\u0026amp;运算效率高于取余运算  if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else {//如果数组tab[i]的位置已有节点p  Node\u0026lt;K,V\u0026gt; e; K k; //要存入的节点和节点p的key相同  if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; //如果节点p是红黑树，则使用红黑树存储  else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { //如果节点的下个点解是null，将要存入的键值对做为新的Node存入节点之后  if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //如果某个链表长度大于7个节点尝试将节点转换成红黑树  if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } //如果已经存在相同key的节点，后面会修改这个节点的值  if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } final void treeifyBin(Node\u0026lt;K,V\u0026gt;[] tab, int hash) { int n, index; Node\u0026lt;K,V\u0026gt; e; //如果table.length个数小于MIN_TREEIFY_CAPACITY(64)，先增大容量不转换成红黑树  if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) \u0026amp; hash]) != null) { TreeNode\u0026lt;K,V\u0026gt; hd = null, tl = null; do { TreeNode\u0026lt;K,V\u0026gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } }   remove逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  final Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, index; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) { Node\u0026lt;K,V\u0026gt; node = null, e; K k; V v; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode\u0026lt;K,V\u0026gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null \u0026amp;\u0026amp; (!matchValue || (v = node.value) == value || (value != null \u0026amp;\u0026amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; }   get逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  final Node\u0026lt;K,V\u0026gt; getNode(int hash, Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; hash]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node  ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; }   hash的计算 首先看hash的计算\n1 2 3 4  static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); }   为什么不是直接返回hashCode?为什么是^（异或），为什么是16？\n我们先看计算下标的逻辑：tab[i = (n - 1) \u0026amp; hash]，即下标是(n - 1) \u0026amp; hash，n是n = tab.length，tab = table，即tab实际上是那个Node数组table。\nHashMap的size是一个int值，即4字节32位。所以上面的n，即table.length的值理论上是至少小于HashMap size的一半的，即2字节16位。所以下标的计算i = (n - 1) \u0026amp; hash实际上只会用到hash的低16位。这大大加大了hash冲突，如何让高16位也参与\u0026amp;运算增加散列度呢？于是就有了(h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16)的设计，让hashCode的高16位与hashCode的低16位异或运算。\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-threadlocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "Java ThreadLocal源码解析",
	"tags": ["java"],
	"categories": [],
	"series": ["源码解析"],
	"description": "ThreadLocal源码解析",
	"content": "ThreadLocal应用场景 ThreadLocal适合需要在不同线程存储不同且唯一的上下文信息的场景\n魔数0x61c88647 0x61c88647是一个魔数，它等于2的32次方*黄金比例，用于提高散列度。\n1 2 3 4 5 6 7 8 9 10 11  public class ThreadLocal\u0026lt;T\u0026gt; { private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } ... }   Thread类的threadLocals和inheritableThreadLocals变量 在解析前我们先看Thread类的两个成员变量：threadLocals、inheritableThreadLocals，两个都是ThreadLocal.ThreadLocalMap类型。\nthreadLocals 由ThreadLocal维护其数据的存放和获取。\ninheritableThreadLocals 由InheritableThreadLocal维护其数据的存放和获取。\n每个Thread都有自己的threadLocals、inheritableThreadLocals。ThreadLocal实现线程隔离的原因也在这，即ThreadLocal维护线程的threadLocals中的数据，其get/set也是先借助Thread.currentThread()获取当前线程对象然后对threadLocals操作。\nThreadLocal 1 2 3 4 5 6 7 8 9 10 11 12 13 14  public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); }   ThreadLocal#get方法解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T result = (T)e.value; return result; } } return setInitialValue(); } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } protected T initialValue() { return null; }   ThreadLocalMap的实现 ThreadLocalMap\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  static class ThreadLocalMap { static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } /** * 初始大小 */ private static final int INITIAL_CAPACITY = 16; /** * 大小必须是2的幂 */ private Entry[] table; private void set(ThreadLocal\u0026lt;?\u0026gt; key, Object value) { Entry[] tab = table; int len = tab.length; //这里是最重要的部分 下标的计算，由于threadLocalHashCode是按HASH_INCREMENT递增的，  //所以实际上下标i的值可能出现回头的问题，且前后两次可能会出现空隙，即前一次下标计算是7，后一次计算是14，再下次计算可能就是5了。  //当两次计算的下标一样(比如都是5)怎么办呢？使用nextIndex从当前向后移动一位(即6)，若下标6处没有值则存入这里，若有值则继续下一位，以此循环。  //注意nextIndex的值，当index=len-1时，即达到数组最后以后，nextIndex值返回0，回到从第一位开始找起。  int i = key.threadLocalHashCode \u0026amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal\u0026lt;?\u0026gt; k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) \u0026amp;\u0026amp; sz \u0026gt;= threshold) rehash(); } private static int nextIndex(int i, int len) { return ((i + 1 \u0026lt; len) ? i + 1 : 0); } }   "
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/",
	"title": "Java注解详解",
	"tags": ["java"],
	"categories": [],
	"series": [],
	"description": "Java注解详解",
	"content": "前言 Java注解是JDK5提供的，用于为代码提供元数据。注解不直接影响代码执行。\n注解也是接口类型。即反射时：annotationClass.isInterface = true\nJava注解包含一种特殊的注解：元注解\n元注解 元注解是注解到注解上的注解，是定义注解时必需的。\nJDK中的元注解有5个：@Retention、@Documented、@Target、@Inherited、@Repeatable\n  @Retention\n自定义注解的存活期，取值：\n RetentionPolicy.SOURCE 只存在源码阶段，编译器将java源码编译成class文件时将被忽略丢弃。你可能会问只在源码阶段存在的注解有什么用？用来注释提醒？编译器在将java源码编译成class时会去掉这类注解，但这个过程中注解还是存在的，而APT的处理也发生在这一时期，即APT可以处理生存期为RetentionPolicy.SOURCE的注解。 RetentionPolicy.CLASS 自定义注解Retention的默认值，这类注解会被编译到class文件，但不会被JVM加载。你可能又会问不被JVM加载只存在与class文件中有什么用？我们又不能操作class文件？事实上开发人员并不是完全不能操作class文件，比如ASM。RetentionPolicy.CLASS通常用于定制开发编译过程的人使用，比如在Android中class会被再次编译成dex文件。查看Android中RetentionPolicy.CLASS的注解有很多：@UnsupportedAppUsage、@DoNotCall、@ColorInt、@ColorRes、@NonNull等。 RetentionPolicy.RUNTIME 注解保留到运行期，会被JVM加载，运行期可以使用反射获取。    @Target\n注解使用的地方，可以多选。\n ElementType.TYPE 用于类、接口、枚举 ElementType.FIELD 用于字段 ElementType.METHOD 用于方法 ElementType.PARAMETER 用于方法参数 ElementType.CONSTRUCTOR 用于构造方法 ElementType.LOCAL_VARIABLE 用于局部变量 ElementType.ANNOTATION_TYPE 用于注解 ElementType.PACKAGE 用于包 ElementType.TYPE_PARAMETER 用于范型参数，JDK8提供 ElementType.TYPE_USE 用于类型(范型类型前、类、参数类型前、接口等)，JDK8提供    @Documented\n被@Documented声明的注解所注解的元素会被javadoc工具提取成文档。\n  @Inherited\n被@Inherited声明的注解所注解的超类可以被子类继承这个注解。\n  @Repeatable\nJDK8提供，可重复的注解，即该注解可以在同一个地方多次使用。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface Values { Value[] value(); } @Repeatable(Values.class) @interface Value { String value() default \u0026#34;\u0026#34;; } @Value(\u0026#34;11\u0026#34;) @Value(\u0026#34;22\u0026#34;) class RepeatableTest{ }     反射注解相关API  clazz.isAnnotation();\nclazz是否时注解类型 clazz.isAnnotationPresent(Class\u0026lt;? extends Annotation \u0026gt; annotationClass);\nclazz类上是否有annotationClass类型的注解 clazz.getAnnotation(Class\u0026lt;A\u0026gt; annotationClass);\n获取clazz类上annotationClass类型的注解 clazz.getAnnotationsByType(Class\u0026lt;A\u0026gt; annotationClass);\nJDK8提供，和clazz.getAnnotation(Class\u0026lt;A\u0026gt; annotationClass)的区别是该方法检测注解是否是Repeatable类型的注解，如果是一个或多个该类型的注解。 clazz.getAnnotations();\n返回clazz类的所有注解  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-%E8%8C%83%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/",
	"title": "Java范型与反射",
	"tags": ["java"],
	"categories": [],
	"series": [],
	"description": "Java范型与反射",
	"content": "前言 泛型 ？ extends X 表示类型的上界，类型参数是X的子类\n？ super X 表示类型的下界，类型参数是X的超类\n示例一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Generic\u0026lt;T\u0026gt; { T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } class SubGeneric extends Generic\u0026lt;CharSequence\u0026gt; { } Generic\u0026lt;?\u0026gt; generic = new Generic\u0026lt;\u0026gt;(); Generic\u0026lt;?\u0026gt; generic1 = new SubGeneric\u0026lt;\u0026gt;(); SubGeneric generic2 = new SubGeneric(); generic.setData(\u0026#34;\u0026#34;);//报错 generic1.setData(\u0026#34;\u0026#34;);//报错 generic2.setData(\u0026#34;\u0026#34;);//OK   以上都可以调用get方法，但使用非具体泛型父类的实例却不能使用set方法，因为setData可能有重载而此时我们不能确定具体执行的是那个。\n虚拟机泛型的实现 泛型思想早在C++语言的模板（Template）中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。，由于Java语言里面所有的类型都继承于java.lang.Object，所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期之中。\n泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧。\nC#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List＜int＞与List＜String＞就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。\nJava语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。\n什么是原始类型？什么是类型擦除？看下面示例\n示例一 无限定的泛型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //Java定义 class Generic\u0026lt;T\u0026gt; { T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } //Generic\u0026lt;T\u0026gt;的原始类型 class Generic { Object data; public Object getData() { return data; } public void setData(Object data) { this.data = data; } }   示例二 有限定的泛型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //Java定义 class Generic\u0026lt;T extends CharSequence\u0026gt; { T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } //Generic\u0026lt;T extends CharSequence\u0026gt;的原始类型 class Generic { CharSequence data; public CharSequence getData() { return data; } public void setData(CharSequence data) { this.data = data; } }   示例二 多重限定的泛型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //Java定义 class Generic\u0026lt;T extends CharSequence\u0026amp;Comparable\u0026gt; { T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } //Generic\u0026lt;T extends CharSequence\u0026gt;的原始类型 class Generic { CharSequence data; public CharSequence getData() { return data; } public void setData(CharSequence data) { this.data = data; } }   对于多重限定的泛型其原始类型即是第一限定类型，编译器会在必要时向第一限定CharSequence插入强制转换(成Comparable)，所以为了提高效率应把标签接口(如Serializable、Cloneable等)放在多重限定的末尾。\n反射 反射API解析 "
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-camerax/",
	"title": "Jetpack-CameraX",
	"tags": ["android", "jetpack", "camera", "media"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack-CameraX",
	"content": "一、camera2 CameraX是Jetpack对camera2功能的封装，并可向后兼容至 Android 5.0（API 级别 21）\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/jvmdalvikart/",
	"title": "JVM/Dalvik/ART",
	"tags": ["android", "java"],
	"categories": [],
	"series": ["编程基础"],
	"description": "SJVM/Dalvik/ART理解",
	"content": "前置知识 Android中每个应用都对应一个单独的虚拟机，独立运行\nJIT\u0026amp;AOT  JIT，Just-in-time，即时编译，运行时动态编译。在运行时将频繁运行的代码(热点代码)编译成机器码。 AOT，Ahead Of Time，提前编译，运行前(安装时)编译成机器码。应用在安装的时候会启动 dex2oat 把dex预编译成ELF文件，以后运行程序的时候不用重新编译，因此应用启动更快、运行更快、体验更流畅、触感反馈更及时  JIT缺点：\n由于JIT是运行时动态编译，虽然可以对执行次数频繁的dex代码进行一定优化，但运行时编译成机器码仍然更消耗cpu，更耗电\nAOT缺点：\n应用安装和系统升级之后的应用优化比较耗时（重新编译，把程序代码转换成机器语言）优化后的文件会占用额外的存储空间\nclass\u0026amp;dex class和dex都是8位字节的二进制流文件，但相比class，dex(Dalvik executable)去掉了class文件中很多冗余信息，数据排列也紧密，并将很多class文件整合到dex文件中，减少了IO操作，提高了类的查找速度，dex把所有class文件的header头(包含JDK)写成了一个,所有的常量放在一个池里, dex文件只维护了一个索引。总的来说dex更适合内存和处理器速度有限的系统。\n其他 dexopt 对dex文件进行验证和优化，经过验证和优化后的dex变为odex文件。\ndex2oat 在安装时对dex文件进行dexopt后再将odex进行AOT操作编译成oat可执行文件(机器码)\nodex(Optimized dex) 是Dalvik环境中使用dexopt对dex文件根据当前ROM特性优化后生成odex文件，优化后的odex文件存在手机的data/dalvik-cache目录下\noat(Optimized Android file Type) ART环境下dex经过dex2oat处理过后的文件，.oat中的文件是ELF文件。ELF ELF文件是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。\ndata/app 安装目录 安装时会把apk文件copy到这里\ndata/dalvik-cache 如上述描述中的存放.dex(.odex 无论davilk的dex 还是art的oat格式)\ndata/data/pkg/ 存放应用程序的数据\nJVM\u0026amp;Dalvik\u0026amp;ART JVM  基于栈的的虚拟机，即JVM的指令集是基于栈的。 将java源文件编译成class字节码文件，多class文件运行在虚拟机上  java-\u0026gt;class-\u0026gt;虚拟机运行\nJVM在运行的时候为每一个类装载字节码\nDalvik  基于寄存器的虚拟机,即Dalvik VM的指令集是基于寄存器的。相对于堆栈模式加载速度更快 将java源文件编译成class字节码文件，再由dex.bat编译成一个dex文件(后来因为65535问题有了MultiDex方案，将原来的一个dex拆分为多个dex文件)运行在虚拟机上 Dalvik下应用需要解释执行，常用热点代码在运行时通过即时编译器(JIT)将字节码转换成机器码 相比JVM，Dalvik更适合低内存低cpu运行  ART Android4.4发布ART，此时Dalvik和ART共存，用户可以手动选择，Android5.0废弃DVM，只使用ART，ART和Dalvik的主要区别是ART采用了AOT技术，安装时将字节码编译成机器码，另外ART还对GC过程的也进行了改进，GC 保持暂停状态期间并行处理，在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短，Android7.0以前只使用AOT方式，但Android7.0及后AOT和JIT共存，安装时dex不会再被编译成机器码，App运行时dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息，手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译\nAndroid ClassLoader  BootClassLoader\n用于加载Android Framework层class文件。 PathClassLoader\n用于Android应用程序类加载器，PathClassLoader的parent是BootClassLoader。可以加载指定的dex，以及jar、zip、apk中的classes.dex。 DexClassLoader\n加载指定的dex，以及jar、zip、apk中的classes.dex InMemoryDexClassLoader\nAndroid 8.0提供，用于加载内存中的dex文件。  参考：\n Dalvik和Art,JIT ,AOT, oat, dex, odex Dalvik,ART与ODEX相爱相生  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/kotlin-%E5%8D%8F%E7%A8%8B/",
	"title": "Kotlin协程",
	"tags": ["kotlin", "协程"],
	"categories": [],
	"series": [],
	"description": "Kotlin协程",
	"content": "协程中又一个概念CPS(Continuation Passing Style)\n协程是用户态的行为类似线程的库\n用户态：不想线程在用户态和内核态切换\n类似线程：只是行为类似\n库：协程本质上是一个用线程次调度代码块的库\n可能你会问 没看到线程调度啊 这事编译器字节码操作\n解决线程问题由最开始的代码层面的锁如java中的lock,到一些以node.js为代表的单线程异步回调，异步回调的方式引起Callback hell,再到协程，协程使用状态机处理不同的挂起点，避免了Callback hell\n 线程 actor 协程 协程可以理解为一段代码片段，Kotlin中的协程是利用编译器操作字节码实现的，本质上在利用线程池来切换协程代码片段,协程遇到阻塞会yiel让出cpu并保存上下文,resume恢复的时候恢复上下文  java中的lock避免了锁消耗\nactor和协程的优势是没有锁消耗且切换不想线程那样需要在用户态和内核态切换\n先阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。他们的核心思想是一样的，遇到需要进行I/O操作的地方，就直接让出CPU资源，然后注册一个回调函数，其他逻辑则继续往下走，I/O结束后带着结果向事件队列里插入执行结果，然后由事件调度器调度回调函数，传入结果。这时候执行的地方可能就不是你原来的代码区块了，具体表现在代码层面上，你会发现你的局部变量全部丢失，毕竟相关的栈已经被覆盖了，所以为了保存之前的栈上数据，你要么选择带着一起放入回调函数里，要么就不停的嵌套，从而引起反人类的Callback hell。\n因此相关的Promise，CompletableFuture等技术都是为解决相关的问题而产生的。但是本质上还是不能解决业务逻辑的割裂\n相比于callback接口回调的异步框架，Coroutine这个暂停和恢复在没有JVM支持下，比较难以理解，是怎么做到的？有没有什么魔法？其实JVM中Coroutine的实现方式有很多(implementing-coroutines-in-java)，Quasar Fiber则是通过字节码修改技术在编译或载入时织入必要的上下文保存/恢复代码，通过抛异常来暂停，恢复的时候根据保存的上下文(Continuation),恢复jvm的方法调用栈和局部变量,Quasar Fiber提供相应的Java类库来实现,对应用有一定的侵入性(很小)\nQuasar Fiber 主要有 Instrument + Continuation + Scheduler几个部分组成\nInstrument 做一些代码的植入，如park前后上下文的保存/恢复等\nContinuation 保存方法调用的信息，如局部变量，引用等,用户态的stack,这个也是跟akka等基于固定callback接口的异步框架最大的区别\nScheduler 调度器，负责将fiber分配到具体的os thread执行\n参考：\n 次时代Java编程（一）：Java里的协程 Coroutine in Java - Quasar Fiber实现 深入理解JVM - Java内存模型与线程 - 第十二章 Java线程中wait状态和block状态的区别? 用户态和内核态的理解和区别 Java中的锁分类 协程  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/media/",
	"title": "media",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/mr/",
	"title": "mr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/rxjava/",
	"title": "rxjava",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/rxjava/",
	"title": "rxjava",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/rxjava2%E6%BA%90%E7%A0%81%E5%8F%8A%E4%BD%BF%E7%94%A8/",
	"title": "RxJava2源码及使用",
	"tags": ["java", "rxjava", "android"],
	"categories": [],
	"series": ["源码解析", "rxjava"],
	"description": "RxJava2源码及使用",
	"content": "前言 RxJava是一个响应式的异步事件流编程库。\nRxJava的优势：\n函数式编程，代码逻辑清晰，优雅\n避险回调地狱\n方便的线程调度\nRxJava中主要使用了观察者(订阅者)模式和装饰模式。\n观察者模式vs发布订阅模式 观察者模式 完整的观察者模式有四个部分：\n  抽象被观察者\n可以增加/删除观察者\n当数据状态改变可以通知观察者\n1 2 3 4 5  interface Observable{ void add(Observer o); void remove(Observer o); void change(); }     抽象观察者\n定义一个一个接口当被观察这数据状态改变时可以通知自己\n1 2 3  interface Observer{ void onChange(); }     具体被观察者\n定义一个集合保存或有观察者引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class MyObservable{ boolean change = false; List\u0026lt;Observer\u0026gt; observers = new Arraylist\u0026lt;\u0026gt;; public void add(Observer o){ observers.add(o); } public void remove(Observer o){ observers.remove(0); } public void nofifyObservers(){ if(!hasChange()){ return; } for(Observer o:observers){ o.onChange(); } } public boolean hasChange(){ return change; } public void publish(String message){ ... change = true; nofifyObservers(); } }     具体观察者\n具体实现接收到通知的业务逻辑\n1 2 3 4 5  class MyObserver{ public void onChange(){ //业务逻辑  } }     发布订阅模式 RxJava使用的模式。\n发布订阅模式很像观察者模式，但和一般的观察者模式有一些区别。观察者模式中被观察者持有观察者的引用，当数据状态改变是通过观察者引用回调通知观察者。而发布订阅模式是发布者将数据流发布到管道，发布者不持有订阅着引用，订阅者在管道中即可获得数据流，实现两者的解耦。\nRxJava的结构 RxJava的五大观察者模式  Observable \u0026amp; Observer\n发送0~n个事件 Flowable \u0026amp; Subscriber\n发送0~n个事件，支持背压的被观察者和观察者 Single \u0026amp; SingleObserver\n只发送/接收一次事件或处理onError的被观察者和观察者 Completable \u0026amp; CompletableObserver\n不发送/接收事件，只处理 onComplete 和 onError事件。 Maybe \u0026amp; MaybeObserver\n发送0~1个事件  其他被观察者：\n ConnectableObservable 一般的被观察者和观察者是在订阅(subscribe)时触发事件(数据)发送，但ConnectableObservable则比较特殊，它是在使用操作符connect时才会触发事件(数据)发送。普通的Oservable调用pulish(observable.publish())操作符转成ConnectableObservable。ConnectableObservable调用refCount操作符可转成普通的Oservable。  RxJava被观察者(发布者)和观察者(订阅者)主要分为两类：\n 不支持背压的被观察者(Observable)和观察者(Observer) 支持背压的发布者(Publisher)和订阅者(Subscriber)  RxJava订阅关系涉及到的相关类：\n Emitter  支持背压部分的：FlowableEmitter 不支持背压部分的：ObservableEmitter、CompletableEmitter、SingleEmitter、MaybeEmitter等。   XxxCreate  支持背压部分的：FlowableCreate 不支持背压部分的：ObservableCreate、CompletableCreate、SingleCreate、MaybeCreate等。   XxxSource  支持背压部分的：Publisher(RxJava中没有FlowableSource，Publisher实际相当于FlowableSource) 不支持背压部分的：ObservableSource、CompletableSource、SingleSource、MaybeSource等。    Publisher/Subscriber和Observable/Observer Publisher和Observable对应，Subscriber和Observer对应。\nPublisher和Subscriber是支持背压部分的父类接口和抽象\nObservable和Observer是不支持背压部分的父类接口和抽象\nRxJava流程的结构 流程结构中有三个重要概念：事件源(Source)、被观察者(Observable)、观察者(Observer)。\n什么是事件源？ 在RxJava中XxxSource及Publisher即代表了事件源接口，比如：ObservaleSource、CompletableSource、MaybeSource、SingleSource、Publisher等，他们的共同的特点是有一个subscribe方法。你会发现这几个事件源接口正好对应RxJava的五大被观察者，分别被五大被观察这继承，即被观察者本身也是事件源，这也是为什么观察者可以在一个事件流中不断转换。你可能还会问这怎么是事件源了？只有一个subscribe方法，事件源来自哪？这里还有一个最初事件源的概念，XXXSource不可能凭空发出一个事件，就像Retrofit中的RxJava2CallAdapter中，最初的事件是由Call发出的。RxJava中也可以构建出最初事件源(未实现HasUpstreamXXXSource)，一般是五大被观察者的create方法。比如：Observable.create中事件由ObservableEmitter发出。当然也可能是直接在subscribe(订阅时)调用观察者的onNext方法发送事件。比如：Observable.just(1).subscribe(observer)。\n举个例子来说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  Observable.just(1) //Observable.just返回ObservableJust，这里相当于调用ObservableJust.map  .map(new Function\u0026lt;Integer, String\u0026gt;() { @Override public String apply(Integer integer) throws Exception { return String.valueOf(integer); } }) //ObservableJust.map返回ObservableMap，这里相当于ObservableMap.subscribe  .subscribe(new Observer\u0026lt;String\u0026gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { } @Override public void onError(Throwable e) { } @Override public void onComplete() { } });   在每一次经过操作符对Observable转换的过程中你会发现都是实例化一个新的Observable并将原有的Observable作为Source传给新的Observable，转换过程就是经过这样层层包裹封装，类似装饰模式。同样的调用subscribe后原始的Observer会分别被层层包裹封装。比如上面的例子：\n\u0026mdash;Observable.just \u0026mdash;\u0026gt;ObservableJust\u0026mdash;-map\u0026mdash;-\u0026gt;ObservableMap\u0026mdash;\u0026mdash;subscribe\u0026mdash;\u0026mdash;\u0026gt;\nObserver\u0026mdash;\u0026ndash;subscribe\u0026mdash;\u0026mdash;\u0026gt;MapObserver\u0026ndash;source(ObservableJust).subscribe \u0026ndash;\u0026gt;ScalarDisposable(MapObserver.onNext)\u0026mdash;\u0026gt;Observer.onNext\nCold Obseravle 和Hot Obserable 所谓的Cold Obseravle就是普通的Obserable，Hot Obserable就是ConnectableObservable。\n Cold Obseravle\n当Obseravle被订阅才开始执行发射数据流的代码，当Obseravle被多个订阅者订阅时他们之间的关系是独立的，即多次订阅发射数据流的代码会独立的多次执行。 Hot Obserable\n无论Obseravle是否被订阅者订阅，事件始终会发生，即发射数据流的代码不会因为未被订阅不执行。类似广播的行为。  Cold Obseravle 和Hot Obserable的转换：\n Cold Obseravle转Hot Obserable  调用publish()\n调用publish()转换成ConnectableObservable，继续调用connect()。Obserable和Flowable可以使用该方法，但部分Obseravle如Single、Completable、Maybe等没有publish()直接调用   Hot Obserable转Cold Obseravle  调用refCount()    观察者和被观察者合体的Subject/Processor Subject和Processor/FlowableProcessor既是被观察者又是观察者，他们可以做为观察者将订阅的数据变成自己的数据发送出去。Subject不支持背压，Processor支持背压。\n以Subject为例，它有多个子类：\n AsyncSubject\n只会接受到onComplete之前的最后一个数据 BehaviorSubject\n接收订阅之前的最后一个数据(若订阅之前未发射过数据，则发射一个默认值)，再继续接受之后发射过来的数据。 PublishSubject\n观察者只接受订阅之后的数据 ReplaySubject\n无论何时订阅，都将发射所有的原始数据给观察者 SerializedSubject\n线程安全，多线程情况下保证同时只有一个线程执行onNext、onComplete、onError方法。 UnicastSubject  Processor的子类：\n FlowableProcessor AsyncProcessor BehaviorProcessor MulticastProcessor PublishProcessor ReplayProcessor SerializedProcessor UnicastProcessor  背压 所谓背压即是当上流发送事件的速度快于下流测处理速度，这些事件将会消耗内存，长期积压容易OOM，RxJava中支持背压的观察者和被观察者则帮我们提供了一种处理这种场景的能力和手段，但这不是从根本上解决问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  public enum BackpressureStrategy { /** * 不缓存也不丢弃，下游必须自己处理可能的溢出 */ MISSING, /** * 在下游无法跟上的情况下，发出MissingBackpressureException异常。 */ ERROR, /** * 缓存所有值直到下游消费它，可能会OOM */ BUFFER, /** * 发送request指定数量的item，其他将被丢弃 */ DROP, /** * 只保留最新的onNext值，如果下游无法跟上，则覆盖以前的任何值。 */ LATEST } Flowable.create(new FlowableOnSubscribe\u0026lt;Integer\u0026gt;() { @Override public void subscribe(FlowableEmitter\u0026lt;Integer\u0026gt; emitter) throws Exception { int i = 0; while (i \u0026lt; 10000) { emitter.onNext(i); i++; } emitter.onComplete(); } }, BackpressureStrategy.LATEST).subscribe(new Subscriber\u0026lt;Integer\u0026gt;() { @Override public void onSubscribe(Subscription s) { Log.i(\u0026#34;kkkkkkk\u0026#34;, \u0026#34;onSubscribe\u0026#34;); s.request(100);//下游需要处理的数据或item个数。  } @Override public void onNext(Integer integer) { Log.i(\u0026#34;kkkkkkk\u0026#34;, \u0026#34;onNext\u0026#34; + integer); } @Override public void onError(Throwable t) { Log.i(\u0026#34;kkkkkkk\u0026#34;, \u0026#34;onError\u0026#34; + t.getMessage()); } @Override public void onComplete() { Log.i(\u0026#34;kkkkkkk\u0026#34;, \u0026#34;onComplete\u0026#34;); } });   Scheduler/Schedulers/AndroidSchedulers  Scheduler 每个Scheduler包含一个线程池 Schedulers 负责对Scheduler管理的策略类。 AndroidSchedulers Android平台主要用来管理切换到主线程的类。  使用介绍  Observer和Consumer区别：\n当Observable subscribe Observer时出现异常会走onError\n当Observable subscribe Consumer时出现异常会抛出异常，若外层没有trycatch会崩溃  RxJava 操作符  create 创建Observable需要自己管理事件的发送 unsafeCreate 使用一个已有的Observable创建。 fromArray 依次发送数组数据，如果数据为null，则发送onError事件 just 多个item时走fromArray操作符逻辑。 amb 传递两个或多个Observable给amb时，它只发射其中首先发射数据或通知（onError或onCompleted）的那个Observable的所有数据，而其他所有的Observable的发射物将被丢弃\n ambArray 逻辑同amb。 concat 连接多个Observable，Observable串行运行，串行发送事件 concatEager 连接多个Observable，Observable并行运行，缓存事件，串行发送事件   merge 连接多个Observable，Observable并行运行，并行发送事件 mergeWith 连接多个Observable，Observable并行运行，并行发送事件 mergeArray 逻辑同merge combineLatest\n   timer 延迟指定时间发送一次0L interval 延迟指定时间指定间隔时间发送一次从0L开始递增的Long数字 range\n rangeLong 逻辑同rang，参数是long intervalRang 相当于interval+rang using 创建与Observable具有相同声明周期的一次性资源\n   defer 在订阅前不创建Observable对象，当订阅时为每个订阅者创建一个新的Observable对象。\n empty 创建一个不发出任何项但正常终止的可观察对象。只执行一次onComplete事件。\n never 创建一个不发出任何项且不终止的可观察对象\n throw 创建一个不发出任何项并以错误结束的可观察对象\n sequenceEqual 确定两个观测值是否发出相同的项目序列\n switchOnNext\n zip 按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据.\n zipArray zipIterable buffer 周期性地从一个可观察到的数据集中收集数据包，并发出这些数据包，而不是一次发出一个数据包\n window\n sample\n定期扫描源Observable产生的结果，在指定的间隔周期内进行采样\n throttleLast throttleFirst flatMap 将源Observable发射的item转换成新的Observable发射出去，不保证转换后Observable的发射顺序\n all 所有发射的item是否符合某个条件\n compose 变换源Observable为新的Observable作为源Observable，并将对整个流产生影响，注意和flatMap区别 concatMap 类似于flatMap，但保证顺序\n contains 判断Observable发射的所有数据中，是否包含一个特定的值。给Contains传一个特定的值，如果原始Observable发射了那个值， 它返回的Observable将发射true，否则发射false\n count 统计源Observable发射的items数并仅发射这个items数 debounce 指定时间跨度后发送最近一次的item\n materialize\n dematerialize\n doOnNext 在onNext前执行 doAfterNext 在onNext后执行 doOnError 在onError前执行 doOnComplete 在onComplete和doOnTerminate前执行 doOnTerminate 在doOnComplete后和doOnTerminate前执行 doOnDispose 在调用dispose()后执行 doOnEach 相当于doOnNext+doOnComplete doOnLifecycle 相当于doOnSubscribe+doOnDispose distinct\n join\n groupJoin\n ignoreElements 忽略所有源Observable产生的结果，只会执行onCpmpleted()或者onError()方法 isEmpty 判定原始Observable是否没有发射任何数据 lift 用参数Observer代理返回的源Observer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  Observable.just(1, 2, 3).lift(new ObservableOperator\u0026lt;String, Integer\u0026gt;() { @Override public Observer\u0026lt;? super Integer\u0026gt; apply(Observer\u0026lt;? super String\u0026gt; observer) throws Exception { return new Observer\u0026lt;Integer\u0026gt;() { @Override public void onSubscribe(Disposable d) { observer.onSubscribe(d); } @Override public void onNext(Integer integer) { observer.onNext(String.valueOf(integer)); } @Override public void onError(Throwable e) { observer.onError(e); } @Override public void onComplete() { observer.onComplete(); } }; } }).subscribe(new Observer\u0026lt;String\u0026gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { } @Override public void onError(Throwable e) { } @Override public void onComplete() { } });    map\n ofType 指定某个类型的class，过滤属于这个类型的的结果并cast，其它抛弃 publish 将普通Observable转成可连接的Observable(ConnectableObservable)。\n RefCount 将一个可连接的Observable转换为普通的Observable reduce 将一个函数应用于被观察者的每个item，最后发射\n repeat 重复发送item\n replay 确保所有的观察者收到同样的数据序列，即使他们在Observable开始发射数据之后才订阅\n retry 如果一个可观测到的源发出错误，请重新订阅它，希望它不会出错\n retryUtil retryWhen scan 类似reduce，但不是最后发送一次数据，而是每次函数操作后发送一次数据。\n serialize 强制Observable进行序列化调用并且不能有onError事件，否则终止。\n share 相当于publish()+refCount()\n skip take takeWhile\n sorted startWith\n timeInterval\n timeout 超过时间未发射item 就发射onError\n timestamp 为每个item附加一个时间戳。\n to 将Observable转换成另一种对象或数据结构。\n toFlowable 转为支持背压的Observable，即Flowable(实际是Flowable的子类FlowableFromObservable)  自定义操作符 重写subscribeActual方法。\n可以参考just等，这里不严谨的实现简单的RxView的click操作符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  public class RxView { public static Observable\u0026lt;View\u0026gt; click(View v) { return new ObservableClick(v); } } public class ObservableClick extends Observable\u0026lt;View\u0026gt; { private View view; public ObservableClick(View view) { this.view = view; } @Override protected void subscribeActual(Observer\u0026lt;? super View\u0026gt; observer) { ViewClickDisposable disposable = new ViewClickDisposable(observer, view); observer.onSubscribe(disposable); } static class ViewClickDisposable extends AtomicBoolean implements View.OnClickListener, Disposable { private Observer\u0026lt;? super View\u0026gt; observer; private View view; ViewClickDisposable(Observer\u0026lt;? super View\u0026gt; observer, View view) { this.observer = observer; this.view = view; view.setOnClickListener(this); } @Override public void onClick(View v) { if (isDisposed()) { return; } observer.onNext(v); observer.onComplete(); } @Override public void dispose() { set(true); AndroidSchedulers.mainThread().scheduleDirect(() -\u0026gt; { if (view != null) { view.setOnClickListener(null); } }); } @Override public boolean isDisposed() { return get(); } } }   参考：\n Backpressure Alphabetical List of Observable Operators ReactiveX Documentation Operators  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-sparsearray%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "SparseArray源码解析",
	"tags": ["android"],
	"categories": [],
	"series": ["源码解析"],
	"description": "SparseArray源码解析",
	"content": "前言 SparseArray是谷歌推荐使用的数据结构，可以取代部分HashMap功能。为什么是部分？因为SparseArray是以int为key的Key-Value集合。SparseArray内部是两个数组：int数组mKeys和范型数组mValues。\n源码分析 appent\u0026amp;put逻辑 appent针对键大于数组中所有现有键的情况进行优化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  public void append(int key, E value) { if (mSize != 0 \u0026amp;\u0026amp; key \u0026lt;= mKeys[mSize - 1]) { put(key, value); return; } if (mGarbage \u0026amp;\u0026amp; mSize \u0026gt;= mKeys.length) { gc(); } mKeys = GrowingArrayUtils.append(mKeys, mSize, key); mValues = GrowingArrayUtils.append(mValues, mSize, value); mSize++; } public void put(int key, E value) { int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i \u0026gt;= 0) { mValues[i] = value; } else { i = ~i; if (i \u0026lt; mSize \u0026amp;\u0026amp; mValues[i] == DELETED) { mKeys[i] = key; mValues[i] = value; return; } if (mGarbage \u0026amp;\u0026amp; mSize \u0026gt;= mKeys.length) { gc(); // Search again because indices may have changed.  i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); } mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; } }   可以看出put元素\nremove\u0026amp;delete逻辑 1 2 3 4 5 6 7 8 9 10 11 12  public void remove(int key) { delete(key); } public void delete(int key) { int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i \u0026gt;= 0) { if (mValues[i] != DELETED) { mValues[i] = DELETED; mGarbage = true; } } }   可以看出SparseArray并不是真的把元素删除，而是将值置为DELETED标志对象。并不会像ArrayList一样Arrays.copyOf\nvalueAt逻辑 1 2 3 4 5 6 7 8 9 10 11 12  public E valueAt(int index) { if (index \u0026gt;= mSize \u0026amp;\u0026amp; UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) { // The array might be slightly bigger than mSize, in which case, indexing won\u0026#39;t fail.  // Check if exception should be thrown outside of the critical path.  throw new ArrayIndexOutOfBoundsException(index); } if (mGarbage) { gc(); } return (E) mValues[index]; }   gc逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  private void gc() { // Log.e(\u0026#34;SparseArray\u0026#34;, \u0026#34;gc start with \u0026#34; + mSize);  int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i \u0026lt; n; i++) { Object val = values[i]; if (val != DELETED) { if (i != o) { keys[o] = keys[i]; values[o] = val; values[i] = null; } o++; } } mGarbage = false; mSize = o; // Log.e(\u0026#34;SparseArray\u0026#34;, \u0026#34;gc end with \u0026#34; + mSize); }   总结：当使用Key删除元素时并不会真正删除元素而是置为删除标志对象DELETE，并将需要整理标志mGarbage置为true。当使用index获取Key或Value时则会先根据mGarbage判断是否执行整理函数gc()。这样mValues数组mSize之前的元素就不会存在DELETED，可以用数组下标直接访问。\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/vr/",
	"title": "vr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc/",
	"title": "依赖注入和控制反转(IoC)",
	"tags": ["java"],
	"categories": [],
	"series": [],
	"description": "依赖注入和控制反转(IoC)",
	"content": "控制反转(IoC) Java设计六大原则中有一项是依赖倒置，简单说就是面向接口编程。\n比如Java中每个Service都有一个接口类和实现类，接口一般不会改变，但实现类可能会不断有微小的变化，这样我们都以接口返回给调用者。但接口实例化的对象却仍是写死的。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  interface Human{ void eat(); } class Man implements Human{ void eat(){ } } class Woman implements Human{ void eat(){ } } class Persion { Human human; Persion(){ human = Man(); } public void eat(){ human.eat(); } }   Persion中的human实例话对象仍然是固定的Man，有时我们希望human实例对象由外部控制，这就需要IoC。可以说IoC解决依赖倒置或者面向接口编程最后的一点瑕疵。\n实现\n而依赖注入是实现Ioc的一种手段。依赖注入分三种：\n 构造方法注入 即构造方法传入实例 setter注入 使用set方法设置实例 接口注入 使用接口方式设置\n依赖注入的本质即：当前对象需要使用另一个对象时并不是当前对象内实例化这个对象而是外部实例化这个对象。  Java依赖注入规范 JSR-330 是 Java 的依赖注入标准。定义了如下的术语描述依赖注入:\n A 类型依赖 B类型(或者说 B 被 A 依赖)，则 A类型 称为”依赖(物)dependency” 运行时查找依赖的过程，称为”解析 resolving“依赖 如果找不到依赖的实例，称该依赖是”不能满足的 unsatisfied” 在”依赖注入 dependency injection”机制中，提供依赖的工具称为”依 赖注入器 dependency injector，注射器”  javax.inject javax.inject 指定了获取对象的一种方法，该方法与构造器、工厂以及服务定位器(例如 JNDI)这些传统方法相比可以获得更好的可重用性、可测试性以 及可维护性。此方法的处理过程就是大家熟知的依赖注入，它对于大多数应用是 非常有价值的。\n@Inject 注解 @Inject 标识了可注入的构造器、方法或字段。可以用于静态或实例成 员。一个可注入的成员可以被任何访问修饰符(private、package- private、 protected、public)修饰。注入顺序为构造器，字段，最后是方法。超类的字 段、方法将优先于子类的字段、方法被注入。对于 同一个类的字段是不区分注 入顺序的，同一个类的方法亦同\nProvider 接口 Provider 用于提供类型 T 的实列。Provider 是一般情况是由注入器实现 的。对于任何可注入的 T 而言，您也可以注入 Provider。与直接注入 T 相比， 注入 Provider 使得:\n 可以返回多个实例。 实例的返回可以延迟化或可选 打破循环依赖 可以在一个已知作用域的实例内查询一个更小作用域内的实例。 1 2 3 4 5 6 7 8 9  class Car { @Inject Car(Provider\u0026lt;Seat\u0026gt; seatProvider) { Seat driver = seatProvider.get(); Seat passenger = seatProvider.get(); ... } ... }    get() 用于提供一个完全构造的类型 T 的实例。 异常抛出: RuntimeException—— 当注入器在提供实例时遇到错误将抛出此异 常。例如，对于一个可注入的成员 T 抛出了一个异常，注入器将包装 此异常并将它抛给 get() 的调用者。调用者不应该尝试处理此类异 常，因为不同注入器实现的行为不一样，即使是同一个注入器，也会 因为配置不同而表现的行为不同。  @Qualifier 用于标识限定器注解。任何人都可以定义新的限定器注解。一个限定器注解:\n 是被 @Qualifier、@Retention(RUNTIME) 标注的，通常也被 @Documented 标注 可以拥有属性。 可能是公共 API 的一部分，就像依赖类型一样，而不像类型实现那样 不作为公共 API 的一部分 如果标注了 @Target 可能会有一些用法限制。本规范只是指定了限定 器注解可以被使用在字段和参数上，但一些注入器配置可能使用限定 器注解在其他一些地方(例如方法或类)上。  @Named 基于 String 的限定器\n@Scope 用于标识作用域注解。一个作用域注解是被标识在包含一个可注入构造器的类上的，用于控制该类型的实例如何被注入器重用。缺省情况下，如果没有标识作用域注解，注入器将为每一次注入都创建(通过注入类型的构造器)新实例，并不重用已有实例。如果多个线程都能够访问一个作用域内的实例，该实例实现应该是线程安全的。作用域实现由注入器完成。\n@Singleton 标识了注入器只实例化一次的类型。该注解不能被继承\nDagger2 Dagger2是一个实现依赖注入的框架。\n"
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E5%8D%8F%E7%A8%8B/",
	"title": "协程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%8D%8F%E7%A8%8B/",
	"title": "协程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/",
	"title": "四大组件",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/",
	"title": "四大组件",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
	"title": "多线程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
	"title": "多线程详解",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": "前置知识 线程是CPU调度的最小单位。\n进程是系统进行程序资源分配的最小单位，线程之间共享所在进程的资源。\n一个进程至少有一个线程，一个线程必须依附于一个进程。\n对于不同的操作系统，一个进程拥有的线程数量有一个上限：Linux 1000，Windows 2000。\n线程状态：\n 初始态（NEW） 运行态（RUNNABLE）  就绪态（READY） 运行态（RUNNNIN）   阻塞态（BLOCKED） 等待态（WAITING） 超时等待态（TIMED_WAITING） 终止态（TERMINATED）  并行和并发 一个四车道，那么它的并行能力是4\n并发或者并发量则是一定时间段内通过的最大车辆数\ncpu指令分为特权指令和非特权指令  特权指令 对内存空间的访问范围不受限制，即：既可以访问用户存储空间也可以访问系统存储空间，一般只给操作系统使用，特权指令：时钟操作 I/O操作 内存清零 关机等 非特权指令 一般程序使用，只能访问用户存储空间完成一般性的操作和任务  用户态和内核态  用户态 只能运行非特权指令 内核态 可运行特权指令  用户态切换到内核态的三种方式：  系统调用,在CPU中的实现称之为陷阱指令(Trap Instruction) 如：文件操作和网络数据发送 未预知的异常(注意不等同于java中的异常),如：缺页异常 外围设备中断  Intel x86cpu 有Ring0~Ring3四个级别，Linux将Ring0作为内核态，Ring3作为用户态。Linux进程有4G地址空间 1~3G用户态地址空间 3~4G是内核态地址空间\njava线程和操作系统线程是一一对应的关系，每一个java/c++线程都映射到操作系统上的一个线程。Java中对线程的操作，如：创建/阻塞/切换等都要切换到内核态，这种切换消耗大量系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。Java中synchronized会导致未获得锁的线程进入阻塞状态，引起用户态与内核态的切换\n多线程的意义 首先明确一个cpu核心同时只能执行一个系统线程，这也是为什么一般线程池是和cpu核心关联,通常维护线程alive数量最小设置为CPU_COUNT+1，最大设置为CPU_COUNT*2+1\n多线程的出现是解决并发和性能问题，那么是不是多线程比单线程性能更好呢？那么要看你对性能的理解，对于整个计算机来说并不一定，这要分情况。影响线程性能的主要是线程的状态切换和线程间切换以及为了线程安全引入的线程锁带来的性能消耗\n 单核cpu   计算密集型操作 本身大量占用cpu，多线程的创建和上下文切换(一次上下文切换大概消耗20000个CPU时间周期)反而加重了cpu的负担，影响整个计算机的性能，但程序本身有更多机会竞争cpu时间片 I/O密集型操作 由于操作过程较少占用cpu，多线程有助于提高性能。我们平时大多是这种操作  多核cpu 由于是多核可以同时执行多个线程，此时多线程是有助于极高整个计算机的利用率，提升性能  每个线程维护一个自己的栈\njava内存模型直接保证的原子性包括：read load use assign store write这6个，另外synchronized之间的操作也具备原子性\nLockSupport.park()\nAndroid线程优先级 Process.setThreadPriority(int priority)\nThread.currentThread().setPriority(int newPriority)\nJava线程的API  thread.start()当前线程进入RUNNABLE Thread.yield()不释放锁,当前运行态线程让出cpu时间片给同等优先级的线程执行并进入就绪态 thread.interrupt() 设置thread中断标志位为true,Java中的输入输出流并没有类似于Interrupt的机制，但是Java的InterruptableChanel接口提供了这样的机制，任何实现了InterruptableChanel接口的类的IO阻塞都是可中断的，中断时抛出ClosedByInterruptedException，也是由Thread对象调用Interrupt方法完成中断调用。IO中断后将关闭通道。实现InterruptableChanel接口的类包括FileChannel,ServerSocketChannel, SocketChannel, Pipe.SinkChannel andPipe.SourceChannel，也就是说，原则上可以实现文件、Socket、管道的可中断IO阻塞操作。虽然解除IO阻塞的方法还可以直接调用IO对象的Close方法，这也会抛出IO异常。但是InterruptableChanel机制能够使处于IO阻塞的线程能够有一个和处于中断等待的线程一致的线程停止方案 thread.isInterrupted() 返回thread中断标志位状态 Thread.interrupted() 返回当前thread中断标志位状态并清除中断标志位,另外抛出中断异常被捕获时也会清除中断标志位，如： 1 2 3 4 5 6  try{ Thread.sleep(2000); }catch(InterruptedException e){ e.printStackTrace(); //进入中断异常的catch代码块时会清除中断标志位 }    wait() 释放锁,以便其他等待此锁的线程执行，当前线程进入等待态，必须在synchronized同步代码块中调用 wait(1000) 释放锁,以便其他等待此锁的线程执行，当前线程进入超时等待态，必须在synchronized同步代码块中调 notify()/notifyAll() 当前线程进入RUNNABLE，此时调用当前monitor.wait()的线程重新竞争锁。必须在synchronized同步代码块中调\nnotify是依附于锁(监视器)monitor的，故必须是monitor.wait()/monitor.notifyAll()，如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  private final Object obj = new Object(); private String name = null; public void xxx() { synchronized (obj) { while (name == null) { try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } public void yyy() { synchronized (obj) { name = \u0026#34;name\u0026#34;; obj.notify(); } }    thread.join() 当前线程进入等待态,注意不是thread，但thread必须是alive状态否则join无效，join是通过wait实现的 thread.join(1000) 当前线程进入超时等待态，其他同join() thread.isAlive() 当前显示是否alive,A thread is alive if it has been started and has not yet died thread.setDaemon(true) 设置线程为守护线程，必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常，Java线程分为两种：用户线程和守护线程。当一个程序中所有用户进程结束，程序也就终止了，守护线程也会随即终止，且不保证守护线程执行完毕,即守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点，这也是利用守护线程的原因。守护线程是用来在后台做通用服务的，如垃圾回收线程即时一个守护线程。不要在守护线程中执行业务逻辑操作(比如对数据的读写等).\njava还有一类特殊线程：Hook (钩子) 线程\nRuntime.getRuntime().addShutdownHook(hook);\n在程序即将退出的时候，也就是 JVM 程序即将退出的时候，Hook 线程就会被启动执行,Hook (钩子) 线程的应用场景：  防止程序重复执行，具体实现可以在程序启动时，校验是否已经生成 lock 文件，如果已经生成，则退出程序，如果未生成，则生成 lock 文件，程序正常执行，最后再注入 Hook 线程，这样在 JVM 退出的时候，线程中再将 lock 文件删除掉 Hook 线程中也可以执行一些资源释放的操作，比如关闭数据库连接，Socket 连接等   Thread.sleep(1000) 不释放锁，当前线程进入超时等待态,Thread.sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”  thread.interrupt()和Thread.interrupted()会唤醒Thread.sleep和thread.wait()导致Thread.sleep和thread.wait()抛出中断异常\nthread.stop, thread.suspend and thread.resume为什么被deprecated，详见参考Java Thread Primitive Deprecation\nthread.stop deprecated原因总的说就是太暴力，会引发不可预期问题。因为thread.stop会抛出ThreadDeath异常，而The monitors are unlocked as the ThreadDeath exception propagates up the stack。一般通过代码控制，或者可以通过thread.interrupt()设置锚点配合代码控制\nthread.suspend and thread.resume deprecated原因是容易引起死锁，可以用obj.wait()/obj.notifyAll()替代\n锁分类  公平锁/非公平锁 公平锁非公平锁的区别是是否是按照申请锁的顺序获取锁。其中非公平锁可能会造成优先级反转和饥饿现象。非公平锁的优点是吞吐量比公平锁大，因为维持公平有一定消耗  优先级反转  T0 thread3(低优先级)获得锁SYNC1 T1 thread2(中优先级)与thread3竞争抢占了cpu时间片，thread3仍持有锁 T2 thread1(高优先级)与thread2竞争抢占了cpu时间片 T3 thread1需要获取锁，但锁被thread3持有，thread1挂起 T4 thread2和thread3都处于可运行态，但由于thread2的优先级高于thread3，thread2优先抢占cpu时间片 总结：这导致了一个现象：低优先级thread2比高优先级thread1先执行 解决：优先继承，即高优先级线程需要低优先级线程持有的锁时，临时提升低优先级线程的优先级，如上面将thread3优先级临时提升到thread1的优先级别，当锁被释放的时候thread3恢复到原来的优先级,这一过程一般有操作系统完成   饥饿 高优先级线程不断进入导致低优先级线程一直无法得到执行   独享锁/共享锁 独享锁：只能被一个线程同时持有，共享锁：可被多个线程同时持有 互斥锁/读写锁 自旋锁 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU 可重入锁 又名递归锁，是指已持有该锁再次调用需要该锁的其他代码块自动获取锁。可重入锁有效避险死锁现象 分段锁 分段锁其实是一种锁的设计，并不是具体的一种锁,目的是细化锁的粒度 java中ConcurrentHashMap就是分段锁，当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入，但在统计size的时候，需要获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计 向锁/轻量级锁/重量级锁 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。\n偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，\n重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低 乐观锁/悲观锁 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。\n悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。\n乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。\n悲观锁在Java中的使用，就是利用各种锁。\n乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新  Java中的锁实现   Synchronized 公平锁 独享锁 可重入锁 synchronized不包含在方法签名，不能继承\n  Lock Java1.5 通过AQS的来实现线程调度，是代码层面实现的锁，比Synchronized轻量，lock的代码块程序抛出异常也不会释放锁，需要手动释放，故使用Lock必须在try{}catch{}块中进行，并且将释放锁的操s作放在finally代码块\nlock() 获取锁，未获取则等待\ntryLock() 获取锁，未获取则等待，有返回值，表示获取锁是否成功\ntryLock(long time, TimeUnit unit)获取锁，未获取则等待，有返回值表示设定时间内获取锁是否成功\nlockInterruptibly() 如果线程正在等待获取锁，则这个线程能够响应中断，通过thread.interrupt()中断线程的等待状态\nnewCondition() 返回当前lock的Condition实例。\n注：thread.interrupt()只能中断阻塞的线程，故线程获取锁之后不能响应interrupt()中断\n ReentrantLock 可重入锁，独享锁，默认非公平锁，可以通过构造函数指定是否是公平， ReadWriteLock 读写锁 读锁是共享锁，写锁是独享锁，即可以共读读，不能共写读，读写，写写  ReentrantReadWriteLock 可重入读写锁，继承ReadWriteLock，并支持ReentrantLock可重入锁的特性      Condition 配合lock使用，await()/signal()/signalAll()类比monitor.wait()/monitor.notify()/monitor.notifyAll()\n  参考：\n 深入理解java内存模型系列文章 synchronized原理和锁优化 Java 多线程之 Hook (钩子) 线程 Java Thread Primitive Deprecation Java线程中wait状态和block状态的区别? 用户态和内核态的理解和区别 Java中的锁分类 Java 并发性和多线程  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A1%A5%E5%85%85/",
	"title": "多线程详解补充",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "对多线程详解中提到的部分概念的补充",
	"content": "Java内存模型 Java内存模型主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与Java编程中的变量略有区别，它包括实例变量/静态字段和构成数组对象的元素，不包括局部变量和方法参数（线程私有）。为获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交换，也没有限制即时编译器调整代码执行顺序这类权利。\nJava内存模型规定所有变量都存储在主存（Main Memory）中（虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory），线程的工作内存保存了被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取/赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主存来完成。\n这里的主内存/工作内存与Java内存区域中的Java栈/堆/方法区并不是同一个层次的内存划分。如果两者一定要勉强对应起来，那从变量/主内存/工作内存的定义来看，主内存主要对应于Java堆中对象的实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低的层次来说，主存就是硬件的内存，而为获取更好的运算速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存。\n主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成:lock unlock read load use assign store write\n对long和double型变量的特殊规则 允许虚拟机将没有被volatile修饰的64位数据类型（long和double）的读取操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，就点就是long和double的非原子协定（Nonatomic Treatment of double and long Variables）。\n如果多个线程共享一个为声明为volatile的long或double类型变量，并同时对他们进行读取和修改操作，那么有些线程可能会读取到一个即非原值，也不是其他线程修改值得代表了“半个变量”的数值。\n不过这种读取带“半个变量”的情况非常罕见（在目前商用虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。\n原子性、可见性和有序性  原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问具备原子性（long和double例外）。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足需求，尽管虚拟机未把lock和unlock操作直接开放给用户，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反应到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。 可见性（Visibility）：指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 有序性（Ordering）：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-if-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入  多线程安全 多线程安全问题根本原因是内存copy和时间片分配导致的，要做到线程安全就是要做到“局部串行”或者原子性，比如两个线程同时访问一个临界资源（一个对象，对象中的属性，一个文件，一个数据库等）可能引发线程安全问题，这时就要做到两个线程访问临界资源这一局部顺序是串行执行\n高优先级线程并不一定比低优先级线程先抢占cpu资源，高级优先抢占资源的权重大，但有随机性\nvolatile/Semaphore/AtomicXXX 两者本质上不是同一类东西\n volatile Java关键字 声明某个变量值的一致性(内存同步)，但不保证原子操作，对赋值操作可以保证原子性。如：a=10，不能保证a++操作的原子性，因为a++其实是a=a+1的语法糖，a=a+1在内存中其实是分两步的：temp=a+1 a=temp。对于复杂对象的赋值操作原子性，如：User user=user1;User user=new User;,但不能保证对user.name属性操作的原子性.即可以看作只能赋值操作原子性。volatile 声明某个变量值的一致性(内存同步)，但不保证原子操作 Semaphore 控制同时访问某个特定资源或者某个操作的操作数量 AtomicXXX Java库实现 可以保证a++操作的原子性  CountDownLatch与join 比如有三个线程 thread1,thread2,thread3\n当thread3需要thread1,thread2都执行完毕后执行，则两者皆可实现，但当thread3只需要thread1,thread2其中一个执行完毕就可执行的场景CountDownLatch很容易实现，使用join则并不容易实现\n详见参考：CountDownLatch理解一：与join的区别\nRunable Future Callable Java中可以简单认为Thread是是对线程的抽象，而Runable和Callable是对线程任务的抽象，Future线程任务结果的容器。\n  Runable 1.没有返回值 2.无法抛异常\n1 2 3  public interface Runnable { public abstract void run(); }     Callable 1.有返回结果，可以抛异常，但不像Runnable那样通过Thread的start方法就能启动实现类的run方法，通常利用ExecutorService的submit方法去启动call方法自执行任务，而ExecutorService的submit又返回一个Future类型的结果，因此Callable通常也与Future一起使用\n1 2 3  public interface Callable\u0026lt;V\u0026gt; { V call() throws Exception; }     Future 保存异步计算的结果,可以在我们执行任务时去做其他工作,Future有一下方法\n1. boolean cancel(boolean mayInterruptIfRunning);用来取消任务，成功返回true，失败则返回false\n2.boolean isCancelled();任务是否已经取消\n3.boolean isDone();任务是否已经完成\n4.V get() throws InterruptedException, ExecutionException;用来获取执行结果，这个方法会产生阻塞会一直等到任务执行完毕才返回\n5.V get(long timeout, TimeUnit unit)\nthrows InterruptedException, ExecutionException, TimeoutException;用来获取执行结果，如果在指定时间内，还没获取到结果，直接返回null\n使用Future的好处：\n1.获取任务的结果，判断任务是否完成，中断任务\n2.Future的get方法很好的替代的了Thread.join或Thread,join(long millis)\n3.Future的get方法可以判断程序代码(任务)的执行是否超时，如：\n1 2 3 4 5 6  try { future.get(60,TimeUtil.SECOND); } catch(TimeoutException timeout){ og4j.log(\u0026#34;异常，将被取消！！\u0026#34;); future.cancel(); }     FutureTask\n对Callable的封装，可以让使用Callable像Runnable一样使用且可以获取Callable的返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public interface RunnableFuture\u0026lt;V\u0026gt; extends Runnable, Future\u0026lt;V\u0026gt; { /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); } public class FutureTask\u0026lt;V\u0026gt; implements RunnableFuture\u0026lt;V\u0026gt; { ... public FutureTask(Callable\u0026lt;V\u0026gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable  } public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable  } ... }     CompletableFuture 提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法,帮助我们简化异步编程的复杂性,有点类似于rxjava的模式，当然没有提供这么丰富的功能\n    多线程间的通信  内存共享  共享volatile变量 synchronized+notify+wait lock+condition semaphere+flag   管道  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  public class CommunicateWhitPiping { public static void main(String[] args) { PipedOutputStream pos = new PipedOutputStream(); PipedInputStream pis = new PipedInputStream(); try { //将管道输入流与输出流连接 此过程也可通过重载的构造函数来实现  pos.connect(pis); } catch (IOException e) { e.printStackTrace(); } //创建生产者线程  Producer p = new Producer(pos); //创建消费者线程  Consumer c = new Consumer(pis); //启动线程  p.start(); c.start(); } } //生产者线程(与一个管道输入流相关联) class Producer extends Thread { private PipedOutputStream pos; public Producer(PipedOutputStream pos) { this.pos = pos; } public void run() { int i = 8; try { pos.write(i); } catch (IOException e) { e.printStackTrace(); } } } //消费者线程(与一个管道输入流相关联) class Consumer extends Thread { private PipedInputStream pis; public Consumer(PipedInputStream pis) { this.pis = pis; } public void run() { try { System.out.println(pis.read()); } catch (IOException e) { e.printStackTrace(); } } }    公共接口 消息通信 如：Actor模型  BlockingDeque   BlockingDeque\nadd/remove 添加元素/移除元素 当队列满/空时抛异常\noffer/poll 添加元素/取出元素\nput/take 添加元素/取出元素 当队列满/空时会阻塞put/take\n  ArrayBlockingQueue\n基于数组的阻塞队列，初始化需要指定固定大小\n  LinkedBlockingQueue\n基于链表实现的阻塞队列，初始化可以指定大小，也可以不指定。\n  LinkedBlockingDeque\n  ConcurrentHashMap\n  ConcurrentLinkedQueue\n  DelayQueue\n  SynchronousQueue\n无容量的队列\n  LinkedTransferQueue\n  多线程的经典场景-生产者消费者模式实现  阻塞队列实现 synchronized关键字实现 lock实现  Java线程内存 Java线程内存有共享区和私有区\n 共享区\n堆 方法区(运行时常量池)[常量 静态变量 类信息] 私有区 有三部分：栈虚拟机、本地方法栈、程序计数器  虚拟机栈 虚拟机栈的每个栈帧对应一个调用方法的信息，可以使用-Xss设置虚拟机栈大小，一般是1M。由以下四部分组成  局部变量表 用于存放八大基本数据类型和对象的引用 操作数栈 存放操作数的一块临时空间 动态链接 存放编译时不能确定方法入口的方法的地址，需要在运行时来保证方法调用的正确性。如：多态方法、native方法。当线程中调用到native方法时JVM不会在为其在虚拟机栈中创建栈帧，而是存储动态链接并直接调用native方法， 方法出口 返回地址   本地方法栈 保存native方法信息，虚拟机规范中并没有强制规定本地方法栈的实现，各版本虚拟机也是自由实现，HotSpot则是将本地方法栈和虚拟机栈合二为一了。 程序计数器 记录程序执行到哪个位置，指向的是当前线程正在执行的字节码指令的地址(行号)。由于Java是多线程的，为了保证多线程切换后正确的执行所以需要程序计数器来记录执行位置。    线程池 对于计算密集型和I/O密集型任务线程池的配置是不同的。\n一般计算密集型的corePoolSize最好是：CPU核心数，I/O密集型的corePoolSize是：CPU核心数 * 2，但实际设计线程池时corePoolSize分别会是：CPU核心数+1和CPU核心数 * 2+1。为什么会+1？因为CPU从磁盘读取数据到内存时都是按页读取，一般一页是4kb，就算你只需要读取一字节操作系统也会读取一页数据到内存。这也是很多地方需要内存对齐的原因。在操作系统读取磁盘数据到内存的过程中可能会出现页缺失错误，这时候系统会将当前线程挂起，将CPU空闲出来，如果是corePoolSize等于CPU核心数就会浪费一个核心，如果是CPU核心数+1则可以充分利用CPU核心数。\n当计算操作和I/O操作所耗时间差不多时应尽量将线程池拆分为计算密集型和I/O密集型\n参考：\n 深入理解JVM - Java内存模型与线程 - 第十二章 Java CompletableFuture 详解 CountDownLatch理解一：与join的区别  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
	"title": "数据结构",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
	"title": "数据结构",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
	"title": "数据结构",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/",
	"title": "数据结构与算法",
	"tags": ["数据结构", "算法"],
	"categories": [],
	"series": ["数据结构", "算法"],
	"description": "数据结构与算法",
	"content": "前言 程序 = 数据结构 + 算法\n似乎数据结构和算法是两码事，但实际有时候数据结构和算法联系非常亲密，可以说有了这种数据结构才有了这种算法或者说有了这种算法的诉求才设计出的这种数据结构。\n数据结构 Java数据结构   ArrayList\n  LinkedList\n  HashMap\n优化capacity\n  SparseArray\n  二分查找\n  二叉树\n  红黑树\n  "
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%AE%97%E6%B3%95/",
	"title": "算法",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%AE%97%E6%B3%95/",
	"title": "算法",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%AE%97%E6%B3%95/",
	"title": "算法",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/",
	"title": "算法-快速排序算法",
	"tags": ["算法"],
	"categories": [],
	"series": ["算法"],
	"description": "快速排序算法",
	"content": "前言 快速排序算法(Quick Sort)是对冒泡排序算法的改进。\n算法思想 任意取一数据(比如数组中一个元素)作为关键数据，称为基准数(Pivot)。然后将所有比它小的数据放在它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序，也称为分区（partition）操作。这样前面一部分的数据会比后面一部分的数据都要小。然后再分别对两部分数据再次快速排序，依此类推进行递归。以达到整个数组变成有序序列。但这可能出现一种情况：所选基准数恰好就是最小值或最大值，这将极大影响快速排序性能，所以选择合适的基准数很重要。为了提升性能，有时我们在分割后独立的两部分的个数小于某个数（比如15）的情况下，会采用其他排序算法，比如插入排序。\n算法实现 双基准快速排序(Dual Pivot Quick Sort) 双基准排序是对快速快速的改进，即使用两个基准数排序。双基准排序在实验上看比快速排序提高10%的性能(节省10%性能)。\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%BC%93%E5%AD%98%E5%8F%8Alru%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "缓存及LRU源码解析",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "缓存及LRU源码解析",
	"content": "占坑，敬请期待\u0026hellip;\nLRU实际上是对访问排序LinkedHashMap的封装\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": ["编程基础"],
	"categories": [],
	"series": ["编程基础"],
	"description": "编程基础",
	"content": "字长 字长是CPU的主要技术指标之一，指的是CPU一次最大能并行处理的二进制位数\n现在主流的计算机字长是32位与64位\n原码\u0026amp;反码\u0026amp;补码 为了表示负数，将最高位解释为符号位\n正数的原码、反码、补码均相同\n对于负数，已知原码求反码，符号位不变，其它位按位求反\n对于负数，已知原码求补码，先求反码，再在反码末位加1\n计算机中数值都是以补码的方式存储的。这样做的好处是：\n符号位和其他位可以统一运算处理，减法可以按照加法处理\n堆栈（stack）和堆(heap) 堆栈（stack）和堆(heap)是应用程序中的两个地址空间，任何应用程序都有，和语言无关。栈和堆映射到物理内存RAM上，只不过栈使用栈这中数据结构存储数据。通常栈是有一定上限的(比如windows是2M)，而堆可以使用整个RAM的80%，但Android稍微有些例外，Android会给每个App设置一个内存上限。\n小端序列\u0026amp;大端序列 \u0026laquo;、\u0026raquo;和\u0026raquo;\u0026gt;运算 见参考Java中的\u0026laquo; 和 \u0026raquo; 和 \u0026raquo;\u0026gt; 详细分析\n \u0026laquo; 有符号左移位运算 \u0026gt;\u0026gt; 有符号右移位运算 \u0026gt;\u0026raquo; 无符号右移位运算  没有\u0026laquo;\u0026lt;(无符号左移位运算)。\n参考：\n Java中的\u0026laquo; 和 \u0026raquo; 和 \u0026raquo;\u0026gt; 详细分析  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/",
	"title": "网络基础",
	"tags": ["java"],
	"categories": [],
	"series": ["java"],
	"description": "网络基础",
	"content": "TCP/IP和OSI TCP/IP协议簇 TCP/IP协议簇既然是以TCP和IP两个协议命名，足以说明TCP和IP两个协议在这个协议簇中的重要性了。另外这个协议簇中比较重要的还有SLIP协议、PPP协议、ICMP协议、ARP协议、UDP协议、FTP协议、DNS协议、SMTP协议等\nTCP/IP模型 TCP/IP协议簇构成的通信互联系统，当前工业中事实上的标准是TCP/IP四层模型。\n  链路层(网络接口层)(Link Layer)\n链路层主要包括：MAC(媒体接入控制)、RLC(无线链路控制)、BMC(广播/组播控制)、MTU(最大传输单元)、PDCP(分组数据汇聚协议)、PPP(点对电协议)、SLIP(串行线路因特网协议)、CSLIP(压缩的串行线路因特网协议)、ARP(地址解析协议)、RARP(反向地址转换协议)。\nMTU、PPP、CSLIP、SLIP、ARP、RARP等用于传输有地址的帧以及错误检测功能。\nISO2110、IEEE802、IEEE802.2等用于以二进制数据形式在物理媒体上传输数据。\n链路层主要是负责提供介质访问和链路管理及物理传输。\n对应OSI模型的数据链路层和物理层。\n  网络层(网际层)(Internet Layer)\n网络层的协议主要有：IP、ICMP、IGMP、BGP、RIP、OSPF等。\n网络层主要是负责IP寻址和路由选择。\n对应OSI模型的网络层。\n  传输层(Transport Layer)\n传输层的协议主要有：TCP、UDP、RTP、SCTP。\n传输层主要是负责建立、管理和维护端对端的连接。\n对应OSI模型的传输层。\n  应用层(Application Layer)\n应用层的主要协议有：HTTP、SMTP、SNMP、FTP、Telnet、SSH、NFS、DNS、TFTP等。\n对应OSI模型的应用层、表示层、会话层。\n  OSI(Open System Interconnection) OSI(开放式系统互联)是国际标准组织制定的的模型，由于其模型过于复杂理想化并没有市场。\n  物理层(Physical Layer)\n物理层主要是负责在物理媒体(网卡，网线，集线器，中继器，调制解调器)上传输原始的数据比特流。\n  数据链路层(Data Link Layer)\n数据链路层主要是负责提供介质访问和链路管理。包括将数据分成一个个数据帧，以数据帧为单位传输。有应有答，遇错重发。该层的设备有：网卡，网桥，网路交换机等。\n  网络层(Network Layer)\n网络层主要是负责IP寻址和路由选择。包括将数据分成一定长度的分组，将分组穿过通信子网，从信源选择路径后传到信宿。该层的设备有：路由。\n  传输层(Transport Layer)\n传输层主要负责建立、管理和维护端对端的连接。包括提供不具体网络的高效、经济、透明的端到端数据传输服务。\n  会话层(Session Layer)\n会话层主要负责建立、管理和维护会话。进程间的对话也称为会话，会话层管理不同主机上各进程间的对话。\n  表示层(Presentation Layer)\n表示层主要负责对来自应用层的命令和数据进行解释，对各种语法赋予相应 的含义，并按照一定的格式传送给会话层。其主要功能是\u0026quot;处理用户信息的表示问题，如编码、 数据格式转换和加密解密，压缩解压缩\u0026quot;等\n  应用层(Application Layer)\n应用层主要负责为应用程序提供网络服务，提供应用程序访问OSI环境的手段。\n  TCP/IP五层模型 OSI和TCP/IP四层模型都有各自的缺陷，TCP/IP五层模型是结合OSI和TCP/IP优点的分层，是OSI的简化模型。五层模型主要用于学术学习。\nTCP/IP五层分别是：\n  物理层(Physical Layer)\n对应OSI模型的物理层\n  数据链路层(Data Link Layer)\n对应OSI模型的数据链路层。\n  网络层(Internet Layer)\n对应OSI模型的网络层。\n  传输层(Transport Layer)\n对应OSI模型的传输层。\n  应用层(Application Layer)\n对应OSI模型的应用层、表示层、会话层。\n  URI和URL URI(Uniform Resource Identifier) 统一资源标识符，用于标识某一互联网资源的字符串。\nURL(Uniform Resource Locator)统一资源定位符，因特网的万维网服务程序上用于指定信息位置的表示方法。\n可以认为URL是URI特例、子集。\nMAC地址 IP地址 端口号   MAC(Media Access Control)地址\nMAC地址一般是由6字节(12个十六进制数表示，如：08:00:20:0A:8C:6D)，前3字节(24位)是由生产网卡的厂商向IEEE申请的厂商地址，后3字节由厂商自行分配给所生产的每个网卡设备(厂商将MAC地址写进网卡的BIOS里)且保证不重复，这样就保证了全球唯一。现在一般的接入Internet的方式是将主机通过局域网组织在一起然后通过交换机和Internet相连，为了防止IP盗用问题在交换机在内部存在一个IP地址-MAC地址的映射表，当有数据包发给局域网内某一台主机时交换机接收下来并根据映射表转发给对应的主机上。\n  IP地址 定位到某个计算机\n  端口号 端口号用16位表示，即0~65535，用于定位到主机上的某个应用程序，其中:\n 0~1023 是分配给系统的端口号 1024~49151 是登记端口号，是要是分配给第三方应用使用，但是必须在IANA（互联网数字分配机构）按照规定手续登记 49152~65535 是短暂端口号，是留给客户进程选择暂时使用，一个进程使用完就可以供其他进程使用。    常用端口号：\n   TCP端口号 应用程序     21 FTP服务器   22 SSH服务器   25 SMTP服务器   80 HTTP服务器   2000 FTP客户端   2001 HTTP客户端    Socket 根据RFC793的定义：端口号拼接到IP地址就构成了套接字。即Socket用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。\nSocket(套接字)是一个抽象层。传输层实现端到端的通信，两边的通信端点(主机IP地址+端口号)即是Socket。每个TCP的Socket的内核中都有一个发送缓冲区和一个接收缓冲区。\n在编程中Socket是应用层与TCP/IP协议族通信的中间软件抽象层，一组编程接口，对TCP/IP的封装。\nJava中的Socket类则是对套接字的具体实现。\n全双工\u0026amp;半双工\u0026amp;单工  全双工 客户端向服务端发送数据的同时服务端也可以向客户端发送数据 半双工 同一时刻允许客户端向服务端发送数据或 服务端向客户端发送数据，两者不可同时进行 单工 只能客户端向服务端发送数据  TCP 数据在TCP层称为流（Stream），数据分组称为分段（Segment）。\nTCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但网络层不提供这样的流机制，IP只提供不可靠的包交换。\nTCP协议的运行可划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。\nACK：Acknowledgment，确认应答，表示已收到消息。ACK是一些通信协议下用来做确认消息的控制字符。在TCP协议中表示创建连接时收到了SYN数据包或使用连接时收到数据包或断开连接时收到FIN数据包。\nRST：重置连接\nSYN：Synchronize，发起了一个新连接\nFIN：为1表示发送方没有数据要传输了，要求释放连接。\nTCB：当主机收到一个TCP包时，用两端的IP地址与端口号来标识这个TCP包属于哪个session。使用一张表来存储所有的session，表中的每条记录称作Transmission Control Block（TCB），TCB结构的定义包括连接使用的源端口、目的端口、目的ip、序号、应答序号、对方窗口大小、己方窗口大小、tcp状态、tcp输入/输出队列、应用层输出队列、tcp的重传有关变量等\nCRC：Cyclic redundancy check，循环冗余校验，CRC为校验和的一种。一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。\nMTU：Maximum Transmission Unit，最大传输单元，是指数据链接层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络卡、串口等）。\nRTT：Round-trip delay time，在通信（Communication）、电脑网络（Computer network）领域中，意指：在双方通信中，发讯方的信号（Signal）传播（Propagation）到收讯方的时间（意即：传播延迟（Propagation delay）），加上收讯方回传消息到发讯方的时间（如果没有造成双向传播速率差异的因素，此时间与发讯方将信号传播到收讯方的时间一样久）。\nMSS：最大分段大小，是在单个分段中TCP愿意接受的数据的字节数最大值。MSS应当足够小以避免IP分片，它会导致丢包或过多的重传。在TCP连接创建时，双端在SYN报文中用MSS选项宣布各自的MSS，这是从双端各自直接相连的数据链路层的最大传输单元(MTU)的尺寸减去固定的IP首部和TCP首部长度。\nTCP数据包头结构见参考TCP Header\nTCP建立连接 - TCP三次握手(three-way handshake) 三次握手主要是解决数据传输的可靠性，交换TCP通信的初始序号。因为数据传输过程中数据包会拆分成多个Segment，每个Segment由一个序号标识。\n两个终端的连接通常是由一端(服务器端)打开一个套接字（socket）(比如HTTP的80，HTTPS的443端口)然后监听来自另一方的连接，这就是通常所指的被动打开（passive open）。服务器端被被动打开以后，用户端就能开始创建主动打开（active open）。\n为什么是三次握手？TCP是全双工传输，如果是两次握手只能保证客户端给服务端发送数据的可靠性(第二次握手已经可以确认第一次握手客户端发送给服务端的序号已收到)，但不能保证服务端给客户端发送数据的可靠性，因为并不能保证第二次握手服务端发送给客户端的序号客户端已收到。\n  客户端请求建立连接\n客户端向服务端 发送一个SYN数据包，SYN位置为1，SYN数据包包含一个随机数J。\nClient -\u0026gt; Server SYN=1，seq=J(系统生成的随机数)\nseq为什么必须是随机数？想象一下如果在第一次握手后网络意外断开然后重新连接再次握手，如果是固定的一个序列数那就没法判断之前第一次握手的数据包到底是哪一次的。\n  针对客户端的SYN的确认应答并请求建立连接\n服务端收到SYN数据包并确认合法后想客户端发送一个SYN-ACK数据包，SYN位和ACK位置为1，SYN-ACK数据包包含一个随机产生的序号K，另外作为对客户端请求建立连接的确认应答，确认应答码ack=J+1\nServer-\u0026gt;Client SYN=1，ACK=1，ack=J+1，seq=K\n其中ack=J+1是向客户端表示服务端确实收到客户端的seq且无误\n  针对服务端的SYN的确认应答\n客户端收到服务端的SYN-ACK数据包并确认合法后向服务端发送一个ACK数据包，ACK位置为1，作为对服务端请求建立连接的确认应答，确认应答码ack=K+1。当服务端收到ACK数据包时就完成了三次握手，并进入了连接创建状态。\nServer-\u0026gt;Client ACK=1，ack=K+1\n其中ack=K+1是向服务端表示客户端确实收到服务端的seq且无误，第三次握手是可以同时携带数据的\n  三次握手漏洞 SYN洪泛攻击 定义：\n通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。\n原理：\n攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(永远都不会有的)，服务端在等待这种半开的连接过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。\n服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow决定超出能力时的行为。\n解决方案：1.无效连接监控释放 2.延缓TCB(Transmission Control Block)分配方法 3.防火墙\nTCP数据传输 三次握手建立连接后TCP向应用层发送信号开始传输数据和通信，TCP按照以下方式处理数据传输：\n TCP使用HTTP，SMTP和POP3（电子邮件）和FTP等协议将来自应用程序的消息分解为适当长度(通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制)的Segment并标记序列号。 TCP将Segment（message pieces）传输到远程主机。 远程主机上的TCP会重组这些Segment。 远程主机收到Segment会向发送方发送ACK确认应答消息表示已收到某个Segment。  TCP断开连接 - TCP四次挥手(four-way handshake) 四次挥手是HTTP断开连接的过程，断开连接可能是客户端向服务端请求断开连接，也可能是服务端向客户端请求断开连接，两者过程基本一致。\nTCP连接可以工作在TCP半开状态。即一侧关闭了连接，不再发送数据；但另一侧没有关闭连接，仍可以发送数据。已关闭的一侧仍然应接收数据，直至对侧也关闭了连接。\n首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793定义了MSL为2分钟，Linux设置成了30s。\n以客户端向服务端断开连接为例：\n  客户端向服务端发送关闭连接请求\nClient-\u0026gt;Server FIN=1，seq=u\n第一次挥手后客户端不能再向服务端发送数据了。\n  服务端向客户端发送关闭连接确认\n此时服务端仍可向客户端发送数据，但客户端不能向服务端发送数据\nServer-\u0026gt;Client ACK=1，ack=u+1，seq=v\n  服务端向客户端发送关闭连接请求\nServer-\u0026gt;Client FIN=1，ACK=1，ack=u+1，seq=w\n  客户端向服务端发送关闭连接确认\nClient-\u0026gt;Server ACK=1，ack=w+1，seq=u+1\n  为什么需要四次挥手 原因和三次握手一样，TCP是全双工的，但不同于握手，2、3过程可能无法合并，因为服务端此时可能并未将所有数据发送给客户端。如果客户端向服务端发送关闭连接请求时服务端也正好要向客户端发送关闭连接请求，那么2、3是可能合并的，即四次挥手是可能变成三次挥手的。\nTCP为什么是可靠的？ TCP提供了对丢失，损坏，重复或接收顺序错误的Segment的恢复机制：\n TCP会将来自应用层的数据分解成多个Segment，通过用序列号标记每个Segment的顺序。每个Segment还附加一个CRC校验码，TCP服务端收到Segment后可以用过CRC校验码进行CRC校验Segment是否损坏，不匹配CRC校验的Segment将被丢弃。 TCP协议要求TCP服务端收到Segment后需要客户端返回ACK确认应答消息(并不绝对一个Segment对应一个ACK确认应答消息，)，如果TCP客户端在合理的往返时延（RTT）内未收到ACK确认应答消息，TCP客户端会重发这个Segment。  滑动窗口机制 发送方和接收方都会维护一个数据帧的序列，这个序列被成为窗口。\n发送方的窗口由接收方确定。接收方在“接收窗口”域指出还可接收的字节数量。发送方在没有新的确认包的情况下至多发送“接收窗口”允许的字节数量。\n滑动窗口的目的：\n确保数据不丢失，如果发送的数据丢失了可以重新发。\n控制发送速度，控制发送速度，以免接收方的缓存不够大导致溢出，同时控制流量也可以避免网络拥塞。\nUDP(User Datagram Protocol) 数据在UDP中分组称为Message。\nUDP是一种无连接的、不可靠的、面向报文、没有拥塞控制的通信协议。\n  无连接的：和TCP要建立连接不同，UDP传输数据不需要建立连接，就像写信，在信封写上收信人名称、地址就可以交给邮局发送了，至于能不能送到，就要看邮局的送信能力和送信过程的困难程度了。\n  不可靠的：因为UDP发出去的数据包发出去就不管了，不管它会不会到达，所以很可能会出现丢包现象，使传输的数据出错。\n  面向报文：数据报文，就相当于一个数据包，应用层交给UDP多大的数据包，UDP就照样发送，不会像TCP那样拆分。\n  没有拥塞控制：拥塞，是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象，就像交通堵塞一样。TCP建立连接后如果发送的数据因为信道质量的原因不能到达目的地，它会不断重发，有可能导致越来越塞，所以需要一个复杂的原理来控制拥塞。而UDP就没有这个烦恼，发出去就不管了。\n  应用场景 很多的实时应用（如IP电话、实时视频会议、某些多人同时在线游戏等）要求源主机以很定的速率发送数据，并且允许在网络发生拥塞时候丢失一些数据，但是要求不能有太大的延时，UDP就刚好适合这种要求。\n  UDP报文结构 UDP报文由报文首部和报文数据两部分组成。其中报文首部有八字节四部分组成：源端口(2字节)+目的端口(2字节)+长度(2字节)+校验和(2字节)。\n 源端口 源端口号，在需要对方回信时选用，不需要时可用全0。 目的端口 目的端口号，这在终点交付报文时必须要使用到。 长度 UDP用户数据包的长度，其最小值是8（仅有首部时）。 校验和 检测UDP用户数据报在传输中是否有错,有错就丢弃。  IP 数据在IP层称为Datagram，数据分组称为分片（Fragment）。\nIP协议定义了寻址方法和数据报的封装结构。\n参考：\n TCP/IP详解（中文版） TCP/IP模型及OSI七层参考模型各层的功能和主要协议 ISO/OSI网络体系结构和TCP/IP协议模型 MAC地址的意义及作用？（mac） 维基百科-传输控制协议 维基百科-互联网协议套件 TCP 3-Way Handshake (SYN,SYN-ACK,ACK) TCP Header  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-measurelayoutdraw/",
	"title": "自定义View-measure&amp;layout",
	"tags": ["自定义view", "android"],
	"categories": [],
	"series": ["自定义view"],
	"description": "measure&amp;layout&amp;draw",
	"content": "View\u0026amp;ViewGroup的自定义 measure/onMeasure  measure\n是View测量自己所需空间的方法，通常是调用onMeasure方法完成子控件的测量并最终确定自己的尺寸。measure方法一般无需也尽量不要重写。无论是View还是ViewGroup都可以重写onMeasure完成具体计算 onMeasure\n是父控件调用子控件测量自身的方法(通常是childView.measure())完成测量，并最终确定自己尺寸大小。并在测量完成后调用setMeasuredDimension()方法传入width/height，setMeasuredDimension()会将传入的width/height储存起来，在layout时用调用该view的getMeasuredWidth()获取测量尺寸进行布局，需要注意的是必须在onMeasure()中调用setMeasuredDimension()，因为View的measure()方法中会检测是否有PFLAG_MEASURED_DIMENSION_SET标志，若没有则会抛出异常，而PFLAG_MEASURED_DIMENSION_SET正是在被setMeasuredDimension()方法调用的setMeasuredDimensionRaw()方法中设置。另外需要明确的是setMeasuredDimension()是设置自己的大小，因此不是所有都需要先调用childView.measure()先确定子控件大小再调用setMeasuredDimension()，控件自身大小和子控件也没有强制关系，全看实现，一旦确定自身的大小就可调用setMeasuredDimension()。例如NestedScrollView自身的尺寸是有限的，但子控件的尺寸是无限的。\n无论是measure还是onMeasure，其两个参数int类型是MeasureSpec结构的，即：高2位是测量的Mode类型：EXACTLY/AT_MOST/UNSPECIFIED，低30位是尺寸大小值。可以通过MeasureSpec类方便获得。而onMeasure中调用的setMeasuredDimension()参数并不一定完全是尺寸值，可能包含MeasureState，MeasureState占这个int参数的高8位，剩余低24位才是真正的尺寸值。见其他API\nView中measure源码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  /** * \u0026lt;p\u0026gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * \u0026lt;/p\u0026gt; * * \u0026lt;p\u0026gt; * The actual measurement work of a view is performed in * {@link #onMeasure(int, int)}, called by this method. Therefore, only * {@link #onMeasure(int, int)} can and must be overridden by subclasses. * \u0026lt;/p\u0026gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) { //判断是否是视觉边界，做相应处理  boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } // Suppress sign extension for the low bytes  long key = (long) widthMeasureSpec \u0026lt;\u0026lt; 32 | (long) heightMeasureSpec \u0026amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); //是否是强制重新布局，当调用requestLayut()时会添加PFLAG_FORCE_LAYOUT标志  final boolean forceLayout = (mPrivateFlags \u0026amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // Optimize layout by avoiding an extra EXACTLY pass when the view is  // already measured as the correct size. In API 23 and below, this  // extra pass is required to make LinearLayout re-distribute weight.  final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY \u0026amp;\u0026amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) \u0026amp;\u0026amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); final boolean needsLayout = specChanged \u0026amp;\u0026amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); //如果是强制重新布局或者尺寸改变需要重新布局  if (forceLayout || needsLayout) { // first clears the measured dimension flag  mPrivateFlags \u0026amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex \u0026lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back  onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed  setMeasuredDimensionRaw((int) (value \u0026gt;\u0026gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise  // an exception to warn the developer  if ((mPrivateFlags \u0026amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(\u0026#34;View with id \u0026#34; + getId() + \u0026#34;: \u0026#34; + getClass().getName() + \u0026#34;#onMeasure() did not set the\u0026#34; + \u0026#34; measured dimension by calling\u0026#34; + \u0026#34; setMeasuredDimension()\u0026#34;); } //添加需要重新布局标志  mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; /将结果转成long类型，高32位是mMeasuredWidth，低32位是mMeasuredHeight。缓存合成的measure结果 mMeasureCache.put(key, ((long) mMeasuredWidth) \u0026lt;\u0026lt; 32 | (long) mMeasuredHeight \u0026amp; 0xffffffffL); // suppress sign extension }   layout/onLayout  layout\n是View确定自己位置的方法(通过调用setFrame)，并调用onLayout方法布局子控件。layout方法一般不需要重写。 onLayout\n是父控件确定子控件位置的方法，一般是在onLayout方法中调用子控件的layout方法来实现。如：childView.layout()。View中该方法是一个空方法。ViewGroup中重写为一个抽象方法。因此自定义继承自ViewGroup的控件需要重写该方法。而自定义继承View的控件因为不包含子控件，因此不需要重写该方法\nView中layout源码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 \u0026amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //是否是视觉边界布局，调用响应方法，setFrame返回边界是否改变  boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); //如果边界改变或者尺寸改变需要重新布局，调用onLayout让childView也重新布局  if (changed || (mPrivateFlags \u0026amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); ... mPrivateFlags \u0026amp;= ~PFLAG_LAYOUT_REQUIRED; ... } ... //清除强制布局标志  mPrivateFlags \u0026amp;= ~PFLAG_FORCE_LAYOUT; //添加布局完成标志  mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; ... }   draw/onDraw draw 图画前景/背景/Edges等，并调用onDraw图画自身内容以及调用dispatchDraw图画子控件,onDraw具体使用因为设计较多内容我会另开一篇\n为什么measure和layout分开 理想情况measure后知道了尺寸即可layout，但是measure的情况比较复杂，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;LinearLayout android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/orange_red\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView2\u0026#34; android:layout_width=\u0026#34;360dp\u0026#34; android:layout_height=\u0026#34;220dp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34;\u0026gt; \u0026lt;/LinearLayout\u0026gt;   LinearLayout需要经过两次测量才可以确定textView1的尺寸，因此需要将measure和layout分开处理，不然layout也要进行两次。因为LinearLayout是wrap_content，即内容多大本身尺寸就多大，而textView1是match_parent，即充满LinearLayout，这就造成了矛盾，此时LinearLayout的测量过程是：测量textView1，先将textView1的宽高测量为0，再测量textView2，宽：360，高：220，此时父控件宽：360dp，高：220。再次onMeasure方法测量，此时再将textView1宽度设置为360，高为0。\n见View:\n1 2 3 4 5 6 7  public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 \u0026amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } ... }   ViewGroup ViewGroup 中封装了getChildMeasureSpec/measureChildren/measureChild/measureChildWithMargins几个方法方便我们自定义控件时使用\n getChildMeasureSpec\n根据传入的parentMeasureSpec(即onMeasure的参数)确定子控件的childMeasureSpec。源码较长，但逻辑十分简单，这里就不贴了。 measureChild 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding. * The heavy lifting is done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param parentHeightMeasureSpec The height requirements for this view */ protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }    measureChildren 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this view * @param heightMeasureSpec The height requirements for this view */ protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i \u0026lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags \u0026amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } }    measureChildWithMargins 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this view * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */ protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }     在自定义view的measure时可以使用上面四个方法，大部分情况无需再自己写，如：FrameLayout，但还是看具体情况，如NestedScrollView这类滚动的View就重写了measureChild及measureChildWithMargins，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Override protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { ViewGroup.LayoutParams lp = child.getLayoutParams(); int childWidthMeasureSpec; int childHeightMeasureSpec; childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, getPaddingLeft() + getPaddingRight(), lp.width); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } @Override protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( lp.topMargin + lp.bottomMargin, MeasureSpec.UNSPECIFIED); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }   View中读取xml布局文件中View属性的源码：\n1 2 3 4 5  public void encode(@NonNull ViewHierarchyEncoder stream) { stream.beginObject(this); encodeProperties(stream); stream.endObject(); }   测量模式：EXACTLY/AT_MOST/UNSPECIFIED  EXACTLY 精确测量，子控件大小已经确定 AT_MOST 子控件需要多大就多大，但不超过MeasureSpec.getSize(measureSpec)，如父控件是MATCH_PARENT，子控件是WRAP_CONTENT，则子控件的测量模式是AT_MOST。由于顶级父控件是一个确定的屏幕尺寸，因此只要控件是WRAP_CONTENT，根据getChildMeasureSpec的实现只要它的父控件不是UNSPECIFIED则它的测量模式就是AT_MOST UNSPECIFIED 不加任何限制，子控件要多大就多大，通常是Scrollview高度的测量模式  其他API   getMeasuredState\n将宽度的MeasuredState和高度的MeasuredState合并成一个int类型，高16位是宽度的MeasuredState，低16位是高度的MeasuredState，但MeasuredState只占一个8位长度，所以其实只有高16位的低8位和低16位的低8位是有效值，其高8位都被0填充了\n1 2 3 4 5  public final int getMeasuredState() { return (mMeasuredWidth\u0026amp;MEASURED_STATE_MASK) | ((mMeasuredHeight\u0026gt;\u0026gt;MEASURED_HEIGHT_STATE_SHIFT) \u0026amp; (MEASURED_STATE_MASK\u0026gt;\u0026gt;MEASURED_HEIGHT_STATE_SHIFT)); }     getMeasuredWidthAndState()\n可以看出getMeasuredWidthAndState就是返回mMeasuredWidth值，而我们平时常用的getMeasuredWidth返回的是mMeasuredWidth的低24位，即去除MeasuredState的尺寸值。目前View的MeasuredState似乎只有一个值：MEASURED_STATE_TOO_SMALL\n1 2 3 4 5 6  public final int getMeasuredWidthAndState() { return mMeasuredWidth; } public final int getMeasuredWidth() { return mMeasuredWidth \u0026amp; MEASURED_SIZE_MASK; }     getMeasuredHeightAndState()\n类似getMeasuredWidthAndState()\n  resolveSize\u0026amp;resolveSizeAndState()\nSDK自带的计算尺寸的方法，resolveSizeAndState()是获取带MeasureState的尺寸，resolveSize调用resolveSizeAndState但去除了MeasureState部分保留的是真正的尺寸。setMeasuredDimension()究竟应该传递这两个哪个方法计算的结果？答案：都可以。看你需要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public static int resolveSize(int size, int measureSpec) { return resolveSizeAndState(size, measureSpec, 0) \u0026amp; MEASURED_SIZE_MASK; } public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) { final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) { case MeasureSpec.AT_MOST: if (specSize \u0026lt; size) { result = specSize | MEASURED_STATE_TOO_SMALL; } else { result = size; } break; case MeasureSpec.EXACTLY: result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; } return result | (childMeasuredState \u0026amp; MEASURED_STATE_MASK); }     getMeasureWidth和getWidth  getMeasureWidth\n从源码可以看出getMeasureWidth是mMeasuredWidth的尺寸值部分，而mMeasuredWidth是onMeasure中调用setMeasuredDimension()设置的 1 2 3  public final int getMeasuredWidth() { return mMeasuredWidth \u0026amp; MEASURED_SIZE_MASK; }    getWidth 1 2 3  public final int getWidth() { return mRight - mLeft; }   \n从源码看出getWidth()是边界计算而来，而设置边界是layout方法中调用的setFrame设置的，设置的值是layout方法的参数，而我们自定义View时在在onLayout方法中调用child.layout()传递而来的。而最初的这个值是由谁传递来的呢？说来话长：当我们启动activity时会执行到ActivityThread.handleResumeActivity，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  @Override public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,String reason) { ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); if (r == null) { // We didn\u0026#39;t actually resume the activity, so skipping any follow-up actions.  return; } ... final Activity a = r.activity; ... if (r.window == null \u0026amp;\u0026amp; !a.mFinished \u0026amp;\u0026amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity  // in addView-\u0026gt;ViewRootImpl#setView. If we are instead reusing  // the decor view we have to notify the view root that the  // callbacks may have changed.  ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; wm.addView(decor, l); } else { // The activity will get a callback for this {@link LayoutParams} change  // earlier. However, at that time the decor will not be set (this is set  // in this method), so no action will be taken. This call ensures the  // callback occurs with the decor set.  a.onWindowAttributesChanged(l); } } // If the window has already been added, but during resume  // we started another activity, then don\u0026#39;t yet make the  // window visible.  }else if (!willBeVisible) { if (localLOGV) Slog.v(TAG, \u0026#34;Launch \u0026#34; + r + \u0026#34; mStartedActivity set\u0026#34;); r.hideForNow = true; } }   这其中的impl.notifyChildRebuilt();最终会调用ViewRootImpl自己的performLayout。另外wm.addView(decor, l);也会会如下依次调用WindowManagerGlobal.addView()-\u0026gt;ViewRootImpl.setView()-\u0026gt;ViewRootImpl.requestLayout()-\u0026gt;\u0026hellip;-\u0026gt;ViewRootImpl.performLayout()\n1 2 3 4 5 6 7  private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { ... //这里的host是ViewRootImpl.setView()时传递过来的DecorView，最终实现从的DecorView开始一级一级传递。  host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ... }   由此可以看出getWith()最初是和getMeasuredWidth()有关系的，正常情况两者是一致的。但不是绝对的，你非要让其不一样也是可以的。\n  总结：由于setFrame设置的是控件显示的范围，setMeasuredDimension()设置的是控件测量出来自身需要的尺寸的值。所以with/height代表的是最终控件显示的范围，measuredWidth/measuredheight代表的是理想的测量值\n参考：\n Android 4.3中的视觉边界布局(Optical bounds layout)  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-pulllayout/",
	"title": "自定义View-PullLayout",
	"tags": ["android", "自定义view"],
	"categories": [],
	"series": ["自定义view"],
	"description": "自定义高可用，易扩展下拉刷新上拉加载空间",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
	"title": "设计模式",
	"tags": ["java"],
	"categories": [],
	"series": [],
	"description": "部分设计模式",
	"content": "设计模式是解决问题的思想，是前辈总结的成熟的设计方案。\n设计的总原则是：低耦合、高内聚，实现可复用，易维护。\n设计模式原则   开闭原则\n对扩展开放，对修改关闭。尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化\n  单一职责原则\n一个类只负责一项职责或者说有且仅有一个原因引起类的变更。单一职责原则提出了一个编程标准，用职责和变化原因衡量接口和类的设计是否优良，但职责和变化原因是不可度量的应因情况而定。\n比如一个用户类只负责用户相关的功能\n好处：类复杂度降低，可读性、维护性、可扩展性提高，降低变更带来的风险。\n  依赖倒置原则\n既面向接口编程，这样通过抽象(接口或抽象类)使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。\n比如Java中每个Service都有一个接口类和实现类，接口一般不会改变，但实现类可能会不断有微小的变化，这样我们都以接口返回给调用者\n  里氏替换原则\n子类可以扩展父类的功能但不要修改父类的功能。这样在父类出现的地方，子类可以完全替换。这可以增强程序的健壮性，即使增加子类原有子类依然可以继续运行。如果子类不能完整实现父类或者父类的某些地方在子类中发生了畸变不能完全替换父类建议断开继承关系使用依赖、组合、聚合等关系替代。\n  接口隔离原则\n设计接口尽量细粒度，最小功能单元，但注意限度，如果过小，则会造成接口数量过多，使设计复杂化。\n  迪米特法则\n降低耦合(局部变量中不要引入新的类)，一个类对自己依赖的类知道的越少越好。\n  设计模式分配 Java中设计模式有三大类：\n 创建型\n工厂模式主要是将对象的创建和对对象使用分开实现解耦。  单例模式 静态工厂模式 将多有对象的创建集中到一个工厂类管理 工厂方法模式 一个工厂只负责一个类的对象创建 抽象工厂模式 将一个系列的类的对象创建合并 建造者模式   结构型  组合模式 当可以使用继承和组合来实现一个功能时优先使用组合 代理模式 适配器模式 桥接模式 装饰模式 外观模式/门面模式   行为型  观察者模式 访问者模式 责任链模式 模版方法模式 策略模式 明亮模式    使用场景及简单使用   简单工厂模式\n 把对象的创建和使用分开 把生产过程集中便于管理 当对象有变化时使用者不需要改变代码\n示例：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class Apple implements Fruit { } class Orange implements Fruit { } class Banana implements Fruit { } class FruitFactory { //方式一  public static final int FRUIT_APPLE = 0; public static final int FRUIT_ORANGE = 1; public static final int FRUIT_BANANA = 2; public static Fruit getFruit(int fruit) { if (fruit == FRUIT_APPLE) { return new Apple(); } else if (fruit == FRUIT_ORANGE) { return new Orange(); } else if (fruit == FRUIT_BANANA) { return new Banana(); } return null; } //工厂也可以修改成多方法形式  //方式二  public static Apple getApple() { return new Apple(); } public static Orange getOrange() { return new Orange(); } public static Banana getBanana() { return new Banana(); } }     工厂方法模式\n简单工厂模式不符合单一职责原则，而且每次增加新的对象都要修改原有代码，可以修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  interface FruitFactory { Fruit getFruit(int fruit); } class AppleFactory implements FruitFactory { @Override public Fruit getFruit(int fruit) { return new Apple(); } } class OrangeFactory implements FruitFactory { @Override public Fruit getFruit(int fruit) { return new Orange(); } } class BananaFactory implements FruitFactory { @Override public Fruit getFruit(int fruit) { return new Banana(); } }     抽象工厂\n如果一个果园销售水果既要采摘水果又要打包，那么既有多个水果工厂又有多个打包工厂，这样采摘和打包工厂很大可能会出错，我们可以把一类水果的采摘和打包放在一个抽象工厂类。\n  建造这模式\n建造者模式适合复杂多变的对象，不同的模版构建过程产生不同的对象有不同的行为。\n  单例模式\n饿汉式\n懒汉式\n  适配器模式\n将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。\n适配器是将原有的对象因为某个需求适配使用，当大量使用适配时可以说是一种设计失误。适配器应该恰当使用或者作为一种对原有代码的补救。\n  桥接模式\n当对象有多个扩展纬度时将多个扩展纬度对象作为构成当前对象的成员变量\n  装饰模式\n装饰器模式装饰器可以多次装饰，附加多个功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  public interface Bag { void pack(); } public class AppleBag implements Bag { @Override public void pack() { System.out.print(\u0026#34;--苹果使用纸箱包装\u0026#34;); } } public class BagDecorator implements Bag { private Bag bag; //维持一个对抽象构件对象的引用  public BagDecorator(Bag bag) //注入一个抽象构件类型的对象  { this.bag = bag; } public void pack() { bag.pack(); } } public class CheckedBagDecorator extends BagDecorator { public CheckedBagDecorator(Bag bag) { super(bag); } public void pack() { super.pack(); //调用原有业务方法  checked(); //打印防伪标识  } //增加防伪标识  public void checked() { System.out.println(\u0026#34;------\u0026#34;); System.out.println(\u0026#34;打印上防伪标识\u0026#34;); } }     代理模式\n代理模式即是给目标对象提供一个代理对象，由代理对象控制对目标对象的引用。\n引入代理对象的目的：\n 通过代理对象间接访问目标对象，防止直接访问目标对象带来的不必要的复杂性 通过代理对象对原有的业务增强    组合模式\n组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。它创建了对象组的树形结构。\n使用场景：比如行政区划全国-\u0026gt;省-\u0026gt;市-\u0026gt;区-\u0026gt;乡-\u0026gt;村 这样的树形数据。\n  外观模式\n使用场景：当访问是一个比较复杂的流程过程，将流程封装成一个接口供外部使用\n比如有采摘/打包/发送三个服务，客户端需要分别调用三个服务，而且三个服务中可能还有其他和客户端不相关的功能也暴漏了。这时候可以使用外观模式：新建一个外观类：Facable，客户端只需要调用Facable，而Facable调用采摘/打包/发送三个服务，并屏蔽不相关的功能\n  模版方法模式\n在父类编写模版接口方法，延后到子类实现\n  策略模式\n通过选择不同策略类执行不同算法分支，核心是通过注入对象改变行为。优点类似IOC\n比如优惠券设计有：信任优惠券、满减优惠券、二次购优惠券，当结算时选择不同优惠券策略类执行不同的满减算法。\n  责任链模式\n比如不同的几类优惠券可以叠加使用，可以给优惠券设计链式结构：加上next的优惠券对象，当前优惠券计算完毕直接调用next继续。\n现实中比如客户点菜，客户通知服务员，服务员通知厨师，厨师做好菜服务员端菜递送到客户。\n编程中常用到的如过滤器、拦截器\n  观察者模式\n  命令模式\n通过增加Command抽象命令类将不符合抽象编程的Handle调用转为抽象编程\n  访问者模式\n利用双重分派机制弥补Java中多态中的方法重载是静态化的不足\n  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/",
	"title": "贝塞尔曲线(Bezier curve)",
	"tags": ["编程基础", "android"],
	"categories": [],
	"series": [],
	"description": "贝塞尔曲线详解",
	"content": "前置知识 Bezier曲线是用一系列点控制曲线状态的，主要分为：\n 数据点 确定曲线的起始和结束位置 控制点 确定曲线的弯曲程度  其中数据点又叫锚点，只有起始和结束两个点，控制点有0～n个，按控制点个数可分为一阶贝塞尔曲线，二阶贝塞尔曲线，三阶贝塞尔曲线，\u0026hellip;，N阶贝塞尔曲线\n一阶贝塞尔曲线 0个控制点 即为一条直线\n给定点P0，P1，其中初始点P0，结束点P1，t为比率，在P0，P1上取一点D，D即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=t $$\n一阶比较简单我们作为例子演算出公式，上面的表达式可改写为：\n$$ \\frac{D-P_0}{P_1-P_0}=t $$\n再进一步演算为：\n$$ D=t*({P_1-P_0})+P_0 $$\nD记为B(t)，推出公式：\n$$ B(t)=(1-t)P_0+tP_1,t{\\in}[0,1] $$\n二阶贝塞尔曲线(quadratic Bezier curve) 1个控制点\n给定点P0，P1，P2，其中初始点P0，结束点P2，控制点P1，t为比率，在P0P1上取一点D，P1P2取一点E，在DE上取一点F，F即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=\\frac{P_1E}{P_1P_2}=\\frac{DF}{DE}=t $$\n推出公式：\n$$ B(t)=(1-t)^2P_0+2t(1-t)P_1+t^2P_2,t{\\in}[0,1] $$\n三阶贝塞尔曲线(cubic Bezier curve) 2个控制点\n给定点P0，P1，P2，P3，其中初始点P0，结束点P3，控制点P1，P2，t为比率，在P0P1上取一点D，P1P2取一点E，P2P3取一点F，在DE上取一点G，在EF上取一点H，在GH上取一点I，I即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=\\frac{P_1E}{P_1P_2}=\\frac{P_2F}{P_2P_3}=\\frac{DG}{DE}=\\frac{EH}{EF}=\\frac{GI}{GH}=t $$\n推出公式：\n$$ B(t)=(1-t)^3P_0+3P_1t(1-t)^2+3P_2t^2(1-t)+P_3t^3,t{\\in}[0,1] $$\n多阶贝塞尔曲线 \u0026hellip;\n贝塞尔曲线的意义 确定初始点和结束点，很容易利用控制点得到一条曲线，控制简单。因此贝塞尔曲线在Android动画中有很多应用,比如Android中的PathInterpolator,PathInterpolator初始点是(0,0)，结束点是(1,1)，构造方法中传入控制点\n参考：\n cubic-bezier  "
},
{
	"uri": "https://dshcao.github.io/zh/series/%E9%9F%B3%E8%A7%86%E9%A2%91/",
	"title": "音视频",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/",
	"title": "音视频",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/",
	"title": "音视频",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/about/",
	"title": "关于",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Hugo, dshcao about",
	"content": "  GitHub.\n  掘金.\n  微博.\n  "
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E9%9A%8F%E7%AC%94/",
	"title": "随笔",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E9%9A%8F%E7%AC%94/",
	"title": "随笔",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/",
	"title": "随笔",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Note page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/android/%E9%9A%8F%E8%AE%B0/",
	"title": "随记",
	"tags": ["随笔"],
	"categories": [],
	"series": [""],
	"description": "小知识点",
	"content": "一、Manifest配置 allowBackup fullBackupContent https://developer.android.com/guide/topics/data/autobackup\nallowBackup配置用来开启停用自动备份\nfullBackupContent用来配置配分规则，如：android:fullBackupContent=\u0026rdquo;@xml/backup_rules\u0026rdquo;\n1 2 3 4 5 6 7 8 9  \u0026lt;!--backup_rules --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;full-backup-content\u0026gt; \u0026lt;include domain=[\u0026#34;file\u0026#34; | \u0026#34;database\u0026#34; | \u0026#34;sharedpref\u0026#34; |\u0026#34;external\u0026#34; | \u0026#34;root\u0026#34;] path=\u0026#34;string\u0026#34; requiredFlags=[\u0026#34;clientSideEncryption\u0026#34; | \u0026#34;deviceToDeviceTransfer\u0026#34;] /\u0026gt; \u0026lt;exclude domain=[\u0026#34;file\u0026#34; | \u0026#34;database\u0026#34; | \u0026#34;sharedpref\u0026#34; |\u0026#34;external\u0026#34; | \u0026#34;root\u0026#34;] path=\u0026#34;string\u0026#34; /\u0026gt; \u0026lt;/full-backup-content\u0026gt;   另外还可实现BackupAgent应用于你的备份逻辑\n如何保证序列化和反序列化仍然是同一个对象？比如单例模式从而实现线程安全\nprotected Object readResolve() throws ObjectStreamException {\nreturn mInstance;\n}\n原因，看ObjectInputStream注释文档\ncustomized: any class-specific readObject, readObjectNoData, and readResolve methods defined by enum types are ignored during deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored--all enum types have a fixed serialVersionUID of 0L. ObjectInputStream反序列化源码检测是否定义了readResolve()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  if (obj != null \u0026amp;\u0026amp; handles.lookupException(passHandle) == null \u0026amp;\u0026amp; desc.hasReadResolveMethod()){ Object rep = desc.invokeReadResolve(obj); if (unshared \u0026amp;\u0026amp; rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Android-removed: ObjectInputFilter logic, to be reconsidered. http://b/110252929  /* // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } */ handles.setObject(passHandle, obj = rep); } }   suppressLayout suppressLayout(true)会将mSuppressLayout标志置为true时所有触发layout()操作不会执行真正的layout()，而是在layout()中将mLayoutCalledWhileSuppressed标志置为true，直到suppressLayout(false)重置mSuppressLayout标志时会触发执行一次requestLayout()，并将mLayoutCalledWhileSuppressed置为false\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * Tells this ViewGroup to suppress all layout() calls until layout * suppression is disabled with a later call to suppressLayout(false). * When layout suppression is disabled, a requestLayout() call is sent * if layout() was attempted while layout was being suppressed. */ public void suppressLayout(boolean suppress) { mSuppressLayout = suppress; if (!suppress) { if (mLayoutCalledWhileSuppressed) { requestLayout(); mLayoutCalledWhileSuppressed = false; } } }   getLocationOnScreen clipBounds finishActivity public void finishActivity(int requestCode)\nandroid:windowIsTranslucent=true 适配 Activity android:persistableMode=\u0026quot;persistAcrossReboots\u0026rdquo; PersistableBundle\nUniversal Android Music Player Sample\nhttps://github.com/android/uamp.git\nStackView的循环实现 优秀博客 https://blog.csdn.net/aigestudio?t=1\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/blogging/",
	"title": "Blogging",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/ctest/",
	"title": "cTest",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/development/",
	"title": "Development",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/fast/",
	"title": "fast",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/go/",
	"title": "Go",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/go-web-dev/",
	"title": "Go Web Dev",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-1/",
	"title": "Note-1",
	"tags": ["Development", "Go", "fast", "Blogging"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
	"content": "post-1 content\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec. Quisque metus tellus, tincidunt eu consequat consequat, placerat sed ante. Cras pulvinar eros ex, vel luctus eros viverra sed. Donec nec quam aliquam, ultricies neque sed, sollicitudin lorem. Aenean faucibus, velit et facilisis semper, leo tellus pellentesque orci, non suscipit libero ipsum sed lacus. Fusce pharetra arcu sed tellus convallis, vel hendrerit turpis rhoncus.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-2/",
	"title": "Note-2",
	"tags": ["Go", "fast", "Blogging"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis,",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-3/",
	"title": "Note-3",
	"tags": ["Development", "Go", "fast"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis,",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-1-1/go-1/",
	"title": "Go 1",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 1 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-2/",
	"title": "Go 2",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 2 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-4/",
	"title": "Go 4",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 4 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-1-1/go-1-1-1/go-5/",
	"title": "Go 5",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 5 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/",
	"title": "Java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Note Sub List",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
}]