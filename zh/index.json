[
{
	"uri": "https://dshcao.github.io/zh/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-okhttp%E5%88%86%E6%9E%90/",
	"title": "Android-OkHttp分析",
	"tags": ["android", "retrofit"],
	"categories": [],
	"series": [],
	"description": "OkHttp分析",
	"content": "前言 源码分析部分基于 OkHttp4.7.2。\nSpdy 一种开放的网络传输协议，由Google开发的基于传输控制协议（TCP）的应用层协议。HTTP/2可以说是吸收Spdy演变来的。HTTP/2的主要功能压缩、多路复用和优先级等都来自Spdy。Google已淘汰SPDY，全面支持HTTP/2。\nOkHttp：\n 支持Http1.X、Http2、Quic以及WebSocket 支持连接池，减少了请求延迟 默认通过Gzip压缩数据(告诉服务端可以使用Gzip压缩) 响应缓存，避免重复请求网络 请求失败自动重试主机的其他ip，自动重定向  高并发请求分发器与线程池\n责任链模式请求与响应拦截器\nOkHttp调用流程 分发器(Dispatcher) RealCall\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class RealCall( val client: OkHttpClient, val originalRequest: Request, val forWebSocket: Boolean ) : Call { //同步  override fun execute(): Response { synchronized(this) { check(!executed) { \u0026#34;Already Executed\u0026#34; } executed = true } timeout.enter() callStart() try { //将RealCall加入到Dispatcher的runningSyncCalls队列  client.dispatcher.executed(this) return getResponseWithInterceptorChain() } finally { client.dispatcher.finished(this) } } //异步  override fun enqueue(responseCallback: Callback) { synchronized(this) { check(!executed) { \u0026#34;Already Executed\u0026#34; } executed = true } callStart() //将AsyncCall(AsyncCall是RealCall的内部类，持有外部类RealCall)加入到Dispatcher的readyAsyncCalls队列  client.dispatcher.enqueue(AsyncCall(responseCallback)) } }   Dispatcher\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75  class Dispatcher constructor() { //线程池  private var executorServiceOrNull: ExecutorService? = null @get:Synchronized @get:JvmName(\u0026#34;executorService\u0026#34;) val executorService: ExecutorService get() { if (executorServiceOrNull == null) { executorServiceOrNull = ThreadPoolExecutor(0, Int.MAX_VALUE, 60, TimeUnit.SECONDS, SynchronousQueue(), threadFactory(\u0026#34;$okHttpName Dispatcher\u0026#34;, false)) } return executorServiceOrNull!! } //异步请求等待队列  private val readyAsyncCalls = ArrayDeque\u0026lt;AsyncCall\u0026gt;() //正在执行的异步请求队列  private val runningAsyncCalls = ArrayDeque\u0026lt;AsyncCall\u0026gt;() //同步请求队列  private val runningSyncCalls = ArrayDeque\u0026lt;RealCall\u0026gt;() //同步执行的请求直接加入运行队列  @Synchronized internal fun executed(call: RealCall) { runningSyncCalls.add(call) } internal fun enqueue(call: AsyncCall) { synchronized(this) { //异步请求先加入readyAsyncCalls异步请求等待队列  readyAsyncCalls.add(call) //同一主机的调用数量的控制  if (!call.call.forWebSocket) { val existingCall = findExistingCallWithHost(call.host) if (existingCall != null) call.reuseCallsPerHostFrom(existingCall) } } promoteAndExecute() } } private fun promoteAndExecute(): Boolean { this.assertThreadDoesntHoldLock() val executableCalls = mutableListOf\u0026lt;AsyncCall\u0026gt;() val isRunning: Boolean synchronized(this) { val i = readyAsyncCalls.iterator() while (i.hasNext()) { val asyncCall = i.next() //是否超过最大异步请求数(默认64)  if (runningAsyncCalls.size \u0026gt;= this.maxRequests) break // Max capacity.  //是否超过单个服务器最大异步请求数(默认5)  if (asyncCall.callsPerHost.get() \u0026gt;= this.maxRequestsPerHost) continue // Host max capacity.  //如果满足以上条件，将请求从异步等待队列移除  i.remove() asyncCall.callsPerHost.incrementAndGet() //线程池执行这个异步请求任务  executableCalls.add(asyncCall) 加入到正在执行的异步执行队列 runningAsyncCalls.add(asyncCall) } isRunning = runningCallsCount() \u0026gt; 0 } for (i in 0 until executableCalls.size) { val asyncCall = executableCalls[i] asyncCall.executeOn(executorService) } return isRunning }   通过上面源码可以看出分发器内部维护了一个线程池和三个队列。三个队列分别是：\nreadyAsyncCalls 异步请求等待队列，当Call(RealCall)调用enqueue时，OkhttpClient会调用Dispatcher将异步请求任务AsyncCall(RealCall中继承Runnable接口的内部类)放置到异步请求等待队列中，然后检测一些列条件(正在执行的异步请求是否超过最大允许请求数，对同一个服务器主机的请求是否超过最大允许请求数)，如果符合条件将这个异步请求从异步请求等待队列中移除，使用线程池执行这个异步请求同时将其放入到正在执行的异步请求队列中。当某一个异步请求任务执行完毕(finished(call: AsyncCall)方法中)继续调用promoteAndExecute方法检查是否有新的异步请求任务且满足条件立即执行。这样enqueue和某个异步请求任务执行完毕两个地方的双重检测实现异步任务的及时执行。\nrunningAsyncCalls 正在执行的异步请求队列。\nrunningSyncCalls 正在执行同步请求队列，当Call(RealCall)调用execute时，OkhttpClient会调用Dispatcher将同步请求(RealCall)加入到正在执行同步请求队列并立即开始执行。所以同步请求都是立即执行没有等待队列的。\nexecutorServiceOrNull 默认线程池，源码中我们可以看出默认线程池的设置corePoolSize是0，maximumPoolSize是Int.MAX_VALUE。你可能很奇怪corePoolSize是0不就是不缓存线程吗？既然使用了线程池又不缓存线程，这和我们常规使用线程池的方式不太一样。还有另一个不同的是默认线程池executorServiceOrNull使用的是SynchronousQueue，也不是我们通常使用线程是使用的LinkedBlockingDeque、ArrayBlockingQueue。这设计到线程池执行的流程及SynchronousQueue和LinkedBlockingDeque、ArrayBlockingQueue的区别。总的来说orePoolSize设为0是为了在一段时间内不网络请求时不必浪费资源，另外配合SynchronousQueue实现网络请求的及时最大化的并发量。详细参考另一篇Java线程池详解\n如果你有自己个性化的请求分发需求可以在OkHttpClient.Builder中设置自己的Dispacher替换默认实现。\n拦截器(Interceptor) 拦截器可以说是OkHttp中最重要的部分了。OkHttp就是由五大默认拦截器来完成整个请求过程的。\n同步或异步请求最终都会执行RealCall的getResponseWithInterceptorChain执行真正的网络请求过程。\nRealCall#getResponseWithInterceptorChain\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  @Throws(IOException::class) internal fun getResponseWithInterceptorChain(): Response { // Build a full stack of interceptors.  val interceptors = mutableListOf\u0026lt;Interceptor\u0026gt;() interceptors += client.interceptors interceptors += RetryAndFollowUpInterceptor(client) interceptors += BridgeInterceptor(client.cookieJar) interceptors += CacheInterceptor(client.cache) interceptors += ConnectInterceptor if (!forWebSocket) { interceptors += client.networkInterceptors } interceptors += CallServerInterceptor(forWebSocket) val chain = RealInterceptorChain( call = this, interceptors = interceptors, index = 0, exchange = null, request = originalRequest, connectTimeoutMillis = client.connectTimeoutMillis, readTimeoutMillis = client.readTimeoutMillis, writeTimeoutMillis = client.writeTimeoutMillis ) var calledNoMoreExchanges = false try { val response = chain.proceed(originalRequest) if (isCanceled()) { response.closeQuietly() throw IOException(\u0026#34;Canceled\u0026#34;) } return response } catch (e: IOException) { calledNoMoreExchanges = true throw noMoreExchanges(e) as Throwable } finally { if (!calledNoMoreExchanges) { noMoreExchanges(null) } } }   上面源码可以看出interceptors和networkInterceptors的主要区别是执行时机不行。\n五大默认拦截器及用户拦截器 拦截器接口内部又一个Chain接口，Chain有一个实现类RealInterceptorChain，每个网络请求都会实例化一个自己的RealInterceptorChain对象，RealInterceptorChain内部有一个拦截器List集合存放了本地网络请求的所有拦截器对象，请求过程中RealInterceptorChain负责以责任链的模式依次调用拦截器。\n默认拦截器 RetryAndFollowUpInterceptor 重试重定向拦截器\n比如一个域名绑定多个IP的情况，请求会先DNS解析获得多个IP，在Socket连接到某一个IP，当某一个IP上的请求失败了，重试拦截器会帮我们自动切换到其他IP继续请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84  class RetryAndFollowUpInterceptor(private val client: OkHttpClient) : Interceptor { @Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response { val realChain = chain as RealInterceptorChain var request = chain.request val call = realChain.call var followUpCount = 0 var priorResponse: Response? = null var newExchangeFinder = true var recoveredFailures = listOf\u0026lt;IOException\u0026gt;() while (true) { call.enterNetworkInterceptorExchange(request, newExchangeFinder) var response: Response var closeActiveExchange = true try { if (call.isCanceled()) { throw IOException(\u0026#34;Canceled\u0026#34;) } try { response = realChain.proceed(request) newExchangeFinder = true } catch (e: RouteException) { // The attempt to connect via a route failed. The request will not have been sent.  if (!recover(e.lastConnectException, call, request, requestSendStarted = false)) { throw e.firstConnectException.withSuppressed(recoveredFailures) } else { recoveredFailures += e.firstConnectException } newExchangeFinder = false continue } catch (e: IOException) { //ConnectionShutdownException是HTTP/2的异常，只有在HTTP/2时才可能发生ConnectionShutdownException异常  if (!recover(e, call, request, requestSendStarted = e !is ConnectionShutdownException)) { throw e.withSuppressed(recoveredFailures) } else { recoveredFailures += e } newExchangeFinder = false continue } // Attach the prior response if it exists. Such responses never have a body.  if (priorResponse != null) { response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build() } //重定向  val exchange = call.interceptorScopedExchange val followUp = followUpRequest(response, exchange) if (followUp == null) { if (exchange != null \u0026amp;\u0026amp; exchange.isDuplex) { call.timeoutEarlyExit() } closeActiveExchange = false return response } val followUpBody = followUp.body if (followUpBody != null \u0026amp;\u0026amp; followUpBody.isOneShot()) { closeActiveExchange = false return response } response.body?.closeQuietly() if (++followUpCount \u0026gt; MAX_FOLLOW_UPS) { throw ProtocolException(\u0026#34;Too many follow-up requests: $followUpCount\u0026#34;) } request = followUp priorResponse = response } finally { call.exitNetworkInterceptorExchange(closeActiveExchange) } } } }   由重试重定向拦截器源码请求是在一个while死循环中，这可以很方便的重试重定向。可以看出当遇到路由异常(RouteException)和IO异常(IOException)时才会被catch住执行可能的重试和重定向，其他异常重试重定向拦截器是是不管的。而且路由异常和IO异常也不是都会重试的。recover方法返回true时才能重试重定向。\n另外注意：\n1 2 3  if (call.isCanceled()) { throw IOException(\u0026#34;Canceled\u0026#34;) }   可以看到取消请求的操作是在重试重定向拦截器操作的，所以如果经过了RetryAndFollowUpInterceptor之后取消网络请求，网络请求仍然是会执行的，只是用户不会再收到请求返回的结果。补充：实际上在ConnectInterceptor中查找连接时调用的ExchangeFinder#findConnection中也会有同样的判断call是否取消，这里应该时最后的机会了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  private fun recover( e: IOException, call: RealCall, userRequest: Request, requestSendStarted: Boolean ): Boolean { // The application layer has forbidden retries.  if (!client.retryOnConnectionFailure) return false // We can\u0026#39;t send the request body again.  if (requestSendStarted \u0026amp;\u0026amp; requestIsOneShot(e, userRequest)) return false // This exception is fatal.  if (!isRecoverable(e, requestSendStarted)) return false // No more routes to attempt.  if (!call.retryAfterFailure()) return false // For failure recovery, use the same route selector with a new connection.  return true }   recover方法也很简单，就四行四个判断：\n if (!client.retryOnConnectionFailure) return false判断OkHttpClient是否配置了允许重试，retryOnConnectionFailure默认是true，允许重试。 if (requestSendStarted \u0026amp;\u0026amp; requestIsOneShot(e, userRequest)) return false 当是HTTP/2请求不是路由异常和ConnectionShutdownException异常时requestSendStarted才为true  if (!isRecoverable(e, requestSendStarted)) return false 是否是可重试的异常。isRecoverable方法中判断了三种异常是不可重试的：ProtocolException(协议异常)、CertificateException(证书异常)、SSLPeerUnverifiedException(证书校验异常)，另外当是SocketTimeoutException(Socket超时异常)时明确重试。 if (!call.retryAfterFailure()) return false 是否有更多路由选择尝试，比如一个域名帮定了多个IP的服务器或配置了多个代理。当有更多路由选择时会执行到重定向方法followUpRequest。followUpRequest判断是否是407、401、300、301、302、303、307、308、408、503等，然后执行响应逻辑。重定向的次数最多是MAX_FOLLOW_UPS = 20次。  BridgeInterceptor 桥接拦截器，相当简单的一个拦截器，主要是为我们补全请求头，及获取响应后为我们做Cookie和Gzip处理，详细看代码注释。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  class BridgeInterceptor(private val cookieJar: CookieJar) : Interceptor { @Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response { val userRequest = chain.request() val requestBuilder = userRequest.newBuilder() val body = userRequest.body if (body != null) { val contentType = body.contentType() if (contentType != null) { //添加Content-Type请求头，告诉服务器请求体的类型。  requestBuilder.header(\u0026#34;Content-Type\u0026#34;, contentType.toString()) } val contentLength = body.contentLength() //请求体解析方式，详见参考[MDN web docs-Transfer-Encoding]  if (contentLength != -1L) { requestBuilder.header(\u0026#34;Content-Length\u0026#34;, contentLength.toString()) requestBuilder.removeHeader(\u0026#34;Transfer-Encoding\u0026#34;) } else { requestBuilder.header(\u0026#34;Transfer-Encoding\u0026#34;, \u0026#34;chunked\u0026#34;) requestBuilder.removeHeader(\u0026#34;Content-Length\u0026#34;) } } //添加Host请求头  if (userRequest.header(\u0026#34;Host\u0026#34;) == null) { requestBuilder.header(\u0026#34;Host\u0026#34;, userRequest.url.toHostHeader()) } //添加Connection请求头，默认使用长连接  if (userRequest.header(\u0026#34;Connection\u0026#34;) == null) { requestBuilder.header(\u0026#34;Connection\u0026#34;, \u0026#34;Keep-Alive\u0026#34;) } // If we add an \u0026#34;Accept-Encoding: gzip\u0026#34; header field we\u0026#39;re responsible for also decompressing  // the transfer stream.  //设置响应体压缩格式  var transparentGzip = false if (userRequest.header(\u0026#34;Accept-Encoding\u0026#34;) == null \u0026amp;\u0026amp; userRequest.header(\u0026#34;Range\u0026#34;) == null) { transparentGzip = true requestBuilder.header(\u0026#34;Accept-Encoding\u0026#34;, \u0026#34;gzip\u0026#34;) } //读取Cookie添加到请求头  val cookies = cookieJar.loadForRequest(userRequest.url) if (cookies.isNotEmpty()) { requestBuilder.header(\u0026#34;Cookie\u0026#34;, cookieHeader(cookies)) } //添加User-Agent请求头  if (userRequest.header(\u0026#34;User-Agent\u0026#34;) == null) { requestBuilder.header(\u0026#34;User-Agent\u0026#34;, userAgent) } val networkResponse = chain.proceed(requestBuilder.build()) //获取响应后获取Cookie保存。  cookieJar.receiveHeaders(userRequest.url, networkResponse.headers) val responseBuilder = networkResponse.newBuilder() .request(userRequest) //判断是否使用了Gzip压缩，如果使用了Gzip自动完成解压缩。  if (transparentGzip \u0026amp;\u0026amp; \u0026#34;gzip\u0026#34;.equals(networkResponse.header(\u0026#34;Content-Encoding\u0026#34;), ignoreCase = true) \u0026amp;\u0026amp; networkResponse.promisesBody()) { val responseBody = networkResponse.body if (responseBody != null) { val gzipSource = GzipSource(responseBody.source()) val strippedHeaders = networkResponse.headers.newBuilder() .removeAll(\u0026#34;Content-Encoding\u0026#34;) .removeAll(\u0026#34;Content-Length\u0026#34;) .build() responseBuilder.headers(strippedHeaders) val contentType = networkResponse.header(\u0026#34;Content-Type\u0026#34;) responseBuilder.body(RealResponseBody(contentType, -1L, gzipSource.buffer())) } } return responseBuilder.build() } /** Returns a \u0026#39;Cookie\u0026#39; HTTP request header with all cookies, like `a=b; c=d`. */ private fun cookieHeader(cookies: List\u0026lt;Cookie\u0026gt;): String = buildString { cookies.forEachIndexed { index, cookie -\u0026gt; if (index \u0026gt; 0) append(\u0026#34;; \u0026#34;) append(cookie.name).append(\u0026#39;=\u0026#39;).append(cookie.value) } } }   CacheInterceptor 缓存拦截器\n缓存拦截器主要是对请求头响应头字段的判断，这里就不具体解释了，具体可以看HTTP头字段意义及OkHttp缓存拦截器的具体逻辑。\nConnectInterceptor 连接拦截器\n1 2 3 4 5 6 7 8 9  object ConnectInterceptor : Interceptor { @Throws(IOException::class) override fun intercept(chain: Interceptor.Chain): Response { val realChain = chain as RealInterceptorChain val exchange = realChain.call.initExchange(chain) val connectedChain = realChain.copy(exchange = exchange) return connectedChain.proceed(realChain.request) } }   连接拦截器的源码极少，只是实例化一个Exchange设置到RealInterceptorChain当中。再来看initExchange：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  internal fun initExchange(chain: RealInterceptorChain): Exchange { synchronized(connectionPool) { check(!noMoreExchanges) { \u0026#34;released\u0026#34; } check(exchange == null) } val codec = exchangeFinder!!.find(client, chain) val result = Exchange(this, eventListener, exchangeFinder!!, codec) this.interceptorScopedExchange = result synchronized(connectionPool) { this.exchange = result this.exchangeRequestDone = false this.exchangeResponseDone = false return result } } fun find( client: OkHttpClient, chain: RealInterceptorChain ): ExchangeCodec { try { val resultConnection = findHealthyConnection( connectTimeout = chain.connectTimeoutMillis, readTimeout = chain.readTimeoutMillis, writeTimeout = chain.writeTimeoutMillis, pingIntervalMillis = client.pingIntervalMillis, connectionRetryEnabled = client.retryOnConnectionFailure, doExtensiveHealthChecks = chain.request.method != \u0026#34;GET\u0026#34; ) return resultConnection.newCodec(client, chain) } catch (e: RouteException) { trackFailure(e.lastConnectException) throw e } catch (e: IOException) { trackFailure(e) throw RouteException(e) } }   首先通过exchangeFinder!!.find(client, chain)，find方法中调用findHealthyConnection从连接池查找或者新建一个健康可用的连接设置到RealCall中，并根据连接的不同返回用于请求和响应编码的ExchangeCodec(实际是Http1ExchangeCodec或Http2ExchangeCodec)返回。里面经过很多步骤和判断，这里代码就不贴上来了。连接是否健康主要时看RealConnection对象持有的socket是否close或超时等情况。RealConnection时连接池中的对象，该对象持有Socket及握手信息等。\n连接池的设计类似于连接池，有最大闲置连接数及最长保存时间。\nclass ConnectionPool internal constructor( internal val delegate: RealConnectionPool ) { constructor( maxIdleConnections: Int, keepAliveDuration: Long, timeUnit: TimeUnit ) : this(RealConnectionPool( taskRunner = TaskRunner.INSTANCE, maxIdleConnections = maxIdleConnections, keepAliveDuration = keepAliveDuration, timeUnit = timeUnit )) constructor() : this(5, 5, TimeUnit.MINUTES) } 可以看出默认最多保存5个处于空闲状态的连接，连接的默认保活时间为5分钟\nCallServerInterceptor 请求服务器拦截器\n请求服务器主要是对请求头中的Expect:100-continue的自动处理以及对响应204、205的处理。Expect:100-continue主要是在大容量请求体上传时对服务器询问是否接收大容量数据。204、205则是服务器处理了请求但没有响应体，OkHttp抛出ProtocolException异常。\nOkHttp具体是如何做连接的 Http的连接肯定要用到Socket，而连接池的对象RealConnection则保存了Socket对象，所谓的连接池实际上就是连接没有关闭的Socket对象。连接的具体逻辑就在RealConnection，代码就不贴了，有点常影响文章可读性。\n连接主要分三种：\n 无代理 Socket代理 HTTP代理 HTTP代理又分为：HTTP代理和HTTPS代理。  HTTP代理 HTTPS代理    参考：\n MDN web docs-Transfer-Encoding    "
},
{
	"uri": "https://dshcao.github.io/zh/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/retrofit/",
	"title": "retrofit",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/",
	"title": "文章",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Post page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-imagecropview/",
	"title": "自定义view-ImageCropView",
	"tags": ["android", "自定义view"],
	"categories": [],
	"series": ["自定义view"],
	"description": "一个文件实现自定义头像裁剪控件",
	"content": "项目中需要为用户截取头像，刚开始调用系统自带功能，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  Intent intent = new Intent(\u0026#34;com.android.camera.action.CROP\u0026#34;); intent.setDataAndType(Uri.fromFile(new File(itemData.getPath())), \u0026#34;image/*\u0026#34;); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); // crop=true是设置在开启的Intent中设置显示的VIEW可裁剪 intent.putExtra(\u0026#34;crop\u0026#34;, \u0026#34;true\u0026#34;); // aspectX aspectY 是宽高的比例 intent.putExtra(\u0026#34;aspectX\u0026#34;, 1); intent.putExtra(\u0026#34;aspectY\u0026#34;, 1); // outputX outputY 是裁剪图片宽高 intent.putExtra(\u0026#34;outputX\u0026#34;, 350); intent.putExtra(\u0026#34;outputY\u0026#34;, 350); intent.putExtra(\u0026#34;scale\u0026#34;, true); intent.putExtra(\u0026#34;noFaceDetection\u0026#34;, false);//取消人脸识别功能 intent.putExtra(\u0026#34;outputFormat\u0026#34;, Bitmap.CompressFormat.PNG.toString()); //true则图片在intent中返回，如果图片过大，会导致oom，这里设置为false intent.putExtra(\u0026#34;return-data\u0026#34;, false); File avatar = new File(getExternalFilesDir(Environment.DIRECTORY_PICTURES), AppConfig.Path.AVATAR); // FileProvider.getUriForFile(AvatarPickerActivity.this, getPackageName() + \u0026#34;.provider\u0026#34;, new File(itemData.getPath())); Uri outputUri = Uri.fromFile(avatar);//裁剪后输出位置 intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri); startActivityForResult(intent, REQUEST_CROP);   但使用过程中发现各手机ui不一致，更严重的是发现锤子手机有问题，锤子手机缩放图片后截取的图像仍是未缩放时的区域，然后就一顿搜索发现github上有不少这个项目，但效果不满意，且实现复杂，就这一个功能拆成N个文件。\n代码讲究 高内聚 低耦合 可重用\n最终目的方便维护\n首先分析如何实现：\n重写onDraw添加自己的逻辑代码，画一层蒙板，蒙板要覆盖整个imageview,周围是半透明，中间是方形或者圆形透明区域，可以用Path实现，还需要手势支持，所以还要用到GestureDetector ScaleGestureDetector，另外图片大小不一，第一次加载到imageview中肯定不是原尺寸，要经过缩放，那我们缩放到什么程度呢？因为我们截图不能使图像缩放小于中间透明区域，所以我们规定初次加载图像最短边缩放到中间透明区域，这里图片说明，这里还用到Matrix从来缩放图像,不太了解的可先看下文档谷歌一下\n首先为了使用方便自定义属性：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;declare-styleable name=\u0026#34;ImageCropView\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;aspectX\u0026#34; format=\u0026#34;integer\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;aspectY\u0026#34; format=\u0026#34;integer\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewStrokeColor\u0026#34; format=\u0026#34;color|reference\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewStrokeWidth\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewShape\u0026#34; format=\u0026#34;enum\u0026#34;\u0026gt; \u0026lt;enum name=\u0026#34;square\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;enum name=\u0026#34;circle\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/attr\u0026gt; \u0026lt;/declare-styleable\u0026gt;   自定义注解取代枚举\nViewShape\n1 2 3 4 5 6 7 8  @Retention(AnnotationRetention.SOURCE) @IntDef(SQUARE, CIRCLE) annotation class ViewShape(val value: Int = CIRCLE) { companion object { const val SQUARE = 1 const val CIRCLE = 1 shl 1 } }   ImageCropView\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117  class ImageCropView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : AppCompatImageView(context, attrs, defStyleAttr), ViewTreeObserver.OnGlobalLayoutListener, ScaleGestureDetector.OnScaleGestureListener { @ViewShape var viewShape = ViewShape.CIRCLE//透明区域形状  private var viewStrokeWidth: Float = 1f//透明区域Stroke宽度  private var viewStrokeColor: Int = Color.WHITE//透明区域Stroke颜色  private var viewMaskColor: Int = Color.parseColor(\u0026#34;#77000000\u0026#34;)//半透明区域颜色  var aspectX: Int = 1//宽高比  var aspectY: Int = 1//宽高比  private val touchSlop: Int var overViewOffset = RectF() private var overViewSpace: Int = 0//透明区域与控件边缘的space  private var imageSpace: Int = 0//  private val paint: Paint//半透明区域  private val paintS: Paint//stroke  private var gestureDetector: GestureDetector private var scaleGestureDetector: ScaleGestureDetector var mValues = FloatArray(9) var mMatrix = Matrix() var initScale: Float = 0f var minScale: Float = 0f var maxScale: Float = 0f var max = 6 var overViewPath = Path() var overView = RectF() init { if (attrs != null) { val a = context.obtainStyledAttributes(attrs, R.styleable.ImageCropView) viewStrokeWidth = a.getDimension(R.styleable.ImageCropView_viewStrokeWidth, viewStrokeWidth) viewStrokeColor = a.getColor(R.styleable.ImageCropView_viewStrokeColor, viewStrokeColor) viewMaskColor = a.getColor(R.styleable.ImageCropView_viewStrokeColor, viewMaskColor) aspectX = a.getInt(R.styleable.ImageCropView_aspectX, aspectX) aspectY = a.getInt(R.styleable.ImageCropView_aspectY, aspectY) viewShape = if (aspectX != aspectY) ViewShape.SQUARE else viewShape a.recycle() } touchSlop = ViewConfiguration.get(context).scaledTouchSlop setLayerType(View.LAYER_TYPE_SOFTWARE, null) scaleType = ScaleType.MATRIX paint = Paint(Paint.ANTI_ALIAS_FLAG) paint.color = viewMaskColor paintS = Paint(Paint.ANTI_ALIAS_FLAG) paintS.color = viewStrokeColor paintS.style = Paint.Style.STROKE paintS.strokeWidth = viewStrokeWidth if (overViewSpace == 0) overViewSpace = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 42f, resources.displayMetrics) .toInt() imageSpace = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1f, resources.displayMetrics) .toInt() val gestureListener: SimpleOnGestureListener = object :SimpleOnGestureListener() { override fun onDoubleTap(e: MotionEvent): Boolean { //双击时若当前缩放小于最大缩放的一半时就缩放到最大，反之回到到初始加载的缩放  val currScale: Float = getCurrentScale() val midScale: Float = maxScale / (max / 2f) if (currScale \u0026lt; midScale) { val rScale = midScale / currScale scale(rScale, rScale, e.x, e.y) } else { val rScale: Float = initScale / currScale scale(rScale, rScale, e.x, e.y) } return true } override fun onScroll( e1: MotionEvent, e2: MotionEvent, distanceX: Float, distanceY: Float ): Boolean { val dx: Float val dy: Float val matrixRectF: RectF = getMatrixRectF() //滑动时判断滑动的距离是否超出中间透明区域，取两者最小值，即最多只能滑动到透明区域边缘  if (distanceX \u0026lt; 0) { dx = distanceX.coerceAtLeast(matrixRectF.left - overViewOffset.left) } else { dx = distanceX.coerceAtMost(matrixRectF.right - overViewOffset.right) } if (distanceY \u0026lt; 0) { dy = distanceY.coerceAtLeast(matrixRectF.top - overViewOffset.top) } else { dy = distanceY.coerceAtMost(matrixRectF.bottom - overViewOffset.bottom) } translate(-dx, -dy) return true } } gestureDetector = GestureDetector(context, gestureListener) scaleGestureDetector = ScaleGestureDetector(context, this) } ....暂时省略 }   onGlobalLayout中确定初始值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  override fun onAttachedToWindow() { super.onAttachedToWindow() viewTreeObserver.addOnGlobalLayoutListener(this) } //onGlobalLayout作用是获取构造函数中获取不到的尺寸以便确定初始缩放大小 //最大最小缩放根据初始缩放决定 override fun onGlobalLayout() { val drawable = drawable ?: return val scale: Float val viewWidth = width val viewHeight = height val overViewSize: Int = Math.min(viewWidth, viewHeight) - overViewSpace * 2 val drawableWidth = drawable.intrinsicWidth val drawableHeight = drawable.intrinsicHeight //build overview path  overViewPath.addRect( 0f, 0f, viewWidth.toFloat(), viewHeight.toFloat(), Path.Direction.CCW ) val circlePath = Path() val radius = overViewSize / 2.toFloat() if (viewShape == ViewShape.CIRCLE) { circlePath.addCircle( viewWidth / 2.toFloat(), viewHeight / 2.toFloat(), radius, Path.Direction.CCW ) } else { circlePath.addRect( viewWidth / 2f - radius, viewHeight / 2f - radius, viewWidth / 2f + radius, viewHeight / 2f + radius, Path.Direction.CCW ) } overViewPath.op(circlePath, Path.Op.XOR) overView.set( viewWidth / 2f - radius, viewHeight / 2f - radius, viewWidth / 2f + radius, viewHeight / 2f + radius ) overViewOffset.set(overView) overViewOffset.inset(-imageSpace.toFloat(), -imageSpace.toFloat()) //calculate the scale  scale = (overViewSize + imageSpace * 2) * 1f / Math.min( drawableWidth, drawableHeight ) initScale = scale minScale = initScale maxScale = minScale * max //calculate the delta move to center  val dx = viewWidth / 2 - drawableWidth / 2 val dy = viewHeight / 2 - drawableHeight / 2 mMatrix.postTranslate(dx.toFloat(), dy.toFloat()) mMatrix.postScale(initScale, initScale, viewWidth / 2.toFloat(), viewHeight / 2.toFloat()) imageMatrix = mMatrix //初始测量一次就够了  viewTreeObserver.removeOnGlobalLayoutListener(this) }   onDraw\n1 2 3 4 5 6 7 8 9 10 11 12  override fun onDraw(canvas: Canvas?) { super.onDraw(canvas) //画蒙层  canvas!!.drawPath(overViewPath, paint) //画stroke  if (viewStrokeWidth \u0026gt; 0) { canvas.drawCircle( overView.centerX(), overView.centerY() , (overView.width() + viewStrokeWidth) / 2, paintS ) } }   缩放处理逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  override fun onScale(detector: ScaleGestureDetector?): Boolean { val currScale = getCurrentScale() var scaleFactor = detector!!.scaleFactor //主要是判断不能小于最小缩放值，不能大于最大缩放值  scaleFactor = if (scaleFactor \u0026lt; 1 \u0026amp;\u0026amp; currScale \u0026gt; minScale) { Math.max(scaleFactor, minScale / currScale) } else if (scaleFactor \u0026gt; 1 \u0026amp;\u0026amp; currScale \u0026lt; maxScale) { Math.min(scaleFactor, maxScale / currScale) } else { 1f } if (scaleFactor != 1f) { scale(scaleFactor, scaleFactor, detector.focusX, detector.focusY) } return true }   裁剪图片,这里可以替换其他方式，提高效率,这里使用中够用，暂时这样处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  fun crop(file: File, outputX: Int, outputY: Int): Boolean { val bitmap = cropImage(outputX, outputY) ?: return false try { if (!file.exists()) { if (!file.parentFile.mkdirs() || !file.createNewFile()) { return false } } val fos = FileOutputStream(file) //java 中可以直接bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos)  //kotlin中报错，必须work线程中处理  val thread = Thread(Runnable { bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos) }) thread.join() fos.flush() fos.close() bitmap.recycle() return true } catch (e: Exception) { e.printStackTrace() } return false } fun cropImage(outputX: Int, outputY: Int): Bitmap? { val drawable = (drawable ?: return null) as? BitmapDrawable ?: return null val scale = getCurrentScale() val mRectF = getMatrixRectF() val w: Float = overView.width() / scale val h: Float = overView.height() / scale val left: Float = (overView.left - mRectF.left) / scale val top: Float = (overView.top - mRectF.top) / scale val srcBmp = drawable.bitmap val cropBmp = Bitmap.createBitmap( srcBmp, left.toInt(), top.toInt(), w.toInt(), h.toInt() ) val bmp = Bitmap.createScaledBitmap(cropBmp, outputX, outputY, false) cropBmp.recycle() return bmp }   最开始写这个控件的时候是java，写文章的时候重写改成kotlin，继承OnScaleGestureListener ,onScaleEnd这里原不需要逻辑，结果kotlin自动生成TODO(\u0026quot;not implemented\u0026quot;) ，这个标志必须删除，不然缩放的时候会崩溃。。。\noverride fun onScaleEnd(detector: ScaleGestureDetector?) {\nTODO(\u0026ldquo;not implemented\u0026rdquo;) //To change body of created functions use File | Settings | File Templates.\n}\n 源码\n "
},
{
	"uri": "https://dshcao.github.io/zh/series/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/renderscript%E4%BD%BF%E7%94%A8/",
	"title": "Android RenderScript使用",
	"tags": ["android"],
	"categories": [],
	"series": ["renderscript"],
	"description": "Android RenderScript详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BBtransition/",
	"title": "Android 转场动画Transition",
	"tags": ["android", "animation"],
	"categories": [],
	"series": ["android"],
	"description": "Android 转场动画Transition详解.",
	"content": "Transition Android中Transition是两个场景(Scene)之间的一个过渡转场动画效果。\nTransition有两个构造函数\n1 2 3 4 5 6  //代码创建 public Transition() {} //从res/transition资源文件加载创建 public Transition(Context context, AttributeSet attrs) { ... }   如：\n1 2 3 4 5 6 7 8  \u0026lt;transitionSet xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;changeBounds/\u0026gt; \u0026lt;fade android:fadingMode=\u0026#34;fade_in\u0026#34; android:duration=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target android:targetId=\u0026#34;@id/transition_title\u0026#34; /\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/fade\u0026gt; \u0026lt;/transitionSet\u0026gt;   TransitionManager.changeScene/TransitionManager.beginDelayedTransition-\u0026gt;\nsceneChangeRunTransition\nsceneChangeRunTransition中为sceneRoot设置监听器监听onPreDraw，在onPreDraw调用transition.playTransition-\u0026gt;runAnimators\nPathMotion 1 2 3 4 5  public abstract class PathMotion { public PathMotion() {} public PathMotion(Context context, AttributeSet attrs) {} public abstract Path getPath(float startX, float startY, float endX, float endY); }   Scene和TransitionInflater/TransitionManager Scene 场景，即UI状态\nTransitionInflater 初始化Scene或TransitionManager\nTransitionManager 控制Scene使用某个Transition动画效果转换\n new Scene() Scene.getSceneForLayout scene.enter() scene.exit() TransitionInflater.from(context).inflateTransition() TransitionInflater.from(context).inflateTransitionManager() TransitionManager.go() 默认transition效果是AutoTransition，也可以指定其他Transition实现 transitionManager.transitionTo()  Transition 的实现  TransitionSet 多个transition(TransitionSet也是transition)的集合，TransitionSet是集合子transition的parent，通过ORDERING_TOGETHER和ORDERING_SEQUENTIAL两种play方式实现复杂的转场效果。TransitionSet对子transitions管理  AutoTransition 继承自TransitionSet并使用初始化的指定效果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class AutoTransition extends TransitionSet { public AutoTransition() { init(); } public AutoTransition(Context context, AttributeSet attrs) { super(context, attrs); init(); } private void init() { setOrdering(ORDERING_SEQUENTIAL); addTransition(new Fade(Fade.OUT)). addTransition(new ChangeBounds()). addTransition(new Fade(Fade.IN)); } }      ChangeBounds Scene改变前后布局边界转场动画 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * Setting this flag tells ChangeBounds to track the before/after parent * of every view using this transition. The flag is not enabled by * default because it requires the parent instances to be the same * in the two scenes or else all parents must use ids to allow * the transition to determine which parents are the same. * * @param reparent true if the transition should track the parent * container of target views and animate parent changes. * @deprecated Use {@link android.transition.ChangeTransform} to handle * transitions between different parents. */ @Deprecated public void setReparent(boolean reparent) { mReparent = reparent; }    ChangeTransform Scene改变前后视图缩放和旋转动画 ChangeClipBounds Scene改变前后视图clipBounds边界转场动画 ChangeImageTransform Scene改变前后imageView matrix变换动画 ChangeScroll Scene改变前后view x/y上滚动变换动画 Visibility Scene改变前后view visibility变换动画  Slide Scene改变前后根据视图可见性，操作视图translationX/translationY将视图从场景某个边缘移入或移出 Explode Scene改变前后根据视图可见性，操作视图translationX/translationY将视图从场景边缘移入或移出,其中移入动画源码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public Animator onAppear(ViewGroup sceneRoot, View view, TransitionValues startValues, TransitionValues endValues) { if (endValues == null) { return null; } Rect bounds = (Rect) endValues.values.get(PROPNAME_SCREEN_BOUNDS); float endX = view.getTranslationX(); float endY = view.getTranslationY(); calculateOut(sceneRoot, bounds, mTempLoc); float startX = endX + mTempLoc[0]; float startY = endY + mTempLoc[1]; return TranslationAnimationCreator.createAnimation(view, endValues, bounds.left, bounds.top, startX, startY, endX, endY, sDecelerate, this); }    Fade Scene改变前后视图transitionAlpha变换动画 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private Animator createAnimation(final View view, float startAlpha, final float endAlpha) { if (startAlpha == endAlpha) { return null; } view.setTransitionAlpha(startAlpha); final ObjectAnimator anim = ObjectAnimator.ofFloat(view, \u0026#34;transitionAlpha\u0026#34;, endAlpha); if (DBG) { Log.d(LOG_TAG, \u0026#34;Created animator \u0026#34; + anim); } final FadeAnimatorListener listener = new FadeAnimatorListener(view); anim.addListener(listener); addListener(new TransitionListenerAdapter() { @Override public void onTransitionEnd(Transition transition) { view.setTransitionAlpha(1); transition.removeListener(this); } }); return anim; }       自定义Transition 过渡动画Transition需要捕获两个Sence之间的差异并使用属性动画实现过渡。属性动画是更改指定时间段内的起始值和结束值之间的视图属性，因此Transition框架需要同时具有属性的起始值和结束值才能构建动画，可参考官方文档创建自定义过渡动画\n 捕获初始值 override fun captureStartValues(transitionValues: TransitionValues)  Transition有两个抽象方法，一个空方法需要实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class CustomTransition : Transition() { // package_name:transition_name:property_name  private val PROPNAME_BACKGROUND = \u0026#34;com.example.android.customtransition:CustomTransition:background\u0026#34; override fun captureStartValues(transitionValues: TransitionValues) { captureValues(transitionValues) } override fun captureEndValues(transitionValues: TransitionValues) { captureValues(transitionValues) } private fun captureValues(transitionValues: TransitionValues) { transitionValues.values[PROPNAME_BACKGROUND] = view.background } override fun createAnimator( sceneRoot: ViewGroup, startValues: TransitionValues?, endValues: TransitionValues? ): Animator? { return super.createAnimator(sceneRoot, startValues, endValues) } ... }   ActivityOptions \u0026amp; Activity的过渡动画 Activity的过渡动画是建立在Transition的基础上的。进入动画/退出动画/共享元素动画都是一个transition。Activity的过渡动画主要包含：\n 进入动画/退出动画 必须是继承Visibility的Transition，Android中的实现有Slide Explode Fade 共享元素动画 activity视图中的过渡元素，Android中的实现有ChangeBounds ChangeClipBounds ChangeTransform ChangeImageTransform ChangeScroll等 API分析    window.enterTransition A-\u0026gt;B B中View的动画\n  window.exitTransition A-\u0026gt;B A中View的动画\n  window.returnTransition A-\u0026gt;B 再从B退到A，B中View的动画\n  window.reenterTransition A-\u0026gt;B 再从B退到A，A中View的动画\n  window.sharedElementEnterTransition 针对共享元素的，时机同window.enterTransition\n  window.sharedElementExitTransition 针对共享元素的，时机同window.exitTransition\n  window.sharedElementReturnTransition 针对共享元素的，时机同window.returnTransition\n  window.sharedElementReenterTransition 针对共享元素的，时机同window.reenterTransition\n  ActivityOptions.makeSceneTransitionAnimation() 设置共享元素，此处传递的A中的view和transitionName会与B中有相同transitionName的View做动画，即以A中的某个transitionName的view状态作为初始Sence，以B中该transitionName的view状态作为最终Sence做动画\n  activity.postponeEnterTransition() 延迟EnterTransition，使用场景：图片选择activity进入图片查看activity,图片查看activity的共享元素ImageView需要下载大图资源，显示大图前无法确定ImageView大小，此时可以用postponeEnterTransition()延迟动画，下载完成后调用startPostponedEnterTransition()开启动画。但这也会造成一个问题：如果下载时间较长，下载完成前EnterTransition动画会卡住一段时间，可以使用占位图片等方式配合解决\n  activity.supportPostponedEnterTransition() 支持库版本，会判定版本号是否执行activity.postponeEnterTransition()\n  activity.startPostponedEnterTransition() 配合activity.postponeEnterTransition()使用，开启EnterTransition\n  activity.supportStartPostponedEnterTransition() 支持库版本，会判定版本号是否执行activity.supportStartPostponedEnterTransition()\n  activity.finishAfterTransition()\n  window.transitionManager/activity.contentTransitionManager\n  window.contentScene/activity.contentScene windown content的Sence，activity需要设置window.requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)，否则window.contentScene为null\n  window.allowEnterTransitionOverlap true尽快执行过渡动画，false会等待A的exitTransition执行完执行完再执行B的enterTransition\n  window.allowReturnTransitionOverlap true尽快执行过渡动画，false会等待B的exitTransition执行完再执行A的reenterTransition\n  Activity方法onActivityReenter(resultCode: Int, data: Intent?)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * Called when an activity you launched with an activity transition exposes this * Activity through a returning activity transition, giving you the resultCode * and any additional data from it. This method will only be called if the activity * set a result code other than {@link #RESULT_CANCELED} and it supports activity * transitions with {@link Window#FEATURE_ACTIVITY_TRANSITIONS}. * * \u0026lt;p\u0026gt;The purpose of this function is to let the called Activity send a hint about * its state so that this underlying Activity can prepare to be exposed. A call to * this method does not guarantee that the called Activity has or will be exiting soon. * It only indicates that it will expose this Activity\u0026#39;s Window and it has * some data to pass to prepare it.\u0026lt;/p\u0026gt; * * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \u0026#34;extras\u0026#34;). */ public void onActivityReenter(int resultCode, Intent data) { }     Window.FEATURE_CONTENT_TRANSITIONS\n1 2 3 4 5 6 7 8 9 10 11  /** * Flag for requesting that window content changes should be animated using a * TransitionManager. * * \u0026lt;p\u0026gt;The TransitionManager is set using * {@link #setTransitionManager(android.transition.TransitionManager)}. If none is set, * a default TransitionManager will be used.\u0026lt;/p\u0026gt; * * @see #setContentView */ public static final int FEATURE_CONTENT_TRANSITIONS = 12;     Window.FEATURE_ACTIVITY_TRANSITIONS\n1 2 3 4 5 6 7 8  /** * Enables Activities to run Activity Transitions either through sending or receiving * ActivityOptions bundle created with * {@link android.app.ActivityOptions#makeSceneTransitionAnimation(android.app.Activity, * android.util.Pair[])} or {@link android.app.ActivityOptions#makeSceneTransitionAnimation( * android.app.Activity, View, String)}. */ public static final int FEATURE_ACTIVITY_TRANSITIONS = 13;     Fragment的过渡动画 Fragment中有类似Activity的方法，区别是：\nvar transaction: FragmentTransaction = supportFragmentManager.beginTransaction()\ntransaction.addSharedElement()//添加共享元素\ntransaction在added, removed, attached, detached, shown,hidden等触发transition过渡动画\n 源码\n 参考：\n 创建自定义过渡动画 用开源项目ActivityOptionsICS让ActivityOptions的动画实现兼容  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-handler%E8%A7%A3%E6%9E%90/",
	"title": "Android源码解析-Handler",
	"tags": ["android", "handler"],
	"categories": [],
	"series": ["源码解析"],
	"description": "android Handler机制详解.",
	"content": "前言 Handler使Android中非常重要的组成部门，很多地方包括系统服务也大量用到Handler这一机制。Handler让我们的开发难度大大降低，几乎看不到多线程死锁问题。\nHandler常见问题  Handler使用不当导致内存泄漏 在子线程创建Handler需要为该Handler准备Looper(调用Looper.prepare()、Looper.loop())，在主线程则不需要(系统帮我们做了) Handler处理消息过程中页面可能已销毁，此时页面控件已经不在，此时更新控件可能空指针异常。  Handler机制源码解析 Handler机制涉及到:Handler、Looper、MessageQueue、Message、ThreadLocal\nHandler  Handler(Looper, Callback, boolean) hide方法，最后一个参数是设置分发的是否是异步消息 1 2 3 4 5 6  public Handler(@NonNull Looper looper, @Nullable Callback callback, boolean async) { mLooper = looper; mQueue = looper.mQueue; mCallback = callback; mAsynchronous = async; }    sendMessage(Message) 发送一个消息 sendMessageDelayed(Message, long) 发送一个延迟消息 sendMessageAtTime(Message, long) 发送一个在指定时间点分发的消息 sendMessageAtFrontOfQueue(Message) 在消息队列队首插入一个消息(消息的when=0，即分发时间是当前时间。) sendEmptyMessage(int) 发送一个空消息 sendEmptyMessageDelayed(int, long) 发送一个延迟空消息 sendEmptyMessageAtTime(int, long) 发送一个在指定时间点分发的空消息 enqueueMessage(MessageQueue, Message,long) 将消息入队。这里有亮点需要注意：1.msg.target = this; 2.msg.setAsynchronous(true); 1 2 3 4 5 6 7 8 9 10 11 12 13  private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg,long uptimeMillis) { //为msg设置target，我们一般编程发送消息都会走到这里，即我们所发送的消息都会有target  //这是和后面介绍的屏障消息的重要区别。  msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); //如果创建的Handler是异步Handler，那么其发送的所有消息都将是异步消息  //创建异步Handler在API28才对开发者开放。  if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis); }    hasMessages(int, Object) 知否存在指定的消息 removeMessages(int, Object) 移除指定消息 hasCallbacks(Runnable) 是否存在指定callback的消息 removeCallbacks(Runnable, Object) 移除指定队列消息包含callback且obj=Object的消息，若Object==null，则不对比Message的obj。 post(Runnable) 发送一个callback消息 postAtFrontOfQueue(Runnable) 类似post。  Message Message分为两类：同步消息、异步消息。异步消息优先级高于同步消息。在屏障消息机制下异步消息会优先于同步消息执行。所谓屏障消息是一种特殊(target==null)的消息，用于保证异步消息的优先执行。屏障消息的本质就是告诉MessageQueue#next操作我这个队列中有异步消息，你快去循环出来优先执行。\nMessage#what 识别message的标识，相当于id。\nMessage#arg1/Message#arg2 arg1和arg2是data的低成本替代品，当只需要几个整形参数时，可以使用arg1和arg2替代data\nMessage#obj 发接收/处理方的任意对象，但当是跨进程发送消息时：Android2.2以后必须是Parcelable的，Android2.2以前不支持使用此字段快进程。\nMessage#replyTo 当使用Messenger跨进程通信时可以使用replyTo回复消息。\nMessage#when 基于SystemClock#uptimeMillis的时间，是Message被分发(dispatchMessage)的时间。\nMessage#data Message携带数据\nMessage#target 发送(sendMessage)这个Message的Handler\nMessage#callback 只能在Messenger.obtain时设置，当dispatchMessage时如果Message有callback则不再走handleMessage。\nMessage#obtain() 复用sPool对象，避免频繁创建销毁对象增加GC压力。sPool是一个Message链表的第一个元素，默认长度MAX_POOL_SIZE(50)。每当调用obtain()时若sPool不为null(链表有元素)，则复用sPool对象，并修改sPool链表长度减1。\nMessage#recycle()/Message#recycleUnchecked() 每当调用该方法则检查sPool链表是否达到最大长度MAX_POOL_SIZE，如果未达到则将当前Message重置并加入到sPool链表(复用池)中。\nMessage#.isAsynchronous() 是否是异步消息，API22后用户可获取，之前未对开发者开放\nMessage#.setAsynchronous(async) 设置是否是异步消息，API22后用户可设置，之前未对开发者开放\nLooper 为什么Looper.myLooper可以获取当前线程的Looper或者说Looper如何与Thread关联的呢？首先我们查看Looper.myLooper是如何获取当前线程的Looper的\n1 2 3  public static @Nullable Looper myLooper() { return sThreadLocal.get(); }   原来是通过sThreadLocal获取的。sThreadLocal可以存放获取绑定到当前线程的数据，你不往里放它自己肯定是没有的，既然是存放获取绑定到当前线程的数据肯定是在当前线程存放的，很容易想到Looper.prepare()和Looper.loop()两个方法，查看Looper.prepare()源码\n1 2 3 4 5 6 7 8 9 10  public static void prepare() { prepare(true); } private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\u0026#34;Only one Looper may be created per thread\u0026#34;); } sThreadLocal.set(new Looper(quitAllowed)); }   正中所想。\n那Looper.loop()这个方法是做什么用的呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48  public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\u0026#34;No Looper; Looper.prepare() wasn\u0026#39;t called on this thread.\u0026#34;); } final MessageQueue queue = me.mQueue; ... for (;;) { Message msg = queue.next(); // 从消息队列取Message对象，如果没取到则阻塞在这  if (msg == null) {//MessageQueue已退出，即调用了quit()或quitSafely()  return; } ... final Observer observer = sObserver; Object token = null; if (observer != null) { token = observer.messageDispatchStarting(); } try { msg.target.dispatchMessage(msg);//分发消息  if (observer != null) { observer.messageDispatched(token, msg); } dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; } catch (Exception exception) { if (observer != null) { observer.dispatchingThrewException(token, msg, exception); } throw exception; } finally { ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) { Trace.traceEnd(traceTag); } } ... msg.recycleUnchecked();//复用消息  } } public void quit() { mQueue.quit(false); } public void quitSafely() { mQueue.quit(true); }   从源码可以看出loop()方法主要做了三件事：从MessageQueue取消息、调用dispatchMessage分发取出的消息、复用分发后的消息。\nMessageQueue MessageQueue是一个存放一个有序(以Message的when排序)的Message的队列。从上面Looper源码分析来看，我们有几个问题：1.queue.next()既然是阻塞的为什么没有导致ANR？2.quit()和quitSafely()最终是怎么实现退出loop循环的？从loop方法看似乎是让MessageQueue的next方法取出一个null的Message对象。\n在回答这两个问题前我们需要先了解什么是屏障消息。屏障消息即时一个target==null的特殊消息(正常我们调用sendMessage发送消息系统会自动帮我们设定非空target)。系统如何发布一个屏障消息：\nMessageQueue#postSyncBarrier\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public int postSyncBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); } private int postSyncBarrier(long when) { // Enqueue a new sync barrier token.  // We don\u0026#39;t need to wake the queue because the purpose of a barrier is to stall it.  synchronized (this) { final int token = mNextBarrierToken++; final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; if (when != 0) { while (p != null \u0026amp;\u0026amp; p.when \u0026lt;= when) { prev = p; p = p.next; } } if (prev != null) { // invariant: p == prev.next  msg.next = p; prev.next = msg; } else { msg.next = p; mMessages = msg; } return token; } }   当然这是只有系统才可以使用的API，没有对开发者开放。\n现在我们先看第二个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61  void quit(boolean safe) { if (!mQuitAllowed) { throw new IllegalStateException(\u0026#34;Main thread not allowed to quit.\u0026#34;); } synchronized (this) { if (mQuitting) { return; } mQuitting = true; if (safe) { removeAllFutureMessagesLocked(); } else { removeAllMessagesLocked(); } // We can assume mPtr != 0 because mQuitting was previously false.  nativeWake(mPtr); } } //重置复用消息，然后将所有mMessages链表Message对象置为null private void removeAllMessagesLocked() { Message p = mMessages; while (p != null) { Message n = p.next; p.recycleUnchecked(); p = n; } mMessages = null; } //检查mMessages的when是否小于等于当前时间，如果是标明mMessages这个消息已经分发/正在出去并且可能正在使用，如果粗暴的将mMessages重置然后置为null，可能导致程序异常；如果mMessages的when大于当前时间说明尚未分发，可以放心回收。 private void removeAllFutureMessagesLocked() { final long now = SystemClock.uptimeMillis(); Message p = mMessages; if (p != null) { if (p.when \u0026gt; now) { removeAllMessagesLocked(); } else {//mMessages.when\u0026lt;=now  Message n; for (;;) { n = p.next;//跳过mMessages从mMessages的下个元素开始  if (n == null) { return; } if (n.when \u0026gt; now) { break; } p = n; } p.next = null; do { p = n; n = p.next; p.recycleUnchecked(); } while (n != null); } } }   从上面代码可以看出Looper.quit()和Looper.quitSafely()的主要区别是判断了mMessages链表的首元素的when，即是否已分发，分发出去的消息可能正在使用不能回收，强制回收可能消息行为改变(recycleUnchecked后mMessages = null前)或导致空指针异常。\n再来看MessageQueue#next()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98  Message next() { final long ptr = mPtr; if (ptr == 0) {//mPtr为0表示已调用quit退出或者当前MessageQueue已没有被其他任何对象引用(调用了finalize()方法)等待被GC回收状态  return null; } int pendingIdleHandlerCount = -1; // -1 only during first iteration  int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis);//会调用到linux的epoll_wait，阻塞指定时间(nextPollTimeoutMillis)并释放时间片  synchronized (this) { // Try to retrieve the next message. Return if found.  final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null \u0026amp;\u0026amp; msg.target == null) {//同步屏障消息  // Stalled by a barrier. Find the next asynchronous message in the queue.  do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026amp;\u0026amp; !msg.isAsynchronous()); } if (msg != null) { if (now \u0026lt; msg.when) {//消息未到分发时间，设置一个超时唤醒时间。  nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else {//有消息需要分发，执行正常流程  mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \u0026#34;Returning message: \u0026#34; + msg); msg.markInUse(); return msg; } } else {// mMessages链表中没有消息  nextPollTimeoutMillis = -1; } //------------只有没有消息时才会执行到下面的代码-------------------//  if (mQuitting) {//退出  dispose(); return null; } // If first time idle, then get the number of idlers to run.  // Idle handles only run if the queue is empty or if the first message  // in the queue (possibly a barrier) is due to be handled in the future.  if (pendingIdleHandlerCount \u0026lt; 0 \u0026amp;\u0026amp; (mMessages == null || now \u0026lt; mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } //如果没有IdleHandler需要运行  if (pendingIdleHandlerCount \u0026lt;= 0) { //标识当前处于阻塞状态，用于enqueueMessage唤醒mPtr(nativeWake(mPtr))，即唤醒next执行，取消阻塞重新争抢时间片。  mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } for (int i = 0; i \u0026lt; pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler  boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, \u0026#34;IdleHandler threw exception\u0026#34;, t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } //重置需要执行的IdelHandler  pendingIdleHandlerCount = 0; //执行IdelHandler时可能队列已有了新消息，因此将nextPollTimeoutMillis设置为0重新检查。  nextPollTimeoutMillis = 0; } }   其他 IdleHandler 在MessageQueue的小节通过分析源码我们了解到IdleHandler，它会在无消息空闲状态下触发执行，这是一种很好的优化方法。比如用来优化App的启动。\nThreadLocal ThreadLocal是一个线程隔离的工具类，详细请见另一篇Java-ThreadLocal源码解析\nHandler机制大致流程(不严谨的流程) Looper.prepare()-\u0026gt;Looper.loop()-\u0026gt;MessageQueue.next-\u0026gt;Handler.dispatchMessage-\u0026gt;Message.callback/Handler.handlerMessage\nHandler、Looper、MessageQueue对应关系 一个线程对应一个Looper，多个Handler\n一个Looper对应一个MessageQueue，多个Handler\n一个MessageQueue对应一个线程，一个Looper，多个Handler。\nHandler机制原理 内存共享，使用MessageQueue/Message这一线程独有的内存对象实现线程间通信。\n"
},
{
	"uri": "https://dshcao.github.io/zh/categories/animation/",
	"title": "animation",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/animation/",
	"title": "animation",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/handler/",
	"title": "handler",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/http/",
	"title": "http",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/http/",
	"title": "http",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/httphttps/",
	"title": "Http/Https详解",
	"tags": ["http", "https"],
	"categories": [],
	"series": ["编程基础"],
	"description": "Http/Https详解",
	"content": "HTTP(HyperText Transfer Protocol) 超文本传输协议，虽然名字叫传输协议，但其其实是应用层的协议，是构建在传输层协议TCP之上的协议。\n   http版本 诞生年份      HTTP/0.9 1991 文本信息   HTTP/1.0 1996 文本、图像、视频、二进制文件   HTTP/1.1 1999 当前流行版本   HTTPS 2000    HTTP/2.0 2015 当前应用不多，主要用于API Service   HTTP/3.0 研发中 使用Quic(改进的UDP)取代TCP    HTTP 各版本区别 HTTP/1.0 HTTP/1.1 HTTP/1.1默认使用keep-alive长连接，解决了多次请求建立多次TCP连接的问题，但这个TCP长连接中的请求是串行的，某个请求耗时严重会阻塞后面的请求。\nHTTP/2.0 HTTP/2.0使用了头部压缩技术及多路复用。不同于HTTP/1.1的keep-alive长连接，HTTP/2.0允许多个请求并行执行。在 HTTP/2.0中，有两个非常重要的概念，分别是(二进制)帧（frame）和流（stream），帧是最小的数据单位，每个帧标识了自己属于哪个流，因此HTTP/2.0可以实现并行。\nHTTP请求方法   GET\nGET的请求应该只被用于获取给定的URL标识的服务端资源，GET请求不应有请求体也不应对请求数据造成影响。\n  POST\n创建或更新资源，请求数据包含在请求体中。POST请求的body主要有有两种格式，一种是application/x-www-form-urlencoded用来传输简单的数据，大概就是\u0026quot;key1=value1\u0026amp;key2=value2\u0026quot;这样的格式。另外一种是传文件，会采用multipart/form-data格式。采用后者是因为application/x-www-form-urlencoded的编码方式对于文件这种二进制的数据非常低效。\n  PUT\n使用请求数据取代服务端目标资源。\n  DELETE\n请求服务端删除给定URL标识的资源。\n  HEAD\n和GET的唯一区别是不返回响应体。使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”（元信息或称元数据）。通常用于测试超链接的有效性或下载前查看文件有多大，服务器是否支持断点下载等。\n  CONNECT\nHTTP/1.1协议中预留给能够将连接改为隧道方式的代理服务器。通常用于SSL加密服务器的链接（经由非加密的HTTP代理服务器）。方法名称是区分大小写的。\n当某个请求所针对的资源不支持对应的请求方法的时候，服务器应当返回状态码405（Method Not Allowed），当服务器不认识或者不支持对应的请求方法的时候，应当返回状态码501（Not Implemented）。\n  OPTIONS\n这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用\u0026rsquo;*\u0026lsquo;来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。\n  TRACE\n回显服务器收到的请求，主要用于测试或诊断。\n  PATCH\n用于对资源应用部分修改。\n  状态码(Status Code)   1xx 消息\n100 - 服务器已经接收到请求头，并且客户端应继续发送请求主体，或者如果请求已经完成，忽略这个响应。服务器在请求完成后向客户端发送一个最终响应。\n  2xx 成功，操作被成功接收并处理\n200 - 请求成功\n201 - 请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回'202 Accepted\u0026rsquo;。\n202 - 服务器已接受请求，但尚未处理完成。\n203 - 服务器是一个转换代理服务器（如网络加速器），请求获得了源服务器的状态码为 200 (OK)的响应，但经过了转换代理服务器的修改。\n  3xx 重定向，需要进一步的操作以完成请求\n301 - 资源（网页等）被永久转移到其它URI，新的永久性的URI应当在响应的Location域中返回。\n302 - Found，请求资源已被临时转移到其它URI，新的临时性的URI应当在响应的Location域中返回。由于这个重定向是临时的，只有在Cache-Control或Expires中进行了指定的情况下，这个临时URI才是有效可缓存的，之后客户端应当继续向原有地址发送以后的请求。\n  4xx 客户端错误，请求包含语法错误或无法完成请求\n400 - Bad Request，由于明显的客户端错误（如请求语法格式错误，无效的请求消息或欺骗性路由请求），服务器不能或不会处理该请求。\n401 - Unauthorized，该状态码表示当前请求需要用户验证但用户没有必要的凭证。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。\n403 - Forbidden，服务器端有能力处理该请求，但是拒绝授权访问。这个状态类似于 401，但进入该状态后不能再继续进行验证。该访问是长期禁止的，并且与应用逻辑密切相关。\n404 - 请求的资源（网页等）不存在\n  5xx 服务器错误，服务器在处理请求的过程中发生了错误\n500 - 服务器遇到了一个未曾预料的状况导致了它无法完成对请求的处理\n  这里就不啰嗦了，详细解释见参考维基百科-HTTP状态码\nHTTP头字段 更多详情解释见参考维基百科-HTTP头字段\n缓存头字段及缓存策略 =Last-Modified则标识未改变返回304，否则返回改变后的资源 2. Etag/If-None-Match etag：当前资源在服务器端的唯一标识，生成规则由服务器决定。客户端再次请求资源时带上etag -- 详情见参考HTTP 缓存- HTTP | MDN、最佳Cache-Control 策略 - Google Developers\n断点续传 Range\nAccept-Range\nContent-Range\nIf-Range\n检测服务器是否支持断点续传 Response的Headers能够找到 Content-Range，则表明服务器支持断点续传。有些服务器还会返回 Accept-Ranges，输出结果 Accept-Ranges: bytes ，说明服务器支持按字节下载。\nHTTP报文结构 请求报文结构 请求报文主要包含三部分：请求行，请求头部，请求体\nGET请求报文结构：\n① GET /dshcao/dshcao.github.io HTTP/1.1 ② Host: github.com ③ Connection: keep-alive ④ Upgrade-Insecure-Requests: 1 ⑤ User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 ⑥ Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 ⑦ Sec-Fetch-Site: none ⑧ Sec-Fetch-Mode: navigate ⑨ Sec-Fetch-Dest: document ⑩ Accept-Encoding: gzip, deflate, br ⑪ Accept-Language: zh-CN,zh;q=0.9 ⑫ Cookie: _ga=GA1.2.464683002.1544702315; _octo=GH1.1.1103713911.1544702315; _device_id=6dcac799610fe64ac0c51f9f73ff2ab5; ① 请求行：请求方法+请求path+协议及版本\n②～⑫ 请求头部\nPOST请求报文结构：\n① POST /xx/yy/zz HTTP/1.1 ② Host: github.com ③ Connection: keep-alive ④ Upgrade-Insecure-Requests: 1 ⑤ User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36 ⑥ Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9 ⑦ Sec-Fetch-Site: none ⑧ Sec-Fetch-Mode: navigate ⑨ Sec-Fetch-Dest: document ⑩ Accept-Encoding: gzip, deflate, br ⑪ Accept-Language: zh-CN,zh;q=0.9 ⑫ Content-Length: 18 ⑬ Content-Type: application/x-www-form-urlencoded ⑭ Cookie: _ga=GA1.2.464683002.1544702315; _octo=GH1.1.1103713911.1544702315; _device_id=6dcac799610fe64ac0c51f9f73ff2ab5; ⑮ ⑯ name=jack\u0026amp;q=domety ① 请求行：请求方法+请求path+协议及版本\n②～⑭ 请求头部\n⑮ 请求头部和请求体之间需要的空行\n⑯ 请求体\n响应报文结构 响应报文主要包含三部分：状态行，响应头部，响应体\n① HTTP/1.1 200 OK ② Bdpagetype: 2 ③ Bdqid: 0xeaa4231b000d977f ④ Cache-Control: private ⑤ Connection: keep-alive ⑥ Content-Encoding: gzip ⑦ Content-Type: text/html;charset=utf-8 ⑧ Date: Sat, 30 May 2020 09:06:17 GMT ⑨ Expires: Sat, 30 May 2020 09:06:17 GMT ⑩ Server: BWS/1.1 ⑪ Set-Cookie: BDSVRTM=502; path=/ ⑫ Set-Cookie: BD_HOME=1; path=/ ⑬ Set-Cookie: H_PS_PSSID=31727_1456_21114_31110_31589_31463_30823_26350; path=/;domain=.baidu.com ⑭ Strict-Transport-Security: max-age=172800 ⑮ Traceid: 1590829577071592193016907677499927664511 ⑯ X-Ua-Compatible: IE=Edge,chrome=1 ⑰ Transfer-Encoding: chunked ⑱ ⑲ \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026quot;Content-Type\u0026quot; content=\u0026quot;text/html; charset=UTF-8\u0026quot;\u0026gt; ... \u0026lt;/head\u0026gt; \u0026lt;/html\u0026gt; ① 状态行：协议及版本+状态码+状态信息\n②～⑰ 响应头部\n⑱ 响应头部与响应体之间所需的空行\n⑲ 响应体\n一次完整的HTTP请求过程  首先进行DNS域名解析（本地浏览器缓存、操作系统缓存或者DNS服务器） 三次握手建立 TCP 连接 客户端向服务器发送请求命令 Get /www.xx.com/ http/1.1 客户端发送请求头信息 服务器应答 Http/1.1 200 OK 返回响应头信息 服务器向客户端发送数据 服务器关闭 TCP 连接  HTTPS(Hyper Text Transfer Protocol over SecureSocket Layer) HTTPS本质上就是客户端和服务端使用非对称密钥协商出一个对称密钥，在后面双方发收的数据时使用这个对称密钥加密解密，从而保证数据的安全传输。\n 对称加密\n速度高，可加密内容较大，用来加密会话过程中的消息。  常见的对称加密算法有：DES、3DES、AES、Blowfish、IDEA、RC5、RC6\n2. 公钥加密\n加密速度较慢，但能提供更好的身份认证技术，用来加密对称加密的密钥。\n常见的公钥加密算法有：RSA、ElGamal、背包算法、Rabin（RSA的特例）、迪菲－赫尔曼密钥交换协议中的公钥加密算法、椭圆曲线加密算法）\n建立连接时，SSL使用非对称加密的公钥加密对称密钥，连接建立完成后使用对称密钥对数据进行加密传输。\nHttps分为单向认证和双向认证，单向认证即客户端需要验证服务端，服务端不需要验证客户端。双向认证则是客户端需要验证服务端，服务端也需要验证客户端。\n非对称加密与签名 非对称加密中公钥加密的数据私钥可以解密，同样的私钥加密的数据公钥也可以解密，但公钥和私钥却不是可以互换的，你不能将公钥当私钥使用，也不能将私钥当公钥使用，这听起来有点奇怪，为什么可以互相加解密却不能互换身份？因为可以使用私钥推理出公钥相对容易，但使用公钥推理出私钥却比较困难。你可能继续问这是怎么做到的？这设计非对称加密原理，参阅非对称加密原理\n签名 签名是非对称加密的反过程，即使用私钥加密，使用公钥解密。实际使用中的签名一般都是对原数据的hash签名，因为一般数据的hash长度远小于消息原文，使得签名（非对称加密）的效率大大提高。\n签名数据的传递一般是：原数据 + 私钥加密的原数据的hash。\n对签名后的数据验证：通过公钥对签名解密出原数据的hash与原数据的hash对比。\nSSL(Secure Socket Layer)和TLS(Transport Layer Secure) SSL是早期的叫法，TLS是现在规范的叫法。\nHTTPS单向认证 HTTPS双向认证 参考：\n 维基百科-HTTP状态码 MDN web docs HTTP 响应代码 维基百科-HTTP头字段 最佳Cache-Control 策略 - Google Developers HTTP 缓存- HTTP | MDN Https单向认证和双向认证  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/https/",
	"title": "https",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/jetpack/",
	"title": "jetpack",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/jetpack/",
	"title": "jetpack",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-jobservice/",
	"title": "Jetpack-JobService详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件JobService详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-lifecycles/",
	"title": "Jetpack-Lifecycles",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件Lifecycles详解",
	"content": "原理 ReportFragment\nProcessLifecycleOwner ActivityInitializationListener\nLifecycleOwner\u0026amp;LifecycleObserver LifecycleRegistry\u0026amp;Lifecycle LiveData既是观察者也是被观察者\n作为观察者可以观察Activity和Fragment的生命周期\n通常将LiveData包在ViewModel中使用\nLiveData使用mVersion表示数据是否有变化，并判断Activity是否在前台，在前台则回调通知\n LiveData   MutableLiveData\n MediatorLiveData SavingStateLiveData LoaderInfo    SliceLiveDataImpl\n  CachedLiveDataImpl\n  PublisherLiveData\n    ComputableLiveData\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-navigation/",
	"title": "Jetpack-Navigation详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件Navigation详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-roomlivedataviewmodel%E8%AF%A6%E8%A7%A3/",
	"title": "Jetpack-Room&amp;LiveData&amp;ViewModel详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack-Room&amp;LiveData&amp;ViewModel详解",
	"content": "Room升级 当数据表结构变化时如何直接修改version会导致数据库数据被清空\n1 2 3 4 5 6 7 8  return Room.databaseBuilder(context, AppDatabase::class.java, \u0026#34;dsh\u0026#34;).allowMainThreadQueries().addMigrations(Migration1000To1001()).build() class Migration1000To1001 : Migration(1000, 1001) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(\u0026#34;alter table user add column vip integer not null default 0\u0026#34;) } }   这样就不会升级时就不会清空数据库数据\n屏幕旋转过程中会回调\nonRetainNonConfigurationInstance\ngetLastNonConfigurationInstance\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public final Object onRetainNonConfigurationInstance() { Object custom = onRetainCustomNonConfigurationInstance(); ViewModelStore viewModelStore = mViewModelStore; if (viewModelStore == null) { // No one called getViewModelStore(), so see if there was an existing  // ViewModelStore from our last NonConfigurationInstance  NonConfigurationInstances nc = (NonConfigurationInstances) getLastNonConfigurationInstance(); if (nc != null) { viewModelStore = nc.viewModelStore; } } if (viewModelStore == null \u0026amp;\u0026amp; custom == null) { return null; } NonConfigurationInstances nci = new NonConfigurationInstances(); nci.custom = custom; nci.viewModelStore = viewModelStore; return nci; }   这也是ViewModel包装后的数据可以在屏幕旋转过程依然可以正常的原因\n当Activity或Fragment onDestroy时ViewModel会被datch\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-workmanager/",
	"title": "Jetpack-WorkManager详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件WorkManager详解",
	"content": "谷歌使用Room数据库保存任务及Alarm来保证\nWorkManager是一定会执行的，最小间隔是15min\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/kotlin-%E8%AF%AD%E6%B3%95/",
	"title": "Kotlin语法",
	"tags": ["kotlin", "android"],
	"categories": [],
	"series": ["kotlin"],
	"description": "Kotlin语法",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/renderscript/",
	"title": "renderscript",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B/",
	"title": "写在开始",
	"tags": ["生活"],
	"categories": [],
	"series": ["生活"],
	"description": "写在开始写博客的开始",
	"content": "工作已经很多年，但基本没写过博客。为什么？！！！当然是懒了！！！\n难道工作这么多年就没有想记录或者没有想写的内容吗？当然有！平时把记录的内容都放在了txt文件中。CSDN？当然早就注册了，但总觉得CSDN网站有些潦草。后来，至少是四年前在博客园申请过开博客，当时申请的理由大概是记录生活和学习内容，转载和保存别人的精品文章，结果，emmm\u0026hellip;很明显，被拒绝了，加上懒散，然后很久没有在写文章上花心思了。一晃不知道多久过去了，无意发现简书，支持当时很流行很火的markdown，自己也很想尝试，然后申请了一个账号，才发现写文章真的不是一件很轻松的事\u0026hellip;至少对于我这种先天性缺陷不会组织语言又追求完美的人。然而工作中又有很多东西需要记录，怎么办?于是我把简书当作了草稿箱，只有自己看的明白的杂乱排版，一篇一篇下来也不少了。\n最近准备找工作，写博客当然是加分项，加上自己这个年纪，很多小年轻在上学的时候就开始写了，当然有些唏嘘和忐忑！所以准备再次起航！\n为什么又搭建这个博客而不是继续简书，主要是我觉得简书软文和鸡汤太多，已不如当初，技术氛围已经快丧失完了。就像人：若只如初见！\n当然还有其他技术氛围不错的掘金等，但搭建自己的博客和网站一直是我想做的事，那就干脆就自己搭建一个吧。服务器我已经买，环境也已搭建好，想自己一个一个页面写出来，写了一部分页面，效果并不满意，觉得写页面这事对我还是有点吃力，况且域名还没有备案。于是选择了先在github搭建，比想象简单，两小时通关。\n选择hugo主要是因为是golang写的，虽然搭建又不用写golang ^_-。本人是golang爱好者，在我看来，golang最接近我对编程语言的幻想。\n开始就不会晚！好吧，我承认自己都感觉这话有点虚了，但开始总比没开始好。\n"
},
{
	"uri": "https://dshcao.github.io/zh/series/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-nestedscrolling%E8%A7%A3%E6%9E%90/",
	"title": "Android源码解析-NestedScrolling",
	"tags": ["android", "嵌套", "滑动"],
	"categories": [],
	"series": ["源码解析"],
	"description": "android 嵌套发动NestedScrollingXXX.",
	"content": "嵌套滑动实现原理及执行过程 嵌套滑动其实就是一套嵌套滑动回调。难的是嵌套滑动是如何回调的。理解嵌套滑动应该试着从嵌套滑动API的设计者思考。如果你明白了设计思路就可以很简单的在嵌套滑动回调做相应的处理。\n嵌套原理 我们知道触摸事件被父控件拦截后子控件无法收到后续的事件。同样的如果子控件决定了消费触摸事件父控件的onTouchEvent也无法继续收到后续的触摸事件。嵌套滑动如何实现的呢？答案是通过requestDisallowInterceptTouchEvent(true)请求父控件不要拦截触摸事件，触摸事件传递到子控件并在子控件onTouchEvent中调用startNestedScroll开启整个嵌套滚动。startNestedScroll会检测支持嵌套滚动的父控件并持有该父控件。然后通过嵌套滚动API的回调方法实现子控件和父控件的通信\n执行过程 NestedChild NestedParent\nstartNestedScroll(TYPE_TOUCH) onStartNestedScroll(TYPE_TOUCH)\nonNestedScrollAccepted(TYPE_TOUCH)\ndispatchNestedPreScroll(TYPE_OUCH) onNestedPreScroll(TYPE_TOUCH)\ndispatchNestedScroll(TYPE_TOUCH) onNestedScroll(TYPE_TOUCH)\ndispatchNestedPreFling onNestedPreFling\ndispatchNestedFling onNestedFling\nstartNestedScroll(TYPE_NON_TOUCH) onStartNestedScroll(TYPE_NON_TOUCH)\nonNestedScrollAccepted(TYPE_NON_TOUCH)\nstopNestedScroll(TYPE_TOUCH) onStopNestedScroll(TYPE_NON_TOUCH)\ndispatchNestedPreScroll(TYPE_NON_TOUCH) onNestedPreScroll(TYPE_NON_TOUCH)\ndispatchNestedScroll(TYPE_NON_TOUCH) onNestedScroll(TYPE_NON_TOUCH) stopNestedScroll(TYPE_NON_TOUCH) onStopNestedScroll(TYPE_NON_TOUCH)\n执行顺序从左到右，从上到下\nNestedScrollingChild/NestedScrollingChild2/NestedScrollingChild3 NestedScrollingChild2继承自NestedScrollingChild并重载部分方法。为什么重载？增强实现。NestedScrollingChild3继承自NestedScrollingChild2并重载部分方法进一步增强实现。详情看下面源码解析注释。\n主要方法：\n  setNestedScrollingEnabled\n设置是否配合父控件嵌套滚动，前提是该控件实现相应的嵌套滚动功能。View默认实现和NestedScrollingChildHelper默认实现类似，只是NestedScrollingChildHelper做了兼容处理\n1 2 3 4 5 6 7 8  public void setNestedScrollingEnabled(boolean enabled) { if (enabled) { mPrivateFlags3 |= PFLAG3_NESTED_SCROLLING_ENABLED; } else { stopNestedScroll(); mPrivateFlags3 \u0026amp;= ~PFLAG3_NESTED_SCROLLING_ENABLED; } }   如果是在嵌套滚动中调用setNestedScrollingEnabled禁用了嵌套滚动会主动调用stopNestedScroll()\n  isNestedScrollingEnabled\n返回的是setNestedScrollingEnabled设置的结果\n  hasNestedScrollingParent\n子控件是否有支持嵌套滑动父控件，由于ViewGroup继承了ViewParent，而新的ViewParent支持了嵌套滑动API，实际上就是判断是否有父控件。嵌套滑动父控件的设置是在startNestedScroll执行的时候设置的\n  startNestedScroll\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public boolean startNestedScroll(int axes) { if (hasNestedScrollingParent()) { // Already in progress  return true; } if (isNestedScrollingEnabled()) { ViewParent p = getParent(); View child = this; while (p != null) { try { if (p.onStartNestedScroll(child, this, axes)) { //设置嵌套滑动父控件，mNestedScrollingParent是hasNestedScrollingParent判断的依据  mNestedScrollingParent = p; p.onNestedScrollAccepted(child, this, axes); return true; } } catch (AbstractMethodError e) { Log.e(VIEW_LOG_TAG, \u0026#34;ViewParent \u0026#34; + p + \u0026#34; does not implement interface \u0026#34; + \u0026#34;method onStartNestedScroll\u0026#34;, e); // Allow the search upward to continue  } if (p instanceof View) { child = (View) p; } p = p.getParent(); } } return false; }   子控件发起嵌套滚动动作，触摸模式嵌套滑动通常应该在ACTION_DOWN时调用该方法触发嵌套滚动。如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Override public boolean onTouchEvent(MotionEvent e) { switch (action) { case MotionEvent.ACTION_DOWN: int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE; if (canScrollHorizontally) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL; } if (canScrollVertically) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL; } startNestedScroll(nestedScrollAxis, TYPE_TOUCH); break; ... } }   startNestedScroll源码可知返回true表示找到了支持嵌套滑动的父控件\n  dispatchNestedPreScroll\n分发嵌套滑动事件。在嵌套滑动子控件消费嵌套滑动前调用该方法。View默认实现源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  /** * 控件消费之前调用该方法 * * @param dx 水平方向滚动的像素 * @param dy 垂直方向滚动的像素 * @param consumed 输出参数. 如果不为null, consumed[0] 表示消费的 dx consumed[1] 表示消费的 dy.默认实现这里是被父控件消费 * @param offsetInWindow 可选项. 如果不是 null, 返回的是当前控件在该方法操作前后的视图坐标偏移。使用这个来调整预期的输入坐标跟踪 * @return true 表示父控件消费了部分或全部 */ public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable @Size(2) int[] consumed, @Nullable @Size(2) int[] offsetInWindow) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { if (dx != 0 || dy != 0) { int startX = 0; int startY = 0; if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; } if (consumed == null) { if (mTempNestedScrollConsumed == null) { mTempNestedScrollConsumed = new int[2]; } consumed = mTempNestedScrollConsumed; } consumed[0] = 0; consumed[1] = 0; //调用嵌套父控件处理  mNestedScrollingParent.onNestedPreScroll(this, dx, dy, consumed); if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; } return consumed[0] != 0 || consumed[1] != 0; } else if (offsetInWindow != null) { offsetInWindow[0] = 0; offsetInWindow[1] = 0; } } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。综上即：在嵌套滑动子控件消费嵌套滑动前调用该方法让嵌套滑动父控件先处理。\n  dispatchNestedScroll\n子控件消费后再次向父控件分发嵌套滑动事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /** * 支持嵌套滑动的控件应该调用该方法报告父控件的滑动信息。 * * @param dxConsumed Horizontal distance in pixels consumed by this view during this scroll step * @param dyConsumed Vertical distance in pixels consumed by this view during this scroll step * @param dxUnconsumed Horizontal scroll distance in pixels not consumed by this view * @param dyUnconsumed Horizontal scroll distance in pixels not consumed by this view * @param offsetInWindow Optional. If not null, on return this will contain the offset * in local view coordinates of this view from before this operation * to after it completes. View implementations may use this to adjust * expected input coordinate tracking. * @return true if the event was dispatched, false if it could not be dispatched. * @see #dispatchNestedPreScroll(int, int, int[], int[]) */ public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable @Size(2) int[] offsetInWindow) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { if (dxConsumed != 0 || dyConsumed != 0 || dxUnconsumed != 0 || dyUnconsumed != 0) { int startX = 0; int startY = 0; if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; } mNestedScrollingParent.onNestedScroll(this, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; } return true; } else if (offsetInWindow != null) { // No motion, no dispatch. Keep offsetInWindow up to date.  offsetInWindow[0] = 0; offsetInWindow[1] = 0; } } return false; }     dispatchNestedPreFling\n子控件消费fling事件前向父控件分发fling事件，若父控件消费则子控件将无法再消费。有一定局限性\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * 不同于scroll，如果父控件消费了fling，该控件不应再消费。即要么父控件要么该子控件消费fling。不应该两者都消费 * 为了获得更好的用户体验，嵌套滑动链中一次应该只有一个view消费fling事件。自定义视图实现应该以两种方式考虑这一点： * 1.如果自定义视图是分页的，并且需要固定到一个固定的页面点，请不要调用dispatchNestedPreFling；使用fling并固定到一个有效的位置 * 2.如果嵌套的父级确实消耗了fling，则该视图根本不应该滚动，甚至不应该回到有效的空闲位置 * * 视图也不应该向当前不支持滚动的轴上的嵌套父视图提供滚动速度 * * @param velocityX Horizontal fling velocity in pixels per second * @param velocityY Vertical fling velocity in pixels per second * @return true 嵌套滑动父控件消费了fling */ public boolean dispatchNestedPreFling(float velocityX, float velocityY) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { return mNestedScrollingParent.onNestedPreFling(this, velocityX, velocityY); } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。综上即：在嵌套滑动子控件消费嵌套fling前调用该方法让嵌套滑动父控件先处理。\n  dispatchNestedFling\n若父控件未消费会调用该方法再次向父控件分发fling事件，之后会再此交给子控件处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * 该方法表示达到了fling条件。如：fling速度大于ViewConfiguration#getScaledMinimumFlingVelocity() * * 如果嵌套滑动子控件fling并达到了内容边缘可以使用此方法将fling委托给嵌套滑动父控件消费或观察 * * @param velocityX Horizontal fling velocity in pixels per second * @param velocityY Vertical fling velocity in pixels per second * @param consumed true if the child consumed the fling, false otherwise * @return true if the nested scrolling parent consumed or otherwise reacted to the fling */ public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { return mNestedScrollingParent.onNestedFling(this, velocityX, velocityY, consumed); } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。\n  stopNestedScroll\n停止嵌套滚动\n1 2 3 4 5 6 7 8 9  /** * 嵌套滚动未开始时调用该方法是没有影响的 */ public void stopNestedScroll() { if (mNestedScrollingParent != null) { mNestedScrollingParent.onStopNestedScroll(this); mNestedScrollingParent = null; } }     NestedScrollingChild 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public interface NestedScrollingChild { void setNestedScrollingEnabled(boolean enabled); boolean isNestedScrollingEnabled(); boolean startNestedScroll(@ScrollAxis int axes); void stopNestedScroll(); boolean hasNestedScrollingParent(); boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow); boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow); boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed); boolean dispatchNestedPreFling(float velocityX, float velocityY); }   NestedScrollingChild2 NestedScrollingChild2相比NestedScrollingChild主要增加了fling消费的支持。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public interface NestedScrollingChild2 extends NestedScrollingChild { boolean hasNestedScrollingParent(@NestedScrollType int type); boolean startNestedScroll(@ScrollAxis int axes, @NestedScrollType int type); //当type=ViewCompat.TYPE_NON_TOUCH时，此方法是设计被fling状态时分发  boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow, @NestedScrollType int type); //当type=ViewCompat.TYPE_NON_TOUCH时，此方法是设计被fling状态时分发  boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow, @NestedScrollType int type); void stopNestedScroll(@NestedScrollType int type); }   NestedScrollingChild3 1 2 3 4 5 6  public interface NestedScrollingChild3 extends NestedScrollingChild2 { void dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow, @ViewCompat.NestedScrollType int type, @NonNull int[] consumed); }   NestedScrollingParent/NestedScrollingParent2/NestedScrollingParent3 NestedScrollingParent2继承自NestedScrollingParent并重载部分方法。为什么重载？增强实现。NestedScrollingParent3继承自NestedScrollingParent2并重载部分方法进一步增强实现。详情看下面源码解析注释。\n主要方法：\n  onStartNestedScroll\n该方法被子控件startNestedScroll(int)方法调用的。返回true表示该父控件将在嵌套滚动期间成为支持子控件嵌套滚动的父控件并接受嵌套滑动操作。当嵌套滚动结束后会收到onStopNestedScroll(View)的回调\n1 2 3 4  @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) { return false; }   由上面ViewGroup源码可知默认实现是不会成为嵌套滚动父控件，不接受子控件传递嵌套滑动操作的。一般如果需要支持作为嵌套滑动父控件需要重写此方法。\n1 2 3 4  @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) { return (nestedScrollAxes \u0026amp; View.SCROLL_AXIS_VERTICAL) != 0; }     onNestedScrollAccepted\n此方法将在onStartNestedScroll返回true后调用。它为视图及其超类提供了执行嵌套滚动的初始配置的机会。此方法的实现应始终调用其超类的此方法的实现（如果存在的话）。\n1 2 3 4  @Override public void onNestedScrollAccepted(View child, View target, int axes) { mNestedScrollAxes = axes; }   ViewGroup的默认实现是记录嵌套滚动的方向。\n  getNestedScrollAxes\n1 2 3  public int getNestedScrollAxes() { return mNestedScrollAxes; }     onNestedPreScroll\n目标视图嵌套滚动前调用该方法。因为嵌套滑动父控件可能想在子控件滚动前有机会消费滚动。onNestedPreScroll是在嵌套滑动子控件调用dispatchNestedPreScroll是被调用的。该方法应该报告消费了多少像素。\n1 2 3 4 5 6 7 8 9 10 11  /** * @param target View that initiated the nested scroll * @param dx Horizontal scroll distance in pixels * @param dy Vertical scroll distance in pixels * @param consumed Output. The horizontal and vertical scroll distance consumed by this parent */ @Override public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) { // Re-dispatch up the tree by default  dispatchNestedPreScroll(dx, dy, consumed, null); }     onNestedScroll\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * * 嵌套滑动子控件分发滑动事件时调用此方法。要想调用到该方法之前的onStartNestedScroll必须返回true * 滚动的消费部分和未消费部分都应该通过此方法报告给父控件。如果有未消耗的部分可以在此方法让父控件继续消费 * * @param target The descendent view controlling the nested scroll * @param dxConsumed Horizontal scroll distance in pixels already consumed by target * @param dyConsumed Vertical scroll distance in pixels already consumed by target * @param dxUnconsumed Horizontal scroll distance in pixels not consumed by target * @param dyUnconsumed Vertical scroll distance in pixels not consumed by target */ Override public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) { // Re-dispatch up the tree by default  dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, null); }     onNestedPreFling\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * 目标视图消费fling之前父控件对嵌套滑动的相应 * 该方法被调用表示子控件发起了一个fling事件，通常是滑动速度大于ViewConfiguration#getScaledMinimumFlingVelocity() * * 如果父控件通过onNestedPreScroll消费了部分滑动，那么可能也需要通过onNestedPreFling完成通常的动作 * 返回true表示父控件消费了fling，此时子控件不应滚动内容 * * @param target View that initiated the nested scroll * @param velocityX Horizontal velocity in pixels per second * @param velocityY Vertical velocity in pixels per second * @return true if this parent consumed the fling ahead of the target view */ public boolean onNestedPreFling(View target, float velocityX, float velocityY) { // Re-dispatch up the tree by default  return dispatchNestedPreFling(velocityX, velocityY); }     onNestedFling\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /** * 如果嵌套滑动子控件fling并达到了内容边缘可以使用此方法将fling委托给嵌套滑动父控件消费或观察 * * @param target View that initiated the nested scroll * @param velocityX Horizontal velocity in pixels per second * @param velocityY Vertical velocity in pixels per second * @param consumed true if the child consumed the fling, false otherwise * @return true if this parent consumed or otherwise reacted to the fling */ @Override public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed) { // Re-dispatch up the tree by default  return dispatchNestedFling(velocityX, velocityY, consumed); }     onStopNestedScroll\n对嵌套滚动结束的响应\n1 2 3 4 5 6 7 8 9 10 11 12  /** * 当嵌套滚动停止时，将调用此方法，在嵌套滚动操作之后执行清理。默认实现调用stopNestedScroll()来停止正在进行的任何递归嵌套滚动 * 例如当嵌套触摸滚动以{@link MotionEvent{ACTION_UP}或{@link MotionEvent{ACTION_CANCEL}事件结束时。 * 此方法的实现应始终调用其超类的此方法的实现（如果存在）。 * */ @Override public void onStopNestedScroll(View child) { // Stop any recursive nested scrolling.  stopNestedScroll(); mNestedScrollAxes = 0; }     NestedScrollingParent\u0026amp;ViewParent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public interface NestedScrollingParent { boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes); void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes); void onStopNestedScroll(@NonNull View target); void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed); void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed); boolean onNestedFling(@NonNull View target, float velocityX, float velocityY, boolean consumed); boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY); @ScrollAxis int getNestedScrollAxes(); }   NestedScrollingParent2 NestedScrollingParent2相比NestedScrollingParent主要增加了对fling消费的支持。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public interface NestedScrollingParent2 extends NestedScrollingParent { boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); void onStopNestedScroll(@NonNull View target, @NestedScrollType int type); //当type=ViewCompat.TYPE_NON_TOUCH时，此方法是设计被fling状态时回调的  void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type); //当type=ViewCompat.TYPE_NON_TOUCH时，此方法是设计被fling状态时回调的  void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type); }   NestedScrollingParent3 1 2 3 4 5  public interface NestedScrollingParent3 extends NestedScrollingParent2 { void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @ViewCompat.NestedScrollType int type, @NonNull int[] consumed); }   NestedScrollingChildHelper\u0026amp;NestedScrollingParentHelper 具体看下RecyclerView实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151  @Override public boolean onTouchEvent(MotionEvent e) { switch (action) { case MotionEvent.ACTION_DOWN: break; case MotionEvent.ACTION_MOVE: final int x = (int) (e.getX(index) + 0.5f); final int y = (int) (e.getY(index) + 0.5f); int dx = mLastTouchX - x; int dy = mLastTouchY - y; mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; if (dispatchNestedPreScroll( canScrollHorizontally ? dx : 0, canScrollVertically ? dy : 0, mReusableIntPair, mScrollOffset, TYPE_TOUCH )) { dx -= mReusableIntPair[0]; dy -= mReusableIntPair[1]; // Updated the nested offsets  mNestedOffsets[0] += mScrollOffset[0]; mNestedOffsets[1] += mScrollOffset[1]; // Scroll has initiated, prevent parents from intercepting  getParent().requestDisallowInterceptTouchEvent(true); } mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, mScrollOffset, TYPE_TOUCH, mReusableIntPair); dx -= mReusableIntPair[0] dy -= mReusableIntPair[1] if (consumed[0] != 0 || consumed[1] != 0) { ... parent.requestDisallowInterceptTouchEvent(true) } break; case MotionEvent.ACTION_UP: if (!((xvel != 0 || yvel != 0) \u0026amp;\u0026amp; fling((int) xvel, (int) yvel))) { setScrollState(SCROLL_STATE_IDLE); } stopNestedScroll(TYPE_TOUCH); break; case MotionEvent.ACTION_CANCEL: stopNestedScroll(TYPE_TOUCH); break; } } public boolean fling(int velocityX, int velocityY) { ... //分发Fling事件，若父控件消费，子控件不再消费  if (!dispatchNestedPreFling(velocityX, velocityY)) { final boolean canScroll = canScrollHorizontal || canScrollVertical; //子控件消费之前分发父控件消费  dispatchNestedFling(velocityX, velocityY, canScroll); if (mOnFlingListener != null \u0026amp;\u0026amp; mOnFlingListener.onFling(velocityX, velocityY)) { return true; } if (canScroll) { int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE; if (canScrollHorizontal) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL; } if (canScrollVertical) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL; } //开始fling事件分发前置处理  startNestedScroll(nestedScrollAxis, TYPE_NON_TOUCH); velocityX = Math.max(-mMaxFlingVelocity, Math.min(velocityX, mMaxFlingVelocity)); velocityY = Math.max(-mMaxFlingVelocity, Math.min(velocityY, mMaxFlingVelocity)); mViewFlinger.fling(velocityX, velocityY); return true; } } return false; } class ViewFlinger implements Runnable { ViewFlinger() { mOverScroller = new OverScroller(getContext(), sQuinticInterpolator); } @Override public void run() { stop(); final OverScroller scroller = mOverScroller; if (scroller.computeScrollOffset()) { final int x = scroller.getCurrX(); final int y = scroller.getCurrY(); int unconsumedX = x - mLastFlingX; int unconsumedY = y - mLastFlingY; mLastFlingX = x; mLastFlingY = y; int consumedX = 0; int consumedY = 0; // Nested Pre Scroll  mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; //子控件未消费前分发fling事件询问父控件是否消费  if (dispatchNestedPreScroll(unconsumedX, unconsumedY, mReusableIntPair, null, TYPE_NON_TOUCH)) { unconsumedX -= mReusableIntPair[0]; unconsumedY -= mReusableIntPair[1]; } //子控件消费fling事件  scrollStep(unconsumedX, unconsumedY, mReusableIntPair); consumedX = mReusableIntPair[0]; consumedY = mReusableIntPair[1]; unconsumedX -= consumedX; unconsumedY -= consumedY; mReusableIntPair[0] = 0; mReusableIntPair[1] = 0; //子控件消费完再次分发询问父控件消费fling事件  dispatchNestedScroll(consumedX, consumedY, unconsumedX, unconsumedY, null, TYPE_NON_TOUCH, mReusableIntPair); unconsumedX -= mReusableIntPair[0]; unconsumedY -= mReusableIntPair[1]; if (consumedX != 0 || consumedY != 0) { dispatchOnScrolled(consumedX, consumedY); } ... postOnAnimation(); } mEatRunOnAnimationRequest = false; if (mReSchedulePostAnimationCallback) { internalPostOnAnimation(); } else { setScrollState(SCROLL_STATE_IDLE); //分发结束fling事件  stopNestedScroll(TYPE_NON_TOUCH); } } public void stop() { removeCallbacks(this); mOverScroller.abortAnimation(); } }   由RecyclerView源码可知nestedchild的dispatchNestedPreScroll(TYPE_NON_TOUCH)/dispatchNestedScroll(TYPE_NON_TOUCH)/stopNestedScroll(TYPE_NON_TOUCH)等方法及nestedparent的onNestedPreScroll(TYPE_NON_TOUCH)/onNestedScroll(TYPE_NON_TOUCH)/onStopNestedScroll(TYPE_NON_TOUCH)等方法均是针对fling增加的分发回调方法。因为之前针对fling的事件分发只有dispatchNestedPreFling/dispatchNestedFling及onNestedPreFling/onNestedFling。但这几个方法相对有局限性。比如dispatchNestedPreFling被父控件消费后子控件无法再次消费。dispatchNestedFling是在子控件消费fling事件之前分发给父控件处理，若想子控件处理fling事件后再次交给父控件处理则无能为力了。因此SDK新增了NestedScrollingXXX2，增加type区别touch和fling事件。\n总的来说NestedScrolling相关是SDK提供的一套有一定使用规则的接口api。其使用具体还看实现。具体可以参考文档.\n参考：\n 10分钟带你入门NestedScrolling机制  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%B5%8C%E5%A5%97/",
	"title": "嵌套",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%BB%91%E5%8A%A8/",
	"title": "滑动",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-scroller%E8%A7%A3%E6%9E%90/",
	"title": "Android Scroller解析及应用",
	"tags": ["android", "scroller", "源码解析", "滑动"],
	"categories": [],
	"series": ["源码解析"],
	"description": "Scroller 源码解析",
	"content": "OverScroller简介 OverScroller中两个重要属性：\n mMode有两个滚动模式：SCROLL_MODE FLING_MODE SplineOverScroller\nmState有三个滚动状态：SPLINE CUBIC BALLISTIC，查看源码可知： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void fling(int start, int velocity, int min, int max, int over) { ... if (start \u0026gt; max || start \u0026lt; min) { startAfterEdge(start, min, max, velocity); return; } mState = SPLINE; ... } private void onEdgeReached() { ... mState = BALLISTIC; ... } private void startSpringback(int start, int end, int velocity) { ... mState = CUBIC; ... }     OverScroller API解析   overScroller.setFriction()\nfriction是fling或者scroll时的摩擦系数标量值\n  overScroller.startScroll()\n开始滚动指定的距离，需要调用invalidate()触发重绘\n  overScroller.computeScrollOffset()\n先判断滚动是否结束，结束返回false，否则返回true，并计算出下一次的新位置\n  overScroller.currVelocity\n当前速度\n  overScroller.fling()\n以初始速度velocity滚动，滚动的距离取决于初始速度velocity，当滚动到minX/maxX和minY/maxY范围内时若velocity不为0会根据当前velocity计算滚动的距离和时间，并确保在minX/maxX和minY/maxY范围内为前提再滚动一定距离，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  void fling(int start, int velocity, int min, int max, int over) { mOver = over; mFinished = false; mCurrVelocity = mVelocity = velocity; mDuration = mSplineDuration = 0; mStartTime = AnimationUtils.currentAnimationTimeMillis(); mCurrentPosition = mStart = start; if (start \u0026gt; max || start \u0026lt; min) { startAfterEdge(start, min, max, velocity); return; } mState = SPLINE; double totalDistance = 0.0; if (velocity != 0) { mDuration = mSplineDuration = getSplineFlingDuration(velocity); totalDistance = getSplineFlingDistance(velocity); } mSplineDistance = (int) (totalDistance * Math.signum(velocity)); mFinal = start + mSplineDistance; // Clamp to a valid final position  if (mFinal \u0026lt; min) { adjustDuration(mStart, mFinal, min); mFinal = min; } if (mFinal \u0026gt; max) { adjustDuration(mStart, mFinal, max); mFinal = max; } }     overScroller.abortAnimation()\n停止滚动动画直接将当前位置置为finalX/finalY\n  overScroller.forceFinished()\n停止滚动，停留在当前滚动位置，只是简单将滚动结束标志置为true\n  overScroller.isFinished\n是否结束\n  overScroller.isOverScrolled\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Returns whether the current Scroller is currently returning to a valid position. * Valid bounds were provided by the * {@link #fling(int, int, int, int, int, int, int, int, int, int)} method. * * One should check this value before calling * {@link #startScroll(int, int, int, int)} as the interpolation currently in progress * to restore a valid position will then be stopped. The caller has to take into account * the fact that the started scroll will start from an overscrolled position. * * @return true when the current position is overscrolled and in the process of * interpolating back to a valid value. */ public boolean isOverScrolled() { return ((!mScrollerX.mFinished \u0026amp;\u0026amp; mScrollerX.mState != SplineOverScroller.SPLINE) || (!mScrollerY.mFinished \u0026amp;\u0026amp; mScrollerY.mState != SplineOverScroller.SPLINE)); }     overScroller.notifyHorizontalEdgeReached()\n  overScroller.notifyVerticalEdgeReached()\n  overScroller.springBack() 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public boolean springBack(int startX, int startY, int minX, int maxX, int minY, int maxY){ mMode = FLING_MODE; // Make sure both methods are called.  final boolean spingbackX = mScrollerX.springback(startX, minX, maxX); final boolean spingbackY = mScrollerY.springback(startY, minY, maxY); return spingbackX || spingbackY; } boolean springback(int start, int min, int max) { mFinished = true; ... if (start \u0026lt; min) { startSpringback(start, min, 0); } else if (start \u0026gt; max) { startSpringback(start, max, 0); } return !mFinished; } private void startSpringback(int start, int end, int velocity) { // mStartTime has been set  mFinished = false; }   可以看出，当(minX \u0026lt;= startX \u0026lt;= maxX) || (minY \u0026lt;= startY \u0026lt;= maxY)时返回false，否则返回true。当调用springBack(int startX, int startY, int minX, int maxX, int minY, int maxY)返回true时，调用invalidate()，然后在computeScroll()中调用OverScroller.computeScrollOffset()计算是否结束，而computeScrollOffset()会调用continueWhenFinished()，continueWhenFinished()再次调用startSpringback实现不断刷新\n  OverScroller 使用 通常自定义view中，在构造函数中初始化OverScroller，然后在onTouchEvent()的ACTION_UP中调用OverScroller的startScroll()或fling() 方法并调用invalidate()，然后在view的computeScroll()方法中调用OverScroller的computeScrollOffset()，若返回true，则做相应处理并再次调用invalidate()实现循环处理\nScroll 相关API View方法view.scrollBy()/view.scrollTo()/view.overScrollBy()  view.scrollBy()\n增量滚动，相对当前滚动位置再滚动x/y距离，最终调用scrollTo() 1 2 3  public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); }    view.scrollTo()\n滚动到指定的x/y位置 1 2 3 4 5 6 7 8 9 10 11 12 13  public void scrollTo(int x, int y) { if (mScrollX != x || mScrollY != y) { int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) { postInvalidateOnAnimation(); } } }    view.overScrollBy()\n  computeVerticalScrollOffset/computeVerticalScrollRange/computeVerticalScrollExtent/canScrollVertically 一般来说:computeVerticalScrollRange()=computeVerticalScrollOffset()+computeVerticalScrollExtent()+未显示部分的高度。canScrollVertically利用该算式实现的API\n  computeVerticalScrollOffset\nview垂直方向已滚动的距离，源码：\n1 2 3  protected int computeVerticalScrollOffset() { return mScrollY; }     computeVerticalScrollExtent\n当前view垂直方向上滑块在整个滚动范围代表的长度，其实就是滚动控件显示出来的这部分内容的高度，一般来说整个滚动控件都会用来显示内容，，即默认实现是滚动控件的高度\n1 2 3  protected int computeVerticalScrollExtent() { return getHeight(); }     computeVerticalScrollRange\n垂直滚动条代表的整个滚动范围。如果是View一般代表的是整个内容的高度，非滚动控件则是控件本身的高度。在ViewGroup(如：NestedScrollView)中即其所有子控件的总高度。\nNestedScrollView的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public int computeVerticalScrollRange() { final int count = getChildCount(); final int parentSpace = getHeight() - getPaddingBottom() - getPaddingTop(); if (count == 0) { return parentSpace; } View child = getChildAt(0); NestedScrollView.LayoutParams lp = (LayoutParams) child.getLayoutParams(); int scrollRange = child.getBottom() + lp.bottomMargin; final int scrollY = getScrollY(); final int overscrollBottom = Math.max(0, scrollRange - parentSpace); //如果是overscroll算上overscroll的距离  if (scrollY \u0026lt; 0) { scrollRange -= scrollY; } else if (scrollY \u0026gt; overscrollBottom) { scrollRange += scrollY - overscrollBottom; } return scrollRange; }     canScrollVertically\n是否可以垂直某个方向上滚动，下面源码可以看出是利用上面三个API实现的\n1 2 3 4 5 6 7 8 9 10  public boolean canScrollVertically(int direction) { final int offset = computeVerticalScrollOffset(); final int range = computeVerticalScrollRange() - computeVerticalScrollExtent(); if (range == 0) return false; if (direction \u0026lt; 0) { return offset \u0026gt; 0; } else { return offset \u0026lt; range - 1; } }     VelocityTracker  VelocityTracker\n跟踪触摸事件的速度，实现fling和类似手势的助手类。通常的使用如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @Override public boolean onTouchEvent(MotionEvent event) { int action = event.getActionMasked(); switch (action) { case MotionEvent.ACTION_DOWN: if (velocityTracker == null) { velocityTracker = VelocityTracker.obtain(); } else { velocityTracker.clear(); } break; case MotionEvent.ACTION_MOVE: velocityTracker.addMovement(event); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: velocityTracker.computeCurrentVelocity(1000); float velocity = velocityTracker.getYVelocity(); //todo  if (velocityTracker != null) { velocityTracker.recycle(); velocityTracker = null; } break; } return super.onTouchEvent(event); }    computeCurrentVelocity\n基于addMovement收集的触摸点计算当前速度，调用getYVelocity/getYVelocity获取速度前必须先调用这个方法    view.offsetLeftAndRight()/view.offsetTopAndBottom() 自定义 参考：\n 使用Fling动画移动视图 以动画方式显示滚动手势  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/scroller/",
	"title": "scroller",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/dir/fourth/",
	"title": "Fourth",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My fourth presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/",
	"title": "展厅",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Presentation list with reveal.js",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/third/",
	"title": "Third",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My third presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/second/",
	"title": "Second",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My second presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/first/",
	"title": "First",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My first presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/archive/",
	"title": "存档",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Archive Page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-wms/",
	"title": "Android AMS",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android AMS源码解析",
	"content": "前言 WMS和AMS一样运行在SystemServer进程中。WMS控制所有Window的显示、隐藏以及显示的位置。\nWindowManager\u0026amp;PhoneWindowManager\u0026amp;WindowManagerService 两者关系和ActivityManager和ActivityManagerService一样的。\nWindowManager WindowManager继承自ViewManager,是用来管理Android中Window的，包括Window的创建。\nViewManager接口定义很简单\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public interface ViewManager { /** * Assign the passed LayoutParams to the passed View and add the view to the window. * \u0026lt;p\u0026gt;Throws {@link android.view.WindowManager.BadTokenException} for certain programming * errors, such as adding a second view to a window without removing the first view. * \u0026lt;p\u0026gt;Throws {@link android.view.WindowManager.InvalidDisplayException} if the window is on a * secondary {@link Display} and the specified display can\u0026#39;t be found * (see {@link android.app.Presentation}). * @param view The view to be added to this window. * @param params The LayoutParams to assign to view. */ public void addView(View view, ViewGroup.LayoutParams params); public void updateViewLayout(View view, ViewGroup.LayoutParams params); public void removeView(View view); } public interface WindowManager extends ViewManager { ... }   WindowManager的LayoutParams中有有一组以TYPE开头的常量TYPE_XXX_XXX定义了窗口的类型。\nWindow窗口分三类：\n 应用窗口(1~99) 位于视图最下层，一个应用窗口对应一个Activity 子窗口(1000~1999) 需要依附于其他窗口，不能单独存在 系统窗口(2000~2999) 位于视图最上层。需要申请系统权限  WindowManager的LayoutParams中有有一组以FLAG开头的常量TYPE_XXX_XXX定义了窗口的类型。\n FLAG_NOT_FOCUSABLE FLAG_NOT_TOUCH_MODAL FLAG_SHOW_WHEN_LOCKED  WindowManager的LayoutParams中有有一组以SOFT_INPUT开头的常量SOFT_INPUT_XXX_XXX定义了窗口的类型。\nPhoneWindowManager 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143  /** * Constants for interfacing with WindowManagerService and WindowManagerPolicyInternal. * @hide */ public interface WindowManagerPolicyConstants { // Policy flags. These flags are also defined in frameworks/base/include/ui/Input.h.  int FLAG_WAKE = 0x00000001; int FLAG_VIRTUAL = 0x00000002; int FLAG_INJECTED = 0x01000000; int FLAG_TRUSTED = 0x02000000; int FLAG_FILTERED = 0x04000000; int FLAG_DISABLE_KEY_REPEAT = 0x08000000; int FLAG_INTERACTIVE = 0x20000000; int FLAG_PASS_TO_USER = 0x40000000; // Flags for IActivityManager.keyguardGoingAway()  int KEYGUARD_GOING_AWAY_FLAG_TO_SHADE = 1 \u0026lt;\u0026lt; 0; int KEYGUARD_GOING_AWAY_FLAG_NO_WINDOW_ANIMATIONS = 1 \u0026lt;\u0026lt; 1; int KEYGUARD_GOING_AWAY_FLAG_WITH_WALLPAPER = 1 \u0026lt;\u0026lt; 2; // Flags used for indicating whether the internal and/or external input devices  // of some type are available.  int PRESENCE_INTERNAL = 1 \u0026lt;\u0026lt; 0; int PRESENCE_EXTERNAL = 1 \u0026lt;\u0026lt; 1; // Navigation bar position values  int NAV_BAR_INVALID = -1; int NAV_BAR_LEFT = 1 \u0026lt;\u0026lt; 0; int NAV_BAR_RIGHT = 1 \u0026lt;\u0026lt; 1; int NAV_BAR_BOTTOM = 1 \u0026lt;\u0026lt; 2; // Navigation bar interaction modes  int NAV_BAR_MODE_3BUTTON = 0; int NAV_BAR_MODE_2BUTTON = 1; int NAV_BAR_MODE_GESTURAL = 2; // Associated overlays for each nav bar mode  String NAV_BAR_MODE_3BUTTON_OVERLAY = \u0026#34;com.android.internal.systemui.navbar.threebutton\u0026#34;; String NAV_BAR_MODE_2BUTTON_OVERLAY = \u0026#34;com.android.internal.systemui.navbar.twobutton\u0026#34;; String NAV_BAR_MODE_GESTURAL_OVERLAY = \u0026#34;com.android.internal.systemui.navbar.gestural\u0026#34;; /** * Broadcast sent when a user activity is detected. */ String ACTION_USER_ACTIVITY_NOTIFICATION = \u0026#34;android.intent.action.USER_ACTIVITY_NOTIFICATION\u0026#34;; /** * Sticky broadcast of the current HDMI plugged state. */ String ACTION_HDMI_PLUGGED = \u0026#34;android.intent.action.HDMI_PLUGGED\u0026#34;; /** * Extra in {@link #ACTION_HDMI_PLUGGED} indicating the state: true if * plugged in to HDMI, false if not. */ String EXTRA_HDMI_PLUGGED_STATE = \u0026#34;state\u0026#34;; /** * Set to {@code true} when intent was invoked from pressing the home key. * @hide */ String EXTRA_FROM_HOME_KEY = \u0026#34;android.intent.extra.FROM_HOME_KEY\u0026#34;; // TODO: move this to a more appropriate place.  interface PointerEventListener { /** * 1. onPointerEvent will be called on the service.UiThread. * 2. motionEvent will be recycled after onPointerEvent returns so if it is needed later a * copy() must be made and the copy must be recycled. **/ void onPointerEvent(MotionEvent motionEvent); } /** Screen turned off because of a device admin */ int OFF_BECAUSE_OF_ADMIN = 1; /** Screen turned off because of power button */ int OFF_BECAUSE_OF_USER = 2; /** Screen turned off because of timeout */ int OFF_BECAUSE_OF_TIMEOUT = 3; @IntDef(prefix = { \u0026#34;ON_BECAUSE_OF_\u0026#34; }, value = { ON_BECAUSE_OF_USER, ON_BECAUSE_OF_APPLICATION, ON_BECAUSE_OF_UNKNOWN, }) @Retention(RetentionPolicy.SOURCE) public @interface OnReason{} /** Convert the on reason to a human readable format */ static String onReasonToString(@OnReason int why) { switch (why) { case ON_BECAUSE_OF_USER: return \u0026#34;ON_BECAUSE_OF_USER\u0026#34;; case ON_BECAUSE_OF_APPLICATION: return \u0026#34;ON_BECAUSE_OF_APPLICATION\u0026#34;; case ON_BECAUSE_OF_UNKNOWN: return \u0026#34;ON_BECAUSE_OF_UNKNOWN\u0026#34;; default: return Integer.toString(why); } } /** Screen turned on because of a user-initiated action. */ int ON_BECAUSE_OF_USER = 1; /** Screen turned on because of an application request or event */ int ON_BECAUSE_OF_APPLICATION = 2; /** Screen turned on for an unknown reason */ int ON_BECAUSE_OF_UNKNOWN = 3; int APPLICATION_LAYER = 2; int APPLICATION_MEDIA_SUBLAYER = -2; int APPLICATION_MEDIA_OVERLAY_SUBLAYER = -1; int APPLICATION_PANEL_SUBLAYER = 1; int APPLICATION_SUB_PANEL_SUBLAYER = 2; int APPLICATION_ABOVE_SUB_PANEL_SUBLAYER = 3; /** * Convert the off reason to a human readable format. */ static String offReasonToString(int why) { switch (why) { case OFF_BECAUSE_OF_ADMIN: return \u0026#34;OFF_BECAUSE_OF_ADMIN\u0026#34;; case OFF_BECAUSE_OF_USER: return \u0026#34;OFF_BECAUSE_OF_USER\u0026#34;; case OFF_BECAUSE_OF_TIMEOUT: return \u0026#34;OFF_BECAUSE_OF_TIMEOUT\u0026#34;; default: return Integer.toString(why); } } } public interface WindowManagerPolicy extends WindowManagerPolicyConstants { ... } public class PhoneWindowManager implements WindowManagerPolicy { ... }   WindowManagerService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144  public interface Monitor { void monitor(); } public interface WindowManagerFuncs { public static final int LID_ABSENT = -1; public static final int LID_CLOSED = 0; public static final int LID_OPEN = 1; public static final int LID_BEHAVIOR_NONE = 0; public static final int LID_BEHAVIOR_SLEEP = 1; public static final int LID_BEHAVIOR_LOCK = 2; public static final int CAMERA_LENS_COVER_ABSENT = -1; public static final int CAMERA_LENS_UNCOVERED = 0; public static final int CAMERA_LENS_COVERED = 1; /** * Add a input consumer which will consume all input events going to any window below it. */ public InputConsumer createInputConsumer(Looper looper, String name, InputEventReceiver.Factory inputEventReceiverFactory, int displayId); /** * Returns a code that describes the current state of the lid switch. */ public int getLidState(); /** * Lock the device now. */ public void lockDeviceNow(); /** * Returns a code that descripbes whether the camera lens is covered or not. */ public int getCameraLensCoverState(); /** * Switch the keyboard layout for the given device. * Direction should be +1 or -1 to go to the next or previous keyboard layout. */ public void switchKeyboardLayout(int deviceId, int direction); public void shutdown(boolean confirm); public void reboot(boolean confirm); public void rebootSafeMode(boolean confirm); /** * Return the window manager lock needed to correctly call \u0026#34;Lw\u0026#34; methods. */ public Object getWindowManagerLock(); /** Register a system listener for touch events */ void registerPointerEventListener(PointerEventListener listener, int displayId); /** Unregister a system listener for touch events */ void unregisterPointerEventListener(PointerEventListener listener, int displayId); /** * Retrieves the {@param outBounds} from the stack matching the {@param windowingMode} and * {@param activityType}. */ void getStackBounds(int windowingMode, int activityType, Rect outBounds); /** * @return The currently active input method window. */ WindowState getInputMethodWindowLw(); /** * Notifies window manager that {@link #isKeyguardTrustedLw} has changed. */ void notifyKeyguardTrustedChanged(); /** * Notifies the window manager that screen is being turned off. * * @param listener callback to call when display can be turned off */ void screenTurningOff(ScreenOffListener listener); /** * Convert the lid state to a human readable format. */ static String lidStateToString(int lid) { switch (lid) { case LID_ABSENT: return \u0026#34;LID_ABSENT\u0026#34;; case LID_CLOSED: return \u0026#34;LID_CLOSED\u0026#34;; case LID_OPEN: return \u0026#34;LID_OPEN\u0026#34;; default: return Integer.toString(lid); } } /** * Convert the camera lens state to a human readable format. */ static String cameraLensStateToString(int lens) { switch (lens) { case CAMERA_LENS_COVER_ABSENT: return \u0026#34;CAMERA_LENS_COVER_ABSENT\u0026#34;; case CAMERA_LENS_UNCOVERED: return \u0026#34;CAMERA_LENS_UNCOVERED\u0026#34;; case CAMERA_LENS_COVERED: return \u0026#34;CAMERA_LENS_COVERED\u0026#34;; default: return Integer.toString(lens); } } /** * Hint to window manager that the user has started a navigation action that should * abort animations that have no timeout, in case they got stuck. */ void triggerAnimationFailsafe(); /** * The keyguard showing state has changed */ void onKeyguardShowingAndNotOccludedChanged(); /** * Notifies window manager that power key is being pressed. */ void onPowerKeyDown(boolean isScreenOn); /** * Notifies window manager that user is switched. */ void onUserSwitched(); /** * Hint to window manager that the user is interacting with a display that should be treated * as the top display. */ void moveDisplayToTop(int displayId); } public class WindowManagerService extends IWindowManager.Stub mplements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs { }   Window\u0026amp;PhoneWindow WindowManager\u0026amp;PhoneWindowManager "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app-bundle/",
	"title": "Android AppBundle",
	"tags": ["android", "AppBundle"],
	"categories": [],
	"series": ["android"],
	"description": "Android AppBundle",
	"content": "ClassLoader,java的ClassLoader双亲委托机制 干预Android加载，既然要干预那就要首先了解其原加载过程 ## 双亲委托 简单说类加载器的双亲委托就是在当前类加载器加载某个类之前先逐级向上询问父类加载器是否已加载过(是否已有类的缓存)，如果已加载就返回，如果未加载则有当前类加载器加载该类。你可能会问ClassLoader本身也是一个类，它是怎么被加载的呢？在jvm启动的时候就有一个根ClassLoader,即：bootstrapclassloader\n设计双亲委托模式的好处： 1.避免重复加载 2.安全，避免核心api被修改 ## PathClassLoader和DexClassLoader源码分析 要做热更新就要用`ClassLoader`加载hotfix dex中的类,用哪个`ClassLoader`呢？我们在Activity中打印`classLoader::class.java.name`可以看到是`dalvik.system.PathClassLoader` 查看`PathClassLoader` ``` java public PathClassLoader(String dexPath, ClassLoader parent) { super(dexPath, null, null, parent); } public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) { super(dexPath, null, librarySearchPath, parent); } ``` 只有几个构造方法，但`PathClassLoader`继承自`BaseDexClassLoader`，继续进入`BaseDexClassLoader`查看 ``` java protected Class loadClass(String name, boolean resolve) throws ClassNotFoundException { // 首先检查是否已经加载过 Class c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //parent.loadClass可鞥在此抛出异常 } if (c == null) { c = findClass(name); } } return c; } ``` `loadClass`首先检查是不是已加载过这个类，若没有，调用父ClassLoader的`loadClass`，以此上推检查父ClassLoader是否加载过此类，若都没有加载则调用`findClass` ``` java @Override protected Class findClass(String name) throws ClassNotFoundException { // First, check whether the class is present in our shared libraries. if (sharedLibraryLoaders != null) { for (ClassLoader loader : sharedLibraryLoaders) { try { return loader.loadClass(name); } catch (ClassNotFoundException ignored) { } } } // Check whether the class in question is present in the dexPath that // this classloader operates on. List suppressedExceptions = new ArrayList(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( \"Didn't find class \\\"\" + name + \"\\\" on path: \" + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; } ``` 最终执行到`Class c = pathList.findClass(name, suppressedExceptions);`，再继续查看`DexPathList`的`findClass`方法 ``` java public Class findClass(String name, List suppressed) { for (Element element : dexElements) { Class clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; } ``` 再继续进入`Element`的`findClass`方法 ``` java public Class findClass(String name, ClassLoader definingContext,List suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed): null; } ``` 参考： [Android N混合编译与对热补丁影响解析](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==\u0026mid=2649286341\u0026idx=1\u0026sn=054d595af6e824cbe4edd79427fc2706\u0026scene=0%23wechat_redirect)\n[安卓App热补丁动态修复技术介绍](https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==\u0026mid=400118620\u0026idx=1\u0026sn=b4fdd5055731290eef12ad0d17f39d4a) --  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app%E4%BC%98%E5%8C%96-apk%E7%98%A6%E8%BA%AB/",
	"title": "Android App优化-Apk瘦身",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android App优化",
	"content": "APK体积优化 svg/vector替换套图小图标 使用SVG替代简单的小图标及图标套图\nSVG：可缩放矢量图，不会因为缩放导致图片质量下降。常用于小图标。SVG由XML定义，标准根结点为\u0026lt;svg\u0026gt;。但Android只支持\u0026lt;vector\u0026gt;，我们可以通过vector将svg的根节点\u0026lt;svg\u0026gt;转换成\u0026lt;vector\u0026gt;。\n相对于jpeg/png更消耗GPU，svg则更消耗CPU，所以svg只适合替换小图标。尽量不应该大于200dp。\n另外SVG有一些不支持的功能：\n 滤镜效果\n不支持投影、模糊和颜色矩阵等效果 文本\n建议用其他工具转换成形状\n不过不用担心，转换过程中不支持的话会有报错的。\n如果需要批量svg转vector可以使用第三方工具：svg2vector，命令行：java -jar svg2vector.jar -d svg目录 -o vector目录 -h 20 -w 20，h/w代表输出宽高(dp)。\nAndroid5.0以前并不支持svg，所以打包时会自动在每个drawable-xxxx转换成图片，这反而会增大Apk体积。可以在Module配置  android { ... defaultConfig { ... vectorDrawables.useSupportLibrary = true } ... } 另外appcompat版本需要大于23.2.0，以上配置后在ImageView需要使用android:srcCompat替代android:src来设置图片。\nSVG的颜色修改方式：\n vectorDrawable的xml中直接修改，但这种方式在多种颜色的套图图标中需要多个xml 在ImageView中使用tint修改颜色，backgroundTint修改背景色。这样就只需要一个xml，如果想按压等状态变色只需要给tint设置为selector  移除无用资源 Analyze-\u0026gt;Run Inspection by Name 输入unused resources AS分析后会列出没有使用的资源，有些资源可能是反射使用到了，所以这里可以选择不删除。\n国际化配置 android { ... defaultConfig { ... resConfigs \u0026quot;en\u0026quot; } ... } 如果不配置支持库会帮我们国际化多个文件夹资源。\nso动态库 so算是个大头，很多第三方的so库还是很大的。只使用armeabi-v7a即可。配置：\nandroid { ... defaultConfig { ... ndk { abiFilters 'armeabi-v7a' } externalNativeBuild { cmake { abiFilters 'armeabi-v7a' } } } ... } 压缩代码/压缩资源 minifyEnabled true 压缩代码，minifyEnabled不只是混淆代码，也是代码压缩\nshrinkResources true 压缩资源，所有未被使用的资源会被移除。shrinkResources是协同minifyEnabled工作的，只开启shrinkResources是没有用的。\n配置如下：\nbuildTypes { release { shrinkResources true minifyEnabled true proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro' } } 默认情况下是没有开启严格模式，什么是非严格模式呢？比如我们项目中用到了activity_main.xml，那么activity_main12.xml就算没有被使用到不会被删除。可以在res/raw下新建keep.xml\ntools:keep 定义哪些资源需要被保留（资源之间用“,”隔开）\ntools:discard 定义哪些资源需要被移除（资源之间用“,”隔开）\ntools:shrinkMode 开启严格模式\n1 2 3 4 5 6 7  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;resources xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; tools:shrinkMode=\u0026#34;strict\u0026#34; tools:keep=\u0026#34;@layout/keep_xxxx,@layout/keep_yyy\u0026#34; tools:discard=\u0026#34;@layout/discard_xxxx\u0026#34;\u0026gt; \u0026lt;/resources\u0026gt;   混淆资源 R文件中资源的整型数格式为：0xpptteeee（16进制，p代表的是package，t代表的是type，e代表的是entry）。\n Package ID 包ID，系统为0x01，应用程序资源为0x7f。 Type ID 资源的类型ID，资源的类型有animator、anim、color等等，每一种都会被赋予一个ID。 Entry ID 资源在其所属的资源类型中所出现的次序。\n微信开源资源混淆：AndResGuard  使用tinypng压缩图片 使用webp替换png/jpeg webp是谷歌开发的图片数据格式，派生自图像编码格式VP8。\nAndroid 4.0 支持有损压缩的WebP格式，Android 4.3开始支持无损透明WebP图像。webp的缺点是加载会比png/jpeg慢一些\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app%E4%BC%98%E5%8C%96-%E5%AD%98%E5%82%A8%E4%BC%98%E5%8C%96/",
	"title": "Android App优化-存储优化",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android App优化-存储优化",
	"content": "Protobuf 7zip 微信开源MMKV 参考：\n GitHub battery-historian googleprotobuf  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app%E4%BC%98%E5%8C%96-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/",
	"title": "Android App优化-安装包优化",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android App优化",
	"content": "前言 既然是性能优化，首先明确优化的方向在哪。\n在Android App中首先最重要的是不能Crash，不能ANR，其次不能卡顿，再其次是耗电，再其次是Apk包大小。这一篇我们聊聊Crash、ANR和卡顿的优化问题。\nANR(Application Not Responding) ANR定义 ANR(Application Not Responding)\n在Android系统中，ANR是四大组件的超时引起的：\n Service 超时引起的ANR\n前台Service：SERVICE_TIMEOUT = 20s\n后台Service：SERVICE_BACKGROUND_TIMEOUT = 200s BroadcastReceiver 超时引起的ANR\n前台广播：BROADCAST_FG_TIMEOUT = 10s\n后台广播：BROADCAST_BG_TIMEOUT = 60s ContentProvider 超时引起的ANR\nCONTENT_PROVIDER_PUBLISH_TIMEOUT = 10s Activity界面交互中InputDispatching 输入事件超时引起的ANR 输入事件包括按键和触摸事件在分发时超过超过5s即判定为ANR，输入事件超时引起的ANR和其它稍有不同，对于输入事件即便执行超过5s只要用户后续没有再产生输入事件就不会产生ANR。  从上面可以看出ANR也分前台ANR和后台ANR：\n前台ANR用户能感知，比如拥有前台可见的activity的进程，或者拥 有前台通知的fg-service的进程，此时发生ANR对用户体验影响比较 大，需要弹框让用户决定是否退出还是等待\n后台ANR只抓取发生无响应进程的trace，也不会收集CPU信息， 并且会在后台直接杀掉该无响应的进程，不会弹框提示用户\n 对于Service当超过一定时间未执行相应操作来触发移除延时消息就会出发ANR 对于BroadcastReceiver，有序广播的总执行时间超过 2 * receiver个数 * timeout时间 触发ANR，有序广播某一个receiver执行过程超过timeout时长出发ANR。 对于ContentProvider在进程启动时publish过程可能产生的ANR，系统会直接kill进程并清理相应信息而不会弹出ANR对话框。 对于Service、BroadcastReceiver,、输入事件发生ANR之后，最终都会调用 AMS.appNotResponding;  ANR执行流程 1.发生ANR -\u0026gt; 2.进程接收异常终止信号，开始写入进程ANR信息 -\u0026gt; 3.弹出ANR提示框(不同厂商Rom表现不一)\nANR分析 traces文件和CPU使用情况信息保存到dropbox，即data/system/dropbox目录data/anr/traces.txt\n分析是否有耗时的message,binder调用，锁的竞争，CPU资源的抢占\n当发生ANR时可以在Logcat中输入ActivityManager Tag过滤错误信息，在最后通常有一行：\n14% TOTAL: 13% user + 0.6% kernel\nuser表示用户占用CPU，kernel表示内核占用的CPU，有时可能还有0.2% iowait，iowait表示I/O操作。\ntraces.txt分析 如何避免ANR发生  主线程尽量只做UI相关的操作,避免耗时操作，比如过度复杂的UI绘 制，网络操作，文件IO操作; 避免主线程跟工作线程发生锁的竞争，减少系统耗时binder的调用， 谨慎使用sharePreference，注意主线程执行provider query操作  ANR优化方案 ANR解决套路\n adb pull data/anr/traces.txt 详细分析原因：CPU、I/O、锁  线上ANR方案：\n通过FileOberver监控文本变化，但高版本有权限问题，监控不到\n我们可以使用ANR-WatchDog监控组件\nANR-WatchDog原理及实战\n 非侵入式的ANR监控组件  Crash优化 Crash的原因大概有几种：内存溢出、代码编写问题、WebView问题。\n内存溢出 导致内存溢出的原因又很多方面，如：\n 内存抖动 内存泄漏 加载大内存对象 如加载未处理过的大图。  内存抖动 频繁创建对象导致GC频繁的一种内存现象。当创建对象过于频繁，GC不及时时可能会导致内存溢出。\n为了防止内存抖动，应注意：\n 避免循环中创建对象 避免循环调用的方法(onDraw)中创建对象 允许复用的情况下使用对象池进行缓存，比如：Handler的message单链表(obtain)  内存泄漏  集合问题 使用集合时只有添加没有删除元素，比如EventBus 静态成员/单例 作为GCRoot持有短生命周期对象(如：Activity)导致其无法释放 未关闭释放资源 如FileOutputStream未close 非静态内部类 如Handler postDelay一个匿名Runnable，退出Activity时消息没有处理完。 系统Bug WebView、InputMethodManager  卡顿优化 卡顿大概有两种原因：内存抖动和消息堵塞\n卡顿单点问题监测方案\n 自动化卡顿方案并不能满足所有场景要求 体系化的监测方案提前暴漏问题 单点问题：主线程IPC、DB  Application onCreate并非只调用一次，这和你的app有多少进程有关，android中四大组件都是可以设置单独进程的，如果有三个进程就会被调用三次，所以onCreate的初始化需要判断是否是主进程\nSparseArray性能高的原理\nres下图片文件的大小和Android加载到内存成为bitmap对象大小是两码事\nres下图片文件的大小指的是以某种格式压缩后的大小。\n加载到内存成为bitmap的大小只和图片的图片的宽高和格式(ARGB888或RGB565等)有关。\n一个是解码前的文件，一个是解码后的bitmap对象，同样的bitmap对象经过不同算法压缩大小肯定不一样。\n同样的图片，放在drawable-hdpi和放在drawable-xxhdpi下加载到内存是不一样的。如果手机像素密度匹配drawable-xxhdpi，如果drawable-xxhdpi没有相应的图片，Andrid会加载drawable-hdpi中相应的图片，但会相应进行缩放。比如drawable-hdpi图片是ARGB-110x132，而手机匹配的是drawable-xxhdpi，Android会将图片是放大，比如：ARGB_8888-960x720\u0026ndash;\u0026gt;ARGB_8888-1920x1440，即加载到内存的bitmap对象所占内存会相应放大，占用更多内存。\nBitmapFactory.Options\noutWidth:\n位图的结果宽度。\n如果injustdecodebunds设置为false，则这将是应用任何缩放后输出位图的宽度。\n如果为true，它将是输入图像的宽度，而不考虑缩放。\nhprof-conv -z in.hprof out.hprof\n性能优化中的常见问题 Crash ANR也算是Crash。\nJava层Crash Java层Crash是Java代码出现未捕获的异常导致程序崩溃\nNative层Crash Native层Crash一般是Native代码中访问了非法地址，也可能是地址对齐问题或者程序主动Abort，这些都会产生相应的Signal信号导致程序异常退出。\n如何收集线上异常信息 大公司一般都会做自己的这部分功能，中小公司则可以使用第三方的服务，比如：阿里的友盟、腾讯的Bugly、网易的云捕、Google的Firebase等。\n冷启动 clickevent-IPC-Process.start-ActivityThread\n1.启动app-2.加载空白window-3.创建进程-4.创建Application-5.启动祝线程-6.创建MainActivity-7.加载布局-8.布置屏幕-9.首帧绘制\n123 是系统行为无法干预\nApp启动主要经过如下几个流程\nLaunch the process.\nInitialize the objects.\nCreate and initialize the activity.\nInflate the layout.\nDraw your application for the first time.\n在performResumeActivity 中进行了onResume的回调，在wm.addView 中进行了绘制，因此onResume的方法是在绘制之前，在onResume中做一些耗时操作都会影响启动时间。\n热启动 温启动 启动优化 优化Application和Activity的生命周期，避免耗时操作\n启动时间测量：\n  adb命令\nam start -W com.osshare.dsh/.ui.MainActivity thistime:最后一个Activity启动耗时\ntotaltime:所有Activity启动耗时\nwaittime: AMS启动Activity的总耗时\n另外执行adb logcat -s ActivityManager | grep \u0026ldquo;Displayed\u0026quot;也可以查看启动Activity的时间\nadb命令方式并非严谨和精确的时间\n  手动打点\n启动开始/结束埋点\nonWindowsFocusChanged 首帧时间/首次绘制时间，我们结束埋点应该是真实数据展示\n所以我们埋点开始应是attachBaseContext我们能接受到的最早回调\n结束点应该是viewTreeObserver.addOnDrawListener\n手动埋点的启动时间更精确严谨\n  知道总时间还要知道所有方法消耗的时间\n常规方式：手动埋点 1.侵入性强 2.工作量大\nAOP:针对同一类问题的同意处理，无侵入性\nJoinPoints 函数运行时的执行点，可以作为切面的地方，如函数调用，执行，获取设置变量，类初始化\nPointCut 带条件的JoinPoints\nAdvice 一种hook，要插入代码的地方 Before: PointCut之前执行 After:PointCut之后执行 Arund:PointCut之前之后执行\n  具体优化：\n设置AppTheme.Launcher\n1 2 3  \u0026lt;style name=\u0026#34;AppTheme.Launcher\u0026#34;\u0026gt; \u0026lt;item name=\u0026#34;android:windowBackground\u0026#34;\u0026gt;@drawable/img_launcher\u0026lt;/item\u0026gt; \u0026lt;/style\u0026gt;   设置drawable\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;layer-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:opacity=\u0026#34;opaque\u0026#34;\u0026gt; \u0026lt;item android:drawable=\u0026#34;@color/white\u0026#34; /\u0026gt; \u0026lt;item\u0026gt; \u0026lt;bitmap android:gravity=\u0026#34;center\u0026#34; android:src=\u0026#34;@drawable/bitmap\u0026#34; /\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/layer-list\u0026gt;   AndroidManifest中splashActivity设置theme为AppTheme.Launcher\n但需要注意这里需要在splashActivity的super.onCreate(savedInstanceState)之前设置会我们真正的AppTheme\n常规启动异步优化 子线程分担主线程任务，并行减少时间\n 不符合异步要求\n创造满足异步要求的条件或者放弃异步优化 需要在某个阶段完成\n实际过程中可能有些必须放主线程完成或者说后面Activity马上要用到。我们可以使用CountDownLatch。仍然把初始化任务放在子线程，但是CountDownLatch计数，在oncreate结束位置latch.await()等待计数归0 区分cpu密集型任务和i/o密集型任务  加强启动异步优化 常规异步优化代码不优雅，依赖关系不好处理，维护成本高\n可以编写一个启动器，每一个初始化是一个任务，任务中标明依赖任务和是主线程执行还是可以异步线程执行，然后拓扑排序任务成一个有向无环图，按照顺序执行\n另外还可以使用IdleHandler\ntraceview使用 Debug.startMethodTracing\nDebug.stopMethodTracing(\u0026ldquo;filename\u0026rdquo;)\n文件在Android/data/package/filename.trace\n CallChart\n系统API 是橙色\n系统第三方api是蓝色\n开发者或引用的第三方lib是绿色 Top Down\n方法执行时间\ntotal = self + children Wall Clock Time 代码执行时间 Thread Time 线程/cpu执行时间  缺点：\ntraceview运行时开销严重，整体会变慢，带偏我们优化方向\nsystrace 可以结合Android内核数据生成html报告\napi18可用，可以使用TraceCompat\n使用方式\n代码加入\nTraceCompat.beginSection(\u0026quot;\u0026quot;)\nTraceCompat.endSection()\n执行命令\n命令python systrace.py -t -10 [option] [categories]\nwalltime 代码执行时间\ncputime 代码消耗cpu时间\n我们重点优化的应该是cputime，提高cpu利用率，即cputime\n比如：多线程锁冲突\nsystrace开销小，直观反应cpu利用率\n启动优化总方针 异步 延迟 懒加载\n另外可以在attachBaseContext中返回application 不用其他地方再获取直接使用\n提前异步加载sp\n启动阶段不启动子进程\n 子进程会共享cpu资源，导致主进程cpu紧张 注意启动顺序，app onCreate之前是ContentProvider 类加载优化 提前异步类加载 因为类加载有校验和优化的过程  Class.forName()只会加载类本身及其静态变量的引用类 new实例，可以额外加载类成员变量 如何判断类需要提前加载 替换系统classloader,在loadclass打log    启动阶段抑制gc\ncpu锁频 拉升cpu频率，做更多的事，因为系统可能只在启动是锁屏很短的时间我们可以延长这个时间 但会消耗更多电量\n内存优化 内存抖动 锯齿装、gc导致卡顿\n内存泄漏 可用内存减少，频繁gc\n内存溢出 oom 程序异常\n工具 Memory Profile /Memory Analyzer /LeakCanary\nMemory Profile\n方便直观\n线下使用\nMemory Analyzer\n强大的java heap分析工具，查找内存泄漏及内存占用\n生成整体报告，分析问题等\n线下深入使用\nLeakCanary\n自动内存泄漏检测\n线下集成，线上会导致消耗内存增加\nJava内存分配\n方法区 类信息 静态变量 所有线程共享\n虚拟机栈 为java变量和堆中对象的引用\n本地方法栈 为native方法服务的\n堆： 所有线程共享，存放对象\n程序计数器：记录程序运行到第几行\njava内存回收算法\n 标记清除算法\n标记所有要清除的对象\n同一回收所有被标记的对象 复制算法\n实现简单运行高效\n浪费一半空间，代价大 标记整理算法\n标记过程与标记清除算法一样\n存活对象往一端移动\n清理其余内存\n避免了标记清除算法的内存碎片，避免复制算法的空间浪费 分代收集算法\n结合多种收集算法优势\n新生代对象存活率低，复制\n老年代对象存活率高，标记整理  Android内存管理机制\n 内存弹性分配，分配值与最大值受具体设备影响 OOM场景：1.手机内存不足2.超过分配给app的最大内存 Dalvil仅固定一种回收算法，ART回收算法可运行期选择，如app前台时响应速度更重要，选择简单的标记清除算法，后台时选择标记整理算法 ART具备内存整理能力，减少内存空洞 Low Memory Killer机制 前台进程 可见进程 服务进程 后台进程 空进程  内存抖动解决：\n定义：内存频繁分配和回收导致内存不稳定\n表现：频繁GC，内存曲线呈锯齿状\n危害：卡顿，OOM。因为频繁创建对象导致内存不足及碎片，不连续的内存碎片导致无法被分配产生OOM\n内存抖动可以通过Memory Profile record录制一端内存查看具体原因\n内存泄漏\n定义：内存中存在已经没有用的对象\n表现：内存抖动，可用内存逐渐减少\n危害：内存不足，频繁GC，OOM\nMemory profile只能提供一个简单的分析，可以使用Memory Analyzer(MAT)确认问题\n先将Android生成的.hprof转换成标砖prof文件\ncd到sdk/platform-tools目录下，运行：\nhprof-conv /Users/dscao/Documents/memory-20200421T154412.hprof /Users/dscao/Documents/memory-xxxxxx.hprof\n转换\nARTHook\n 运行时插桩 性能分析\nEpic是一个虚拟机层面，以Java Method为粒度的运行时Hook框架，支持Android4.0-9.0\n比如检测图片相对ImageView是否尺寸过大。利用Epic Hook ImageView的setImageBitmap方法。\n无侵入性，通用型比较强，但兼容性问题大不能线上使用  如果一个HashMap只存两三个对象而创建HashMap不指定大小可能会浪费空间。\n线上内存监控方案，线上主要是内存泄漏 使用Debug.dumpHprofData\n设定场景(如：占用内存超过最大内存的80%)线上Dump：Debug.dumpHprofData(fileName)\n然后回传hprof文件，然后使用MAT(Memory Analyzer Tool)分析\n 随着用户使用时间内存对象比较多，dump文件太大，不过可以裁剪 由于文件比较大，回传失败几率高，分析困难  使用Leak Canary\n这种方式需要预设泄漏怀疑点，发现泄漏时回传\n 不适合所有情况，必须预设怀疑点 分析比较耗时也容易OOM  针对需要预设怀疑点的问题\u0026ndash;\u0026gt;自动找怀疑点，谁占用内存大就怀疑谁\n针对比较耗时\u0026ndash;\u0026gt;阅读源码发现是因为Leak Canary会分析预设对象的每一个对象，我们可以只分析Retain size比较大的对象\n针对容易OOM\u0026ndash;\u0026gt;因为Leak Canary会将内存堆栈生成的文件全部映射到内存当中，比较占内存，我们可以对象裁剪不全部加载到内存\n线上监控完整方案  待机内存 重点模块内存 OOM率 整体及重点模块GC次数、GC时间 增强Leak Canary自动化内存泄漏分析  线上优化大方向\n 内存泄漏 内存抖动 bitmap\n优化细节\nLargeHeap属性 开启后可以申请最大内存增加\nonTirmMemory 低内存回调是做处理，比如强制清除所有图片，关闭子界面\n使用优化过的集合SparseArray\n谨慎使用SharedPreference，因为第一次加载SharedPreference会将SharedPreference存储全部加载到内存，如果SharedPreference存储过多会占用更多内存\n谨慎使用外部第三方库\n业务架构合理设计  面试：你的内存优化是怎么做的\n 分析现状，确认问题 针对性的优化 效率提升  内存优化最大感受\n磨刀不误砍柴功\n技术优化必须结合业务代码\n系统化完善解决方案\n如何检测所有不合理的地方\n ARTHook 重点强调ARTHook和其他方案的区别 ARTHook的优点  绘制优化 绘制原理\nCPU负责计算显示内容\nGPU负责栅格化(UI元素绘制到屏幕上)\n优化工具\n Systrace 1.关注Frames2.正常绿色原点，黄色或红色则会丢帧 3.Alerts栏 Layout Inspector\nandroid studio自带工具，查看视图层次结构\n使用：Tools-\u0026gt;Layout Inspector 选择需要检测的进程 Choreographer\n获取FPS，线上使用，具备实时性\napi16后使用\nChoreographer.getInstance().postFrameCallback { }  布局加载原理\nLayoutInflater.Factory是LayoutInflater创建view的一个Hook。可以用来定制View创建过程。如：全局替换TextView为自定义View\nLayoutInflater.Factory2继承自Factory，多了一个参数parent\n优化获取界面布局耗时\nAOP setContentView\nARTHook setContentView\n另外可以使用LayoutInflaterCompat.setFactory2()获取每个控件加载时间\n加载布局慢：\n 布局文件读取慢 I/O过程 创建View慢，使用了反射，比new慢三倍  AsyncLayoutInflater\n工作线程加载布局，回调主线程\n不能设置LayoutInflater.Factory/LayoutInflater.Factory2，可以自定义一个AsyncLayoutInflater解决\n布局加载优化实战 AsyncLayoutInflater只是缓解。\nX2C:APT编译期将XML编译成java代码，即保留了XML优点又解决性能问题\nX2C问题：部分XML布局属性Java不支持，失去了系统兼容(AppCompat)\n使用ConstraintLayout减少层级\n避免过渡绘制\n避免层级叠加\n自定义view使用clipRect屏蔽被覆盖view复制\n使用megre Viewstub onDraw避免创建大对象和耗时操作 textview优化\n指标fps 加载时间 布局层级\n卡顿问题 卡顿问题难在哪？\n 产生原因错综复杂：代码 内存 绘制 I/O 不易复现：当时场景强相关\n调试工具\nCPU Profiler 图形的形式展示执行时间调用栈 信息全面，包含所有线程 运行时开销严重，整体都会变慢\nDebug.startMethodTracing\nDebug.stopMethodTracing(\u0026ldquo;filename\u0026rdquo;)\nsystrace\n监控和跟踪api调用，线程运行情况\napi18可用，可以使用TraceCompat\nTraceCompat.beginSection(\u0026quot;\u0026quot;)\nTraceCompat.endSection()\n轻量开销小，直观反应cpu利用率  StrictMode\n严苛模式，Android提供的一种运行时检测机制，方便强大，容易被忽视\n包含线程策略和虚拟机策略检测\n线程策略：1.自定义的耗时调用detectCustomSlowCalls 2.磁盘读取操作detectDiskReads 3.网络操作detectNetwork\n虚拟机策略：1.Activity泄漏detectActivityLeaks 2.Sqlite对象泄漏detectLeakedSqlLiteObjects 3.检测实例数量setClassInstanceLimit\n自动化卡顿检测及优化 以上卡顿优化方案只能线下针对分析，线上及测试环节需要自动化检测方案\n  自动卡顿检测方案原理\n消息处理机制，一个线程只有一个Looper\nLooper中的mLogging在每个message处理前后都会被调用\n主线程出现卡顿一定是在dispatchMessage执行耗时操作\n  具体实现\nLooper.getMainLooper().setMessageLogging(printer)设置自己的logging Printer\n匹配\u0026raquo;\u0026raquo;\u0026gt; Dispatching，阀值时间后执行任务(获取堆栈)\n匹配\u0026laquo;\u0026laquo;\u0026lt; Finished，任务启动之前取消掉\n  AndroidPerformanceMonitor实战\n非侵入式的性能监控组件，通知形式弹出卡顿信息，该库依赖blockcanary-android\n方便精准，定位到代码某一行\n不足：\n确实卡顿了，但卡顿堆栈可能不准确\n和OOM一样，最后的堆栈是表象，不是真正问题\n优化：获取监控周期内的多个堆栈而不仅仅是最后一个堆栈，但会导致海量卡顿堆栈处理，高频卡顿上报量太大，服务端有压力。分析：一个卡顿多个堆栈大概率有重复，可以对一个卡顿堆栈进行hash排重，找出重复的堆栈，这样可以极大减少堆栈展示量同时更搞笑找到卡顿堆栈\n  问题及优化\n  卡顿监控纬度 1.IPC 2.I/O、DB 3.View绘制\nIPC问题监测\n  监测指标\nIPC调用类型\n调用次数及耗时\n调用堆栈、发生线程\n  IPC监测\nadb命令\nadb shell am trace-ipc start\nadb shell am trace-ipc stop \u0026ndash;dump-file /data/local/tmp/ipc-trace.txt\nadb pull /data/local/tmp/ipc-trace.txt\nARTHook\n因为ipc最终都会走到BinderProxy，可以使用ARTHook hook BinderProxy中的方法\n开发阶段利用ARTHook hook相关操作暴漏分析问题\n  界面秒开实现\n 提前获取数据 Systrace 前面的优雅异步方案 优雅延迟方案 异步inflate、X2C、绘制优化 使用onCreate-onWindowFoucalsChanged计算页面打开耗时，onWindowFoucalsChanged可能不是太精确，可以使用特定方法\nLancet\n轻量Android AOP框架\n编译速度块，支持增量编译\nAPI简单，没有任何多余代码插入APK\n@Proxy 通常用于对系统Api的Hook\n@Insert 通常用于操作app与library的类\n使用Lancet hook onCreate-onWindowFoucalsChanged两个方法统计秒开率  界面秒开监控纬度\n1.总体耗时 2.生命周期耗时 3.生命周期间隔耗时\n耗时盲区监控背景\n盲区1.生命周期间隔\n盲区2.onResume到Feed展示的间隔\n比如：postMessage很可能在Feed之前执行，这样就延迟了Feed展示的时间\n耗时盲区监控难点\n 只知道盲区时间，不清楚具体在做什么 线上盲区无从可查\n耗时盲区监控线下方案 TraceView\n特别适合一段时间内的盲区监控\n线程具体做了什么一目了然\n耗时盲区监控线上方案 使用同一Handler，定制具体方法，即：sendMessageAtTime，因为最终都会走这个方法 定制gradle插件，编译器动态替换项目中所有Handler为同一Handler，这种只能监控自己的message，不能监控系统message  卡顿优化模拟面试\n 你是怎么做卡顿优化的\n第一阶段：系统工具定位解决\n第二阶段：自动化卡顿方案及优化\n第三阶段：线上监控及线下监测工具建设 怎么自动化的获取卡顿信息的\n来自Android的消息日志机制mLogging.println，经过实战发现这种获得的堆栈信息不是准确的，有可能卡顿已经过去，执行到了主线程的位置\n我们换成了高频采集去除重复堆栈 卡顿的一整套解决方案是如何做的\n线下和线上工具结合\n特定难题突破：单点问题 盲区监控  Android 线程调度原理剖析\n 线程调度原理\n任何时刻只有一个线程占用CPU处于运行状态\n多线程并发 轮流获取CPU使用权\nJVM负责线程调度：按照特定机制分配CPU使用权\n线程调度模型：  分时调度模型 轮流获取均分CPU时间 抢占式调度模型：优先级高的采用，JVM采用   Android 线程调度  nice值\nprocess中定义，值越小优先级越高，默认是Process.THREAD_PRIORITY_DEFAULT 0 cgroup\n更严格的群组调度策略，如：类似后台线程组，前台线程组。保证前台线程获取更多CPU\n线程优先级具有继承性，比如在UI线程中创建的线程具有和UI线程一样的优先级    HandlerThread\n自带消息循环的线程，串行执行，长时间运行，不断从队列中获取任务\nIntentService\n继承Service内部创建HandlerThread\n异步，不占用主线程\n是个service优先级较高不易被kill\n线程池：\n易复用 减少频繁创建销毁时间\n功能强大 定时 任务队列 并发控制\nRxJava\nAndroid线程优化实战\n禁用new Thread\n提供基础线程池供各个业务使用，避免各个业务维护自己一套线程池，线程太多\n线程使用准则\n根据任务类型选择合适的异步方式\n对于优先级低长时间执行可以选择HandlerThread\n创建线程必须命名 避免异常难以查找问题，运行期可以使用Thread.currentThread.setName修改名字\n使用AOP监控关键异步任务\n重视优先级设置，优先级可以多次设置\n锁定线程创建背景\n 项目变大之后收敛线程 项目源码、第三方库、aar中都有创建线程 避免恶化的监控防御手段  分析：\n创建线程的位置获取堆栈\n所有异步方式都会走new Thread\n使用Hook线程构造方法\n统一线程库要注意：1.区分任务类型 I/O、CPU密集型 2.I/O密集型不消耗CPU，核心池可以很大 CPU密集型核心池大小和CPU核心数相关。类似于RxJava\n面试 线程使用为什么会遇到问题\n主线程卡顿 异步任务非常耗时\n如何优化线程使用\n线程收敛，使用统一线程库，并区分任务类别\n网络优化  流量优化 网络质量 请求速度 成功率 公司带宽 服务器数 CDN 耗电  优化工具\n Network Profiler\n实时显示网络活动 发送接受数据及连接数\n需要开启高级分析\n只支持HttpUrlConnection和Okhttp 抓包工具\nCharles Fiddler Wireshark TcpDump\nCharles\n断点功能\nMap Local\n弱网环境模拟 Stetho\n强大的应用调试桥，链接Android和Chrome\n网络监控 视图查看 数据库查看 命令行扩展等  流量消耗测试方案\n 设置-\u0026gt;流量管理 抓包工具：只允许本App联网 可以解决大部分问题，但线上环境线下可能遇不到\n线上流量获取方案\nTrafficStats:API18以上重启以来的流量统计\nTrafficStats.getUidRxBytes(uid) 指定uid的接收流量\nTrafficStats.getTotalTxBytes() 总发送流量  NetworkStatsManager\nAPI23之后流量统计\n可获取指定时间间隔内的流量消耗\n可获取不同网络类型下的消耗\nhttps://github.com.tiann/epic\nhttps://developer.android.google.cn/studio/intro\nhttps://github.com/ganyao114/SandHook\nhttps://github.com/ElderDrivers/EdXposed\nhttps://github.com/PAGalaxyLab/YAHFA\n面试专题3.31-如何排除应用崩溃的原因 Android如何排除应用崩溃的原因.md\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app%E4%BC%98%E5%8C%96-%E8%80%97%E7%94%B5%E4%BC%98%E5%8C%96/",
	"title": "Android App优化-耗电优化",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android App优化-耗电优化",
	"content": "battery-historian Mac battery-historian安装配置  安装go环境\n只支持1.8.1以上版本 安装git 安装python\n只支持2.7版本不支持3.x版本 $ go get -d -u github.com/google/battery-historian/\u0026hellip;  安装遇到的坑\n protobuf无法下载。虽然我这边配置了代理，还是不行。到github上找到golang/protobuf，下载到go/src/google.golang.org下运行go run setup.go还是报错，缺少encoding目录相关东西。最后在googleprotobufclone到go/src/google.golang.org下并将googleprotobuf重命名为protobuf。 运行go run setup.go还是报错，这次是battery-historian/third_party/closure-library报错。到github上找到closure-library切换到v20170409版本，下载替换。  以上，运行OK。\n终端运行go run cmd/battery-historian/battery-historian.go，连接手机在Android Studio终端运行:\nadb bugreport bugreport.zip7.0及以上版本\n或\nadb bugreport \u0026gt; bugreport.txt//6.0及以下版本\n等一会会生成相应bugreport.zip或bugreport.txt文件，浏览器打开http://localhost:9999/，导入文件提交。\nbattery-historian分析 经过上一步骤我们可以在浏览器看到生成的电量报告。\n参考：\n GitHub battery-historian googleprotobuf 电量优化Battery Historian2.0 配置  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-pms/",
	"title": "Android PMS",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android AMS源码解析",
	"content": "前言 PMS和AMS一样运行在SystemServer进程中。SystemServer启动时会调用PackageManagerService#main方法。PackageManagerService#main方法会创建PackageManagerService并addService注册到ServiceManager。\nPackageManager\u0026amp;PackageManagerNative\u0026amp;PackageManagerService 两者关系和ActivityManager和ActivityManagerService一样的。\nIPackageManager PackageManager PackageManager是一个抽象类，其被ApplicationPackageManager继承实现。\n1 2 3 4 5 6  public abstract class PackageManager { ... } public class ApplicationPackageManager extends PackageManager{ ... }   IPackageManagerNative\u0026amp;PackageManagerNative 1 2 3  private class PackageManagerNative extends IPackageManagerNative.Stub { ... }   PackageManagerService 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  interface PackageSender { /** * @param userIds User IDs where the action occurred on a full application * @param instantUserIds User IDs where the action occurred on an instant application */ void sendPackageBroadcast(final String action, final String pkg, final Bundle extras, final int flags, final String targetPkg, final IIntentReceiver finishedReceiver, final int[] userIds, int[] instantUserIds); void sendPackageAddedForNewUsers(String packageName, boolean sendBootCompleted, boolean includeStopped, int appId, int[] userIds, int[] instantUserIds); void notifyPackageAdded(String packageName, int uid); void notifyPackageChanged(String packageName, int uid); void notifyPackageRemoved(String packageName, int uid); } public class PackageManagerService extends IPackageManager.Stub implements PackageSender { ... }   看到PackageManagerService继承IPackageManager.Stub有什么想法\nPMS如何启动的？ PackageManagerService#main\n1 2 3 4 5 6 7 8 9 10 11 12 13  public static PackageManagerService main(Context context, Installer installer, boolean factoryTest, boolean onlyCore) { // Self-check for initial settings.  PackageManagerServiceCompilerMapping.checkProperties(); PackageManagerService m = new PackageManagerService(context, installer, factoryTest, onlyCore); m.enableSystemUserPackages(); ServiceManager.addService(\u0026#34;package\u0026#34;, m); final PackageManagerNative pmn = m.new PackageManagerNative(); ServiceManager.addService(\u0026#34;package_native\u0026#34;, pmn); return m; }   "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-systemserverservicemanager/",
	"title": "Android ServiceManager&amp;SystemServer",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android ServiceManager&amp;SystemServer",
	"content": "前言 SystemServer是系统进程，SystemServer负责启动很多系统服务，App通过Binder跨进程通信使用这些系统服务，ServiceManager像是系统服务大管家，里面缓存了各个系统服务的IBinder。系统服务启动后通过addService()将IBinder缓存到ServiceManager，应用上层通过getService获取系统服务IBiner和系统服务通信\nServiceManager\u0026amp;SystemServer ServiceManager也是一个Binder服务，不同于其他服务的是ServiceManager的内存地址是固定的，谁都可以获取ServiceManager。而ServiceManager里面存放了各种系统服务的Ibinder，所以我们可以很轻松找到ServiceManager然后再找个各个系统服务。\nIServiceManager\u0026amp;ServiceManagerNative 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74  /** * Basic interface for finding and publishing system services. * * An implementation of this interface is usually published as the * global context object, which can be retrieved via * BinderNative.getContextObject(). An easy way to retrieve this * is with the static method BnServiceManager.getDefault(). * * @hide */ public interface IServiceManager extends IInterface { /** * Retrieve an existing service called @a name from the * service manager. Blocks for a few seconds waiting for it to be * published if it does not already exist. */ @UnsupportedAppUsage IBinder getService(String name) throws RemoteException; /** * Retrieve an existing service called @a name from the * service manager. Non-blocking. */ @UnsupportedAppUsage IBinder checkService(String name) throws RemoteException; /** * Place a new @a service called @a name into the service * manager. */ void addService(String name, IBinder service, boolean allowIsolated, int dumpFlags) throws RemoteException; /** * Return a list of all currently running services. */ String[] listServices(int dumpFlags) throws RemoteException; /** * Assign a permission controller to the service manager. After set, this * interface is checked before any services are added. */ void setPermissionController(IPermissionController controller) throws RemoteException; static final String descriptor = \u0026#34;android.os.IServiceManager\u0026#34;; int GET_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION; int CHECK_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+1; int ADD_SERVICE_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+2; int LIST_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+3; int CHECK_SERVICES_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+4; int SET_PERMISSION_CONTROLLER_TRANSACTION = IBinder.FIRST_CALL_TRANSACTION+5; /* * Must update values in IServiceManager.h */ /* Allows services to dump sections according to priorities. */ int DUMP_FLAG_PRIORITY_CRITICAL = 1 \u0026lt;\u0026lt; 0; int DUMP_FLAG_PRIORITY_HIGH = 1 \u0026lt;\u0026lt; 1; int DUMP_FLAG_PRIORITY_NORMAL = 1 \u0026lt;\u0026lt; 2; /** * Services are by default registered with a DEFAULT dump priority. DEFAULT priority has the * same priority as NORMAL priority but the services are not called with dump priority * arguments. */ int DUMP_FLAG_PRIORITY_DEFAULT = 1 \u0026lt;\u0026lt; 3; int DUMP_FLAG_PRIORITY_ALL = DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_HIGH | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PRIORITY_DEFAULT; /* Allows services to dump sections in protobuf format. */ int DUMP_FLAG_PROTO = 1 \u0026lt;\u0026lt; 4; }   ServiceManagerNative 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181  /** * Native implementation of the service manager. Most clients will only * care about getDefault() and possibly asInterface(). * @hide */ public abstract class ServiceManagerNative extends Binder implements IServiceManager { /** * Cast a Binder object into a service manager interface, generating * a proxy if needed. */ @UnsupportedAppUsage static public IServiceManager asInterface(IBinder obj) { if (obj == null) { return null; } IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ServiceManagerProxy(obj); } public ServiceManagerNative() { attachInterface(this, descriptor); } public boolean onTransact(int code, Parcel data, Parcel reply, int flags) { try { switch (code) { case IServiceManager.GET_SERVICE_TRANSACTION: { data.enforceInterface(IServiceManager.descriptor); String name = data.readString(); IBinder service = getService(name); reply.writeStrongBinder(service); return true; } case IServiceManager.CHECK_SERVICE_TRANSACTION: { data.enforceInterface(IServiceManager.descriptor); String name = data.readString(); IBinder service = checkService(name); reply.writeStrongBinder(service); return true; } case IServiceManager.ADD_SERVICE_TRANSACTION: { data.enforceInterface(IServiceManager.descriptor); String name = data.readString(); IBinder service = data.readStrongBinder(); boolean allowIsolated = data.readInt() != 0; int dumpPriority = data.readInt(); addService(name, service, allowIsolated, dumpPriority); return true; } case IServiceManager.LIST_SERVICES_TRANSACTION: { data.enforceInterface(IServiceManager.descriptor); int dumpPriority = data.readInt(); String[] list = listServices(dumpPriority); reply.writeStringArray(list); return true; } case IServiceManager.SET_PERMISSION_CONTROLLER_TRANSACTION: { data.enforceInterface(IServiceManager.descriptor); IPermissionController controller = IPermissionController.Stub.asInterface( data.readStrongBinder()); setPermissionController(controller); return true; } } } catch (RemoteException e) { } return false; } public IBinder asBinder() { return this; } } class ServiceManagerProxy implements IServiceManager { public ServiceManagerProxy(IBinder remote) { mRemote = remote; } public IBinder asBinder() { return mRemote; } @UnsupportedAppUsage public IBinder getService(String name) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(GET_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder; } public IBinder checkService(String name) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); mRemote.transact(CHECK_SERVICE_TRANSACTION, data, reply, 0); IBinder binder = reply.readStrongBinder(); reply.recycle(); data.recycle(); return binder; } public void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeString(name); data.writeStrongBinder(service); data.writeInt(allowIsolated ? 1 : 0); data.writeInt(dumpPriority); mRemote.transact(ADD_SERVICE_TRANSACTION, data, reply, 0); reply.recycle(); data.recycle(); } public String[] listServices(int dumpPriority) throws RemoteException { ArrayList\u0026lt;String\u0026gt; services = new ArrayList\u0026lt;String\u0026gt;(); int n = 0; while (true) { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeInt(n); data.writeInt(dumpPriority); n++; try { boolean res = mRemote.transact(LIST_SERVICES_TRANSACTION, data, reply, 0); if (!res) { break; } } catch (RuntimeException e) { // The result code that is returned by the C++ code can  // cause the call to throw an exception back instead of  // returning a nice result... so eat it here and go on.  break; } services.add(reply.readString()); reply.recycle(); data.recycle(); } String[] array = new String[services.size()]; services.toArray(array); return array; } public void setPermissionController(IPermissionController controller) throws RemoteException { Parcel data = Parcel.obtain(); Parcel reply = Parcel.obtain(); data.writeInterfaceToken(IServiceManager.descriptor); data.writeStrongBinder(controller.asBinder()); mRemote.transact(SET_PERMISSION_CONTROLLER_TRANSACTION, data, reply, 0); reply.recycle(); data.recycle(); } @UnsupportedAppUsage private IBinder mRemote; }   ServiceManager 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285  public final class ServiceManager { private static final String TAG = \u0026#34;ServiceManager\u0026#34;; private static final Object sLock = new Object(); @UnsupportedAppUsage private static IServiceManager sServiceManager; /** * Cache for the \u0026#34;well known\u0026#34; services, such as WM and AM. */ @UnsupportedAppUsage private static HashMap\u0026lt;String, IBinder\u0026gt; sCache = new HashMap\u0026lt;String, IBinder\u0026gt;(); /** * We do the \u0026#34;slow log\u0026#34; at most once every this interval. */ private static final int SLOW_LOG_INTERVAL_MS = 5000; /** * We do the \u0026#34;stats log\u0026#34; at most once every this interval. */ private static final int STATS_LOG_INTERVAL_MS = 5000; /** * Threshold in uS for a \u0026#34;slow\u0026#34; call, used on core UIDs. We use a more relax value to * avoid logspam. */ private static final long GET_SERVICE_SLOW_THRESHOLD_US_CORE = SystemProperties.getInt(\u0026#34;debug.servicemanager.slow_call_core_ms\u0026#34;, 10) * 1000; /** * Threshold in uS for a \u0026#34;slow\u0026#34; call, used on non-core UIDs. We use a more relax value to * avoid logspam. */ private static final long GET_SERVICE_SLOW_THRESHOLD_US_NON_CORE = SystemProperties.getInt(\u0026#34;debug.servicemanager.slow_call_ms\u0026#34;, 50) * 1000; /** * We log stats logging ever this many getService() calls. */ private static final int GET_SERVICE_LOG_EVERY_CALLS_CORE = SystemProperties.getInt(\u0026#34;debug.servicemanager.log_calls_core\u0026#34;, 100); /** * We log stats logging ever this many getService() calls. */ private static final int GET_SERVICE_LOG_EVERY_CALLS_NON_CORE = SystemProperties.getInt(\u0026#34;debug.servicemanager.log_calls\u0026#34;, 200); @GuardedBy(\u0026#34;sLock\u0026#34;) private static int sGetServiceAccumulatedUs; @GuardedBy(\u0026#34;sLock\u0026#34;) private static int sGetServiceAccumulatedCallCount; @GuardedBy(\u0026#34;sLock\u0026#34;) private static long sLastStatsLogUptime; @GuardedBy(\u0026#34;sLock\u0026#34;) private static long sLastSlowLogUptime; @GuardedBy(\u0026#34;sLock\u0026#34;) private static long sLastSlowLogActualTime; interface Stats { int GET_SERVICE = 0; int COUNT = GET_SERVICE + 1; } public static final StatLogger sStatLogger = new StatLogger(new String[] { \u0026#34;getService()\u0026#34;, }); @UnsupportedAppUsage private static IServiceManager getIServiceManager() { if (sServiceManager != null) { return sServiceManager; } // Find the service manager  sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager; } /** * Returns a reference to a service with the given name. * * @param name the name of the service to get * @return a reference to the service, or \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; if the service doesn\u0026#39;t exist */ @UnsupportedAppUsage public static IBinder getService(String name) { try { IBinder service = sCache.get(name); if (service != null) { return service; } else { return Binder.allowBlocking(rawGetService(name)); } } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in getService\u0026#34;, e); } return null; } /** * Returns a reference to a service with the given name, or throws * {@link NullPointerException} if none is found. * * @hide */ public static IBinder getServiceOrThrow(String name) throws ServiceNotFoundException { final IBinder binder = getService(name); if (binder != null) { return binder; } else { throw new ServiceNotFoundException(name); } } /** * Place a new @a service called @a name into the service * manager. * * @param name the name of the new service * @param service the service object */ @UnsupportedAppUsage public static void addService(String name, IBinder service) { addService(name, service, false, IServiceManager.DUMP_FLAG_PRIORITY_DEFAULT); } /** * Place a new @a service called @a name into the service * manager. * * @param name the name of the new service * @param service the service object * @param allowIsolated set to true to allow isolated sandboxed processes * to access this service */ @UnsupportedAppUsage public static void addService(String name, IBinder service, boolean allowIsolated) { addService(name, service, allowIsolated, IServiceManager.DUMP_FLAG_PRIORITY_DEFAULT); } /** * Place a new @a service called @a name into the service * manager. * * @param name the name of the new service * @param service the service object * @param allowIsolated set to true to allow isolated sandboxed processes * @param dumpPriority supported dump priority levels as a bitmask * to access this service */ @UnsupportedAppUsage public static void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) { try { getIServiceManager().addService(name, service, allowIsolated, dumpPriority); } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in addService\u0026#34;, e); } } /** * Retrieve an existing service called @a name from the * service manager. Non-blocking. */ @UnsupportedAppUsage public static IBinder checkService(String name) { try { IBinder service = sCache.get(name); if (service != null) { return service; } else { return Binder.allowBlocking(getIServiceManager().checkService(name)); } } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in checkService\u0026#34;, e); return null; } } /** * Return a list of all currently running services. * @return an array of all currently running services, or \u0026lt;code\u0026gt;null\u0026lt;/code\u0026gt; in * case of an exception */ @UnsupportedAppUsage public static String[] listServices() { try { return getIServiceManager().listServices(IServiceManager.DUMP_FLAG_PRIORITY_ALL); } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in listServices\u0026#34;, e); return null; } } /** * This is only intended to be called when the process is first being brought * up and bound by the activity manager. There is only one thread in the process * at that time, so no locking is done. * * @param cache the cache of service references * @hide */ public static void initServiceCache(Map\u0026lt;String, IBinder\u0026gt; cache) { if (sCache.size() != 0) { throw new IllegalStateException(\u0026#34;setServiceCache may only be called once\u0026#34;); } sCache.putAll(cache); } /** * Exception thrown when no service published for given name. This might be * thrown early during boot before certain services have published * themselves. * * @hide */ public static class ServiceNotFoundException extends Exception { public ServiceNotFoundException(String name) { super(\u0026#34;No service published for: \u0026#34; + name); } } private static IBinder rawGetService(String name) throws RemoteException { final long start = sStatLogger.getTime(); final IBinder binder = getIServiceManager().getService(name); final int time = (int) sStatLogger.logDurationStat(Stats.GET_SERVICE, start); final int myUid = Process.myUid(); final boolean isCore = UserHandle.isCore(myUid); final long slowThreshold = isCore ? GET_SERVICE_SLOW_THRESHOLD_US_CORE : GET_SERVICE_SLOW_THRESHOLD_US_NON_CORE; synchronized (sLock) { sGetServiceAccumulatedUs += time; sGetServiceAccumulatedCallCount++; final long nowUptime = SystemClock.uptimeMillis(); // Was a slow call?  if (time \u0026gt;= slowThreshold) { // We do a slow log:  // - At most once in every SLOW_LOG_INTERVAL_MS  // - OR it was slower than the previously logged slow call.  if ((nowUptime \u0026gt; (sLastSlowLogUptime + SLOW_LOG_INTERVAL_MS)) || (sLastSlowLogActualTime \u0026lt; time)) { EventLogTags.writeServiceManagerSlow(time / 1000, name); sLastSlowLogUptime = nowUptime; sLastSlowLogActualTime = time; } } // Every GET_SERVICE_LOG_EVERY_CALLS calls, log the total time spent in getService().  final int logInterval = isCore ? GET_SERVICE_LOG_EVERY_CALLS_CORE : GET_SERVICE_LOG_EVERY_CALLS_NON_CORE; if ((sGetServiceAccumulatedCallCount \u0026gt;= logInterval) \u0026amp;\u0026amp; (nowUptime \u0026gt;= (sLastStatsLogUptime + STATS_LOG_INTERVAL_MS))) { EventLogTags.writeServiceManagerStats( sGetServiceAccumulatedCallCount, // Total # of getService() calls.  sGetServiceAccumulatedUs / 1000, // Total time spent in getService() calls.  (int) (nowUptime - sLastStatsLogUptime)); // Uptime duration since last log.  sGetServiceAccumulatedCallCount = 0; sGetServiceAccumulatedUs = 0; sLastStatsLogUptime = nowUptime; } } return binder; } }   SystemServer 1 2 3  public final class SystemServer { }   "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/",
	"title": "Android-App启动流程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android-App启动流程",
	"content": "Android启动流程 ROM/RAM ROM(Read-Only Memory)\nRAM(Random Access Memory)\nBoot ROM 它负责加载引导程序Boot Loader。\nBoot Loader 固化在ROM中的引导程序，主要是检查RAM，初始化系统参数等功能。\nAndroid内核(Kernel)层 Kernel层即是Android系统的内核层。Kernel层通过系统调用(SysCall)调用\n系统调用(SysCall)层 SysCall是内核层提供的用户空间程序与内核空间进行交互的一套标准接口。是连接用户态和内核态的桥梁，它提供了用户态程序受限访问系统内核空间资源的能力。用户空间通过向内核空间发起SysCall产生软中断让用户程序陷入内核态执行相应的操作。\nNative层 Native层主要包括用户守护进程、开机动画(bootanim)、ServiceManager及硬件抽象层(HAL)。\n内核态通过SysCall创建Native层init进程，init进程是所有用户进程的鼻祖。init进程主要做了：\n 孵化出用户守护进程、 启动开机动画(bootanim)及ServiceManager等重要服务。 孵化Zygote进程。Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程。  Framework层 SystemServer是Zygote fork的第一个进程，SystemServer中会启动各种服务(Android中服务包括引导服务、核心服务、其他服务)，包括AMS、WMS、PMS等重要服务(这些服务都运行在SystemServer进程，比如AMS运行在SystemServer进程的一个单独线程中)。\nSystemServer进程 SystemServer#run()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private void run() { ... // Start services.  try { traceBeginAndSlog(\u0026#34;StartServices\u0026#34;); startBootstrapServices();//引导服务，包括AMS、WMS、PMS等  startCoreServices();//核心服务  startOtherServices();//其他服务  SystemServerInitThreadPool.shutdown(); } catch (Throwable ex) { Slog.e(\u0026#34;System\u0026#34;, \u0026#34;******************************************\u0026#34;); Slog.e(\u0026#34;System\u0026#34;, \u0026#34;************ Failure starting system services\u0026#34;, ex); throw ex; } finally { traceEnd(); } }   SystemService\nSystemService是一个抽象类，Android中有一类继承自SystemService的系统服务。在系统启动时由SystemServiceManager负责实例化并启动各个SystemService，SystemService会被保存在SystemServiceManager中，大部分SystemService在启动执行到onStart时会调用自己的publishBinderService将自己的IBinder添加到ServiceManager中管理。你可能会问为什么SystemService的对象添加到SystemServiceManager，IBinder对象又添加到ServiceManager中呢？我们要明白Binder机制是设计用于跨进程通信的，所以SystemServiceManager持有SystemService对象主要是同在SystemServer进程的其他系统服务，如AMS使用的，ServiceManager持有SystemService的IBinder对象是为了方便跨进程获取的服务的IBinder对象进行通信的。当然ServiceManager并不只有SystemService这一类服务的IBinder对象。\nSystemService#publishBinderService\n1 2 3 4  protected final void publishBinderService(String name, IBinder service, boolean allowIsolated, int dumpPriority) { ServiceManager.addService(name, service, allowIsolated, dumpPriority); }   SystemServiceManager\nSystemServiceManager是一个专门用于启动管理(继承自)SystemService(系统服务)的类。SystemServiceManager中有一个ArrayList集合：\n1  private final ArrayList\u0026lt;SystemService\u0026gt; mServices = new ArrayList\u0026lt;SystemService\u0026gt;();   当SystemServer#run()中调用startBootstrapServices()时，startBootstrapServices()内部会调用一些列的SystemServiceManager#startService方法启动各个SystemService(比如：Installer、PowerManagerService、DisplayManagerService等)并将启动的SystemService添加到mServices集合。\nSystemServiceManager#startService\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  public \u0026lt;T extends SystemService\u0026gt; T startService(Class\u0026lt;T\u0026gt; serviceClass) { try { final String name = serviceClass.getName(); Slog.i(TAG, \u0026#34;Starting \u0026#34; + name); Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, \u0026#34;StartService \u0026#34; + name); // Create the service.  if (!SystemService.class.isAssignableFrom(serviceClass)) { throw new RuntimeException(\u0026#34;Failed to create \u0026#34; + name + \u0026#34;: service must extend \u0026#34; + SystemService.class.getName()); } final T service; try { Constructor\u0026lt;T\u0026gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); } catch (InstantiationException ex) { throw new RuntimeException(\u0026#34;Failed to create service \u0026#34; + name + \u0026#34;: service could not be instantiated\u0026#34;, ex); } catch (IllegalAccessException ex) { throw new RuntimeException(\u0026#34;Failed to create service \u0026#34; + name + \u0026#34;: service must have a public constructor with a Context argument\u0026#34;, ex); } catch (NoSuchMethodException ex) { throw new RuntimeException(\u0026#34;Failed to create service \u0026#34; + name + \u0026#34;: service must have a public constructor with a Context argument\u0026#34;, ex); } catch (InvocationTargetException ex) { throw new RuntimeException(\u0026#34;Failed to create service \u0026#34; + name + \u0026#34;: service constructor threw an exception\u0026#34;, ex); } startService(service); return service; } finally { Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); } } public void startService(@NonNull final SystemService service) { // Register it.  mServices.add(service); // Start it.  long time = SystemClock.elapsedRealtime(); try { service.onStart(); } catch (RuntimeException ex) { throw new RuntimeException(\u0026#34;Failed to start service \u0026#34; + service.getClass().getName() + \u0026#34;: onStart threw an exception\u0026#34;, ex); } warnIfTooLong(SystemClock.elapsedRealtime() - time, service, \u0026#34;onStart\u0026#34;); }   ServiceManager\nServiceManager\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  public final class ServiceManager { private static IServiceManager sServiceManager; /** * Cache for the \u0026#34;well known\u0026#34; services, such as WM and AM. */ private static HashMap\u0026lt;String, IBinder\u0026gt; sCache = new HashMap\u0026lt;String, IBinder\u0026gt;(); private static IServiceManager getIServiceManager() { if (sServiceManager != null) { return sServiceManager; } // Find the service manager  sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager; } public static void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) { try { getIServiceManager().addService(name, service, allowIsolated, dumpPriority); } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in addService\u0026#34;, e); } } }   App启动 经过上面的步骤，系统已经启动完成，各种系统服务也已经启动好，环境已经就绪。于是你点击了桌面应用图标启动一个应用程序。Launcher进程会想SystemServer进程中的AMS发起请求启动应用程序，AMS会向Zygote进程请求(这一步是通过Socket通信)创建应用程序进程，Zygote进程接收到请求fork一个应用程序进程。当应用进程准备好后请求AMS创建根Activity，AMS会用进程请求创建根Activity，最终执行到ActivityThread#ApplicationThread创建启动根Activity。\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app%E9%80%82%E9%85%8D/",
	"title": "Android-App适配",
	"tags": ["android"],
	"categories": [],
	"series": ["android"],
	"description": "Android-App适配",
	"content": "屏幕适配 首先我们需要明白几个概念：\n 分辨率 屏幕像素点总数(如：1080x1920) 屏幕尺寸 手机屏幕对角线英寸(inch)单位的位物理尺寸(如：4.7/5/5.5/6) dpi(dots per inch)\n像素密度，即每英寸的像素点数。像素密度(dpi) = 像素(px) / 尺寸(inch)。Android中将每英寸160个像素点的像素密度成为标准屏幕像素密度(mdpi)    屏幕密度标准 dpi density 分辨率     ldpi 120dpi 0.75 240x320   mdpi 160dpi 1 320x480   hdpi 240dpi 1.5 480x800   xhdpi 320dpi 2 720x1280   xxhdpi 480dpi 3 1080x1920       dp/dip(density-independent pixel)\n官方文档对dp的解释：A virtual pixel unit that you should use when defining UI layout, to express layout dimensions or position in a density-independent way.\n并给出了关系：px = dp * (dpi / 160)，由此可知标准屏幕像素密度(mdpi)下：1dp = 1px。hdpi下：1dp = 1.5px，即：dp = px * density； sp/sip(scale-independent pixel)\n字体大小专用单位，可根据字体大小首选项缩放。推荐使用12/14/18/22双数字体大小，不建议使用奇数和小数，容易丢失精度。  为什么需要屏幕适配？因为各个手机厂商的屏幕密度并不标准，比如一个1080x1920像素的5英寸手机，其屏幕像素密度：\n$$ dpi = \\frac{\\sqrt{1080^2*1920^2}}{5}=440 $$\n显然对不上上表中的标准值。所以使得原本可以标准情况下使用dp适配的问题在不标准的情况下变得不可行。\n布局组件适配  使用像素无关的的单位dp指定尺寸 使用相对布局和线性布局，不使用绝对布局\n相对布局需要测量两次，线性布局只需要测量一次。 使用wrap_content/match_parent、比例/权重 使用minWidth/minHeight、lines等属性 不同限定符资源下dimens设置不同尺寸  布局适配  使用size限定符 使用最小宽度限定符 使用布局别名 使用屏幕方向限定符 多套layout适配  代码适配 比如向服务器请求图片时带上屏幕大小，根据当前屏幕大小请求合适的图片。\n图片适配  ImageView的scaleType属性使用。 使用Nine-Patch图片 自定义View/Shape  适配优化 Google官方刘海屏适配方案\n华为官方刘海屏适配方案\nOPPO官方刘海屏适配方案\nVIVO官方刘海屏适配方案\n今日头条适配方案 原理：修改系统的density值\nAndroidAutoSize AndroidAutoSize 是基于今日头条适配方案，该开源库已经很大程度上解决了今日头条适配方案的两个缺点，可以对activity，fragment进行取消适配\n屏幕分割方案 将屏幕尺寸按标准像素密度的尺寸320x480进行分割，计算出每一份等于多少像素。UI设计按照标准的320x480进行设计。我们可以利用工具预先生成所有values-heightxwidth文件夹并生成尺寸文件。\nmakeValueDimens(320, 480); makeValueDimens(480, 800); makeValueDimens(480, 854); makeValueDimens(540, 960); makeValueDimens(600, 1024); makeValueDimens(720, 1184); makeValueDimens(720, 1196); makeValueDimens(720, 1280); makeValueDimens(768, 1024); makeValueDimens(800, 1280); makeValueDimens(1080, 1812); makeValueDimens(1080, 1920); makeValueDimens(1440, 2560); 权限适配 参考：\n Google官方刘海屏适配方案 华为官方刘海屏适配方案 OPPO官方刘海屏适配方案 VIVO官方刘海屏适配方案 Android屏幕适配-应用篇 Android 屏幕适配：最全面的解决方案  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-apt/",
	"title": "Android-APT",
	"tags": ["apt"],
	"categories": [],
	"series": ["android"],
	"description": "Android-APT详解",
	"content": "APT(Annotation Processor Tool) 注解处理器(APT)它是Java提供的帮我们处理注解的。要实现我们自己的处理注解的逻辑就需要继承Processor接口。\n1 2 3 4 5 6 7 8 9 10 11 12 13  public interface Processor { Set\u0026lt;String\u0026gt; getSupportedOptions(); Set\u0026lt;String\u0026gt; getSupportedAnnotationTypes(); SourceVersion getSupportedSourceVersion(); void init(ProcessingEnvironment var1); boolean process(Set\u0026lt;? extends TypeElement\u0026gt; var1, RoundEnvironment var2); Iterable\u0026lt;? extends Completion\u0026gt; getCompletions(Element var1, AnnotationMirror var2, ExecutableElement var3, String var4); }   Processor还有个抽象类AbstractProcessor，我们自定义注解处理器一般都是继承AbstractProcessor，AbstractProcessor提供的默认实现主要是读取自定义Processor类的注解SupportedOptions、SupportedAnnotationTypes、SupportedSourceVersion，分别对应getSupportedOptions()、getSupportedAnnotationTypes()、getSupportedSourceVersion()三个方法，用配置的形式让我们写起来更方便。\n如果 APT 处理 Annotation 时产生了新的Java代码，编译器会再调用一次Annotation Processor，如果第二次处理还有新代码产生，就会接着调用Annotation Processor，直到没有新代码产生为止。\n辅助类库 AutoService auto-service是谷歌提供的工具库，可以帮我们自动注册Processor，即自动生成 META-INF/services/javax.annotation.processing.Processor 文件，并注册我们自定义的Processor。如果不使用auto-service就需要我们手动添加。\nJavapoet Javapoet是让我们可以使用面向对象的方式生成Java源码的库且不需要自己导包，我们当然可以使用字符串拼接的方式，但这样容易出错，不能自动导包。\n向注解处理器传递参数 1 2 3 4 5 6 7 8 9 10 11 12  android { ... defaultConfig { ... javaCompileOptions { annotationProcessorOptions { argument \u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34; argument \u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34; } } } }   或者\n1 2 3 4 5 6 7 8 9 10 11  android { ... defaultConfig { ... javaCompileOptions { annotationProcessorOptions { arguments = [key1: value1, key2: value2] } } } }   使用示例 使用自定义APT实现自己的一个简版ARouter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187  @AutoService(Processor.class) @SupportedSourceVersion(SourceVersion.RELEASE_8) @SupportedAnnotationTypes({Config.AX_ROUTER_ANN_NAME}) @SupportedOptions({Config.OPTIONS_MODULE_KEY, Config.AX_ROUTER_OPTIONS_PACKAGE}) public class AxRouterProcessor extends AbstractProcessor { private Map\u0026lt;String, Set\u0026lt;RouteMeta\u0026gt;\u0026gt; groupMap = new HashMap\u0026lt;\u0026gt;(); private Map\u0026lt;String, String\u0026gt; rootMap = new TreeMap\u0026lt;\u0026gt;(); //Element工具类(类、函数、属性、包名都是Element)  private Elements elementUtils; private Types typeUtils; //用来打印Log信息  private Messager messager; //文件生成器  private Filer filer; //gradle中传递过来的参数  private String routerModule; TypeElement iRouteGroup; TypeElement iRouteRoot; @Override public synchronized void init(ProcessingEnvironment processingEnvironment) { super.init(processingEnvironment); elementUtils = processingEnvironment.getElementUtils(); typeUtils = processingEnvironment.getTypeUtils(); messager = processingEnvironment.getMessager(); filer = processingEnvironment.getFiler(); Map\u0026lt;String, String\u0026gt; options = processingEnvironment.getOptions(); routerModule = options.get(Config.OPTIONS_MODULE_KEY); messager.printMessage(Diagnostic.Kind.NOTE, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; AxRouterProcessor init routerModule:\u0026#34; + routerModule); iRouteGroup = elementUtils.getTypeElement(Config.I_ROUTE_GROUP); iRouteRoot = elementUtils.getTypeElement(Config.I_ROUTE_ROOT); } @Override public boolean process(Set\u0026lt;? extends TypeElement\u0026gt; set, RoundEnvironment roundEnvironment) { messager.printMessage(Diagnostic.Kind.NOTE, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; AxRouterProcessor process:\u0026#34;); if (set.isEmpty()) { messager.printMessage(Diagnostic.Kind.NOTE, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 没有发现 被@Router 注解的地方\u0026#34;); return false; } TypeMirror activityMirror = elementUtils.getTypeElement(RouteMeta.Type.ACTIVITY.getClassName()).asType(); Set\u0026lt;? extends Element\u0026gt; AxRouters = roundEnvironment.getElementsAnnotatedWith(Route.class); messager.printMessage(Diagnostic.Kind.NOTE, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; AxRouterProcessor processxxxx:\u0026#34; + AxRouters.size()); for (Element element : AxRouters) { String pkg = elementUtils.getPackageOf(element).getQualifiedName().toString(); String clazz = element.getSimpleName().toString(); Route router = element.getAnnotation(Route.class); RouteMeta routeMeta = new RouteMeta.Builder() .setGroup(router.group()) .setPath(router.path()) .setElement(element) .build(); TypeMirror elementMirror = element.asType(); if (typeUtils.isSubtype(elementMirror, activityMirror)) { routeMeta.setType(RouteMeta.Type.ACTIVITY); } else { throw new IllegalArgumentException(\u0026#34;@Router目前仅支持Activity\u0026#34;); } if (!checkRoute(routeMeta)) { messager.printMessage(Diagnostic.Kind.ERROR, \u0026#34;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; \u0026#34; + pkg + \u0026#34;.\u0026#34; + clazz + \u0026#34;的@Router的配置不符合规范\u0026#34;); } else { Set\u0026lt;RouteMeta\u0026gt; routeMetas = groupMap.get(routeMeta.getGroup()); if (routeMetas == null) { routeMetas = new HashSet\u0026lt;\u0026gt;(); groupMap.put(routeMeta.getGroup(), routeMetas); } routeMetas.add(routeMeta); } try { createRouteGroups(); } catch (IOException e) { e.printStackTrace(); } try { createRouteRoots(); } catch (IOException e) { e.printStackTrace(); } } return true; } /** * 检查routeMeta的合法性 * * @param routeMeta * @return */ boolean checkRoute(RouteMeta routeMeta) { return true; } private void createRouteGroups() throws IOException { TypeName routerGroupPT = ParameterizedTypeName.get( ClassName.get(Map.class), ClassName.get(String.class), ClassName.get(RouteMeta.class) ); ParameterSpec routerGroupPS = ParameterSpec.builder(routerGroupPT, Config.ROUTE_GROUP_LOAD_INTO_PARAM_VAR).build(); MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(Config.LOAD_INTO_METHOD) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(routerGroupPS); for (Map.Entry\u0026lt;String, Set\u0026lt;RouteMeta\u0026gt;\u0026gt; entry : groupMap.entrySet()) { Set\u0026lt;RouteMeta\u0026gt; routeMetas = entry.getValue(); for (RouteMeta routeMeta : routeMetas) { // atlas.put(\u0026#34;/app/MainActivity\u0026#34;,RouteMeta.build(group,path, type,destination))  methodBuilder.addStatement( \u0026#34;$N.put($S, $T.build($S, $S, $T.\u0026#34; + routeMeta.getType() + \u0026#34;, $T.class))\u0026#34;, Config.ROUTE_GROUP_LOAD_INTO_PARAM_VAR, routeMeta.getPath(), ClassName.get(RouteMeta.class), routeMeta.getGroup(), routeMeta.getPath(), ClassName.get(RouteMeta.Type.class), ClassName.get((TypeElement) routeMeta.getElement())); } String fileName = Config.AX_ROUTER_APT_ROUTE_GROUP_FILE + entry.getKey(); JavaFile.builder(Config.AX_ROUTER_APT_GEN_PACKAGE, TypeSpec.classBuilder(fileName) .addSuperinterface(ClassName.get(iRouteGroup)) .addJavadoc(Config.WARNING_TIPS) .addModifiers(PUBLIC) // public修饰符  .addMethod(methodBuilder.build()) // 方法的构建（方法参数 + 方法体）  .build()) // 类构建完成  .build() // JavaFile构建完成  .writeTo(filer); // 文件生成器开始生成类文件  rootMap.put(entry.getKey(), fileName); } } private void createRouteRoots() throws IOException { if (rootMap.isEmpty()) { return; } ParameterizedTypeName routerRootPT = ParameterizedTypeName.get( ClassName.get(Map.class), ClassName.get(String.class), ParameterizedTypeName.get( ClassName.get(Class.class), WildcardTypeName.subtypeOf(ClassName.get(iRouteGroup)) ) ); ParameterSpec routerRootPS = ParameterSpec.builder(routerRootPT, Config.ROUTE_ROOT_LOAD_INTO_PARAM_VAR).build(); MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(Config.LOAD_INTO_METHOD) .addAnnotation(Override.class) .addModifiers(PUBLIC) .addParameter(routerRootPS); for (Map.Entry\u0026lt;String, String\u0026gt; entry : rootMap.entrySet()) { methodBuilder.addStatement(\u0026#34;$N.put($S, $T.class)\u0026#34;, Config.ROUTE_ROOT_LOAD_INTO_PARAM_VAR, entry.getKey(), ClassName.get(Config.AX_ROUTER_APT_GEN_PACKAGE, entry.getValue())); } String fileName = Config.AX_ROUTER_APT_ROUTE_ROOT_FILE + routerModule; JavaFile.builder(Config.AX_ROUTER_APT_GEN_PACKAGE, TypeSpec.classBuilder(fileName) .addJavadoc(Config.WARNING_TIPS) .addSuperinterface(ClassName.get(iRouteRoot)) .addModifiers(PUBLIC) .addMethod(methodBuilder.build()) .build() ).build().writeTo(filer); } }   参考：\n 添加注释处理器 AutoService JavaPoet  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-arouter%E5%8E%9F%E7%90%86%E7%AE%80%E6%9E%90/",
	"title": "Android-ARouter原理简析",
	"tags": ["arouter"],
	"categories": [],
	"series": [],
	"description": "Android-ARouter原理简析",
	"content": "前言 阿里ARouter是组件开发所需的路由框架。由于组件开发中的类(尤其是Activity)不能直接相互引用，无法使用通常的跳转方式。\n隐式跳转：需要AndroidManifest.xml中配置，不便维护，也无法集中管理\nClass.forName：报名容易出错，业务逻辑修改将难以维护。\n阿里ARouter ARouter中有几个重要概念：Router、IInterceptor\u0026amp;IInterceptorGroup、IProvider\u0026amp;IProviderGroup。需要明白的是路由框架本质就是提供路由功能，其他的都是为路由功能服务的，是为了更好的控制路由的过程，所以IInterceptor\u0026amp;IInterceptorGroup、IProvider\u0026amp;IProviderGroup都是为Router服务的。\nARouter的主要原理和功能：使用APT，实现对路由信息的分组(模块)的懒加载。\nRouter、IInterceptor、IProvider相关的信息保存在仓库类Warehouse中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Warehouse { // Cache route and metas  static Map\u0026lt;String, Class\u0026lt;? extends IRouteGroup\u0026gt;\u0026gt; groupsIndex = new HashMap\u0026lt;\u0026gt;(); static Map\u0026lt;String, RouteMeta\u0026gt; routes = new HashMap\u0026lt;\u0026gt;(); // Cache provider  static Map\u0026lt;Class, IProvider\u0026gt; providers = new HashMap\u0026lt;\u0026gt;(); static Map\u0026lt;String, RouteMeta\u0026gt; providersIndex = new HashMap\u0026lt;\u0026gt;(); // Cache interceptor  static Map\u0026lt;Integer, Class\u0026lt;? extends IInterceptor\u0026gt;\u0026gt; interceptorsIndex = new UniqueKeyTreeMap\u0026lt;\u0026gt;(\u0026#34;More than one interceptors use same priority [%s]\u0026#34;); static List\u0026lt;IInterceptor\u0026gt; interceptors = new ArrayList\u0026lt;\u0026gt;(); static void clear() { routes.clear(); groupsIndex.clear(); providers.clear(); providersIndex.clear(); interceptors.clear(); interceptorsIndex.clear(); } }   Router ARouter会根据@Router注解的path和group(如果group为空，则使用配置的的AROUTER_MODULE_NAME)，使用APT技术为我们生成\nARouter$$Group$$group和ARouter$$Root$$group两个类，我这里没有配置group，使用了AROUTER_MODULE_NAME配置，即项目的Module名。\n1 2 3 4 5 6 7 8 9 10 11 12 13  public class ARouter$$Group$$app implements IRouteGroup { @Override public void loadInto(Map\u0026lt;String, RouteMeta\u0026gt; atlas) { atlas.put(\u0026#34;/app/MainActivity\u0026#34;, RouteMeta.build(RouteType.ACTIVITY, MainActivity.class, \u0026#34;/app/mainactivity\u0026#34;, \u0026#34;app\u0026#34;, null, -1, -2147483648)); } } public class ARouter$$Root$$app implements IRouteRoot { @Override public void loadInto(Map\u0026lt;String, Class\u0026lt;? extends IRouteGroup\u0026gt;\u0026gt; routes) { routes.put(\u0026#34;app\u0026#34;, ARouter$$Group$$app.class); } }   RouteMeta是对@Router配置的封装，但并不仅仅包含@Router配置的path和group，在APT处理过程中还加入了RouteType等。\nIRouteGroup 记录当前group有哪些路由信息。\nIRouteRoot 记录每个group的路由信息由哪个IRouteGroup实现类加载。\n上面ARouter$$Group$$app和ARouter$$Root$$app中的方法loadInto的参数实际上就是Warehouse中的routes和groupsIndex\nARouter拦截器的使用 使用拦截器需要继承IInterceptor，且添加@Interceptor注解，注意@Interceptor注解中的优先级priority是不能相同的，当有多个拦截器时，拦截器的执行顺序是按照priority排序的。priority值越小优先级越高。\ncallback.onContinue表示继续执行，callback.onInterrupt表示拦截当前跳转。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  @Interceptor(name = \u0026#34;login\u0026#34;, priority = 3) public class LoginInterceptor implements IInterceptor { @Override public void process(Postcard postcard, InterceptorCallback callback) { if (\u0026#34;/order/MainActivity\u0026#34;.equals(postcard.getPath())) { callback.onContinue(postcard); } else { callback.onInterrupt(new Exception(\u0026#34;没有登陆\u0026#34;)); } } @Override public void init(Context context) { } }   自定义拦截器ARouter会帮我们生成ARouter$$Interceptors$$app类，帮我们自动将自定义的拦截器添加到Warehouse仓库。\nARouter$$Interceptors$$app：\n1 2 3 4 5 6  public class ARouter$$Interceptors$$app implements IInterceptorGroup { @Override public void loadInto(Map\u0026lt;Integer, Class\u0026lt;? extends IInterceptor\u0026gt;\u0026gt; interceptors) { interceptors.put(3, LoginInterceptor.class); } }   ARouter中的Service ARouter的Service需要继承IProvider。\nService一般定义在base模块，比如在其他子模块我们想获取登陆用户信息就可以一定一个Service用于获取用户信息。\n1 2 3 4 5 6 7 8 9 10 11 12  public interface UserService extends IProvider { UserInfo getUserInfo(); } @Route(path = \u0026#34;/ax/service/user\u0026#34;) public interface UserServiceImpl implements UserService { public UserInfo getUserInfo(){ ... } } UserInfo info = ARouter.getInstance().navigation(UserService.class).getUserInfo();   以上自定义Service后ARouter会自动生成ARouter$$Group$$ax和ARouter$$Providers$$app两个类帮我们将自定义Service添加到Warehouse仓库。\n1 2 3 4 5 6 7 8 9 10 11 12  public class ARouter$$Group$$ax implements IRouteGroup { @Override public void loadInto(Map\u0026lt;String, RouteMeta\u0026gt; atlas) { atlas.put(\u0026#34;/ax/service/user\u0026#34;, RouteMeta.build(RouteType.PROVIDER, UserServiceImpl.class, \u0026#34;/ax/service/user\u0026#34;, \u0026#34;ax\u0026#34;, null, -1, -2147483648)); } } public class ARouter$$Providers$$app implements IProviderGroup { @Override public void loadInto(Map\u0026lt;String, RouteMeta\u0026gt; providers) { providers.put(\u0026#34;com.osshare.ax.UserService\u0026#34;, RouteMeta.build(RouteType.PROVIDER, UserServiceImpl.class, \u0026#34;/ax/service/user\u0026#34;, \u0026#34;ax\u0026#34;, null, -1, -2147483648)); } }   我们看以下ARouter中自带的Service实现。\nInterceptorService是ARouter中调用拦截器逻辑的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  public interface InterceptorService extends IProvider { /** * Do interceptions */ void doInterceptions(Postcard postcard, InterceptorCallback callback); } @Route(path = \u0026#34;/arouter/service/interceptor\u0026#34;) public class InterceptorServiceImpl implements InterceptorService { private static boolean interceptorHasInit; private static final Object interceptorInitLock = new Object(); @Override public void doInterceptions(final Postcard postcard, final InterceptorCallback callback) { ... } ... }   AutowiredService是ARouter中调用拦截器逻辑的实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36  public interface AutowiredService extends IProvider { /** * Autowired core. * @param instance the instance who need autowired. */ void autowire(Object instance); } @Route(path = \u0026#34;/arouter/service/autowired\u0026#34;) public class AutowiredServiceImpl implements AutowiredService { private LruCache\u0026lt;String, ISyringe\u0026gt; classCache; private List\u0026lt;String\u0026gt; blackList; @Override public void init(Context context) { classCache = new LruCache\u0026lt;\u0026gt;(66); blackList = new ArrayList\u0026lt;\u0026gt;(); } @Override public void autowire(Object instance) { String className = instance.getClass().getName(); try { if (!blackList.contains(className)) { ISyringe autowiredHelper = classCache.get(className); if (null == autowiredHelper) { // No cache.  autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance(); } autowiredHelper.inject(instance); classCache.put(className, autowiredHelper); } } catch (Exception ex) { blackList.add(className); // This instance need not autowired.  } } }   参考： * [ARouter解析五：IoC与依赖注入](https://www.jianshu.com/p/31a1c2c3ee72) -- "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-binder%E6%9C%BA%E5%88%B6%E4%B8%80/",
	"title": "Android-Binder机制(一)",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android-Binder机制(一)",
	"content": "前沿 Android Binder是在OpneBinder上的定制实现。Binder是Android系统中大量使用的IPC（Inter-process communication，进程间通讯）机制。无论是应用程序对系统服务的请求，还是应用程序自身提供对外服务，都需要使用到Binder。\n在Unix/Linux环境下，传统的IPC机制包括：\n 管道 共享内存 信号量 Socket 消息队列  详细参阅《UNIX网络编程 卷2：进程间通信》。\nBinder相较于传统IPC来说更适合于Android系统，具体原因的包括如下三点：\n Binder本身是C/S架构的，这一点更符合Android系统的架构 性能上更有优势：管道，消息队列，Socket的通讯都需要两次数据拷贝，而Binder只需要一次。要知道，对于系统底层的IPC形式，少一次数据拷贝，对整体性能的影响是非常之大的 安全性更好：传统IPC形式，无法得到对方的身份标识（UID/GID)，而在使用Binder IPC时，这些身份标示是跟随调用过程而自动传递的。Server端很容易就可以知道Client端的身份，非常便于做安全检查  可以看出Binder分为Framework层和驱动层：\n驱动层 \u0026ndash; 位于Linux内核中，它提供了最底层的数据传递，对象标识，线程管理，调用过程控制等功能。驱动层是整个Binder机制的核心。\nFramework层 \u0026ndash; 以驱动层为基础，提供了应用开发的基础设施。Framework层又分C++和Java两部分，中间使用JNI连接调用。\n驱动层 Binder是C/S架构的，Client对于Server的请求会经由Binder框架由上至下传递到内核的Binder驱动中，请求中包含了Client将要调用的命令和参数。请求到了Binder驱动之后，在确定了服务的提供方之后，会再从下至上将请求传递给具体的服务。整个调用过程如下图所示：\n看过Android-App启动流程篇的都直到系统启动时启动了很多的系统服务，再加上第三方应用提供的服务系统中存在着大量的服务，即Binder服务端。客户端是如何找到服务端的呢？答案就在ServiceManager中。每个对外公开提供服务的Server都需要通过调用addService注册到ServiceManager中，即以唯一标识Server的字符串为Key，将其IBinder放入到一个HashMap中。\nServiceManager：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public final class ServiceManager { private static IServiceManager sServiceManager; /** * Cache for the \u0026#34;well known\u0026#34; services, such as WM and AM. */ private static HashMap\u0026lt;String, IBinder\u0026gt; sCache = new HashMap\u0026lt;String, IBinder\u0026gt;(); private static IServiceManager getIServiceManager() { if (sServiceManager != null) { return sServiceManager; } // Find the service manager  sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager; } public static IBinder getService(String name) { try { IBinder service = sCache.get(name); if (service != null) { return service; } else { return Binder.allowBlocking(rawGetService(name)); } } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in getService\u0026#34;, e); } return null; } public static void addService(String name, IBinder service, boolean allowIsolated, int dumpPriority) { try { getIServiceManager().addService(name, service, allowIsolated, dumpPriority); } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in addService\u0026#34;, e); } } }   Client向Server发起请求时必须直到唯一标识这个Server的字符串，通过这个getService获取Server的Binder与Server通信。\nBinder协议 Binder协议可以分为控制协议和驱动协议两类。\n控制协议是进程通过ioctl(“/dev/binder”) 与Binder设备进行通讯的协议，该协议包含以下几种命令：\n   命令 说明 参数类型     BINDER_WRITE_READ 读写操作，最常用的命令。IPC过程就是通过这个命令进行数据传递 binder_write_read   BINDER_SET_MAX_THREADS 设置进程支持的最大线程数量 size_t   BINDER_SET_CONTEXT_MGR 设置自身为ServiceManager 无   BINDER_THREAD_EXIT 通知驱动Binder线程退出 无   BINDER_VERSION 获取Binder驱动的版本号 无   BINDER_SET_IDLE_PRIORITY 暂未用到 无   BINDER_SET_IDLE_TIMEOUT 暂未用到 无    Binder的驱动协议描述了对于Binder驱动的具体使用过程。驱动协议又可以分为两类：\n binder_driver_command_protocol，描述了进程发送给Binder驱动的命令。\nbinder_driver_command_protocol包含17个命令：\n此处暂略 binder_driver_return_protocol，描述了Binder驱动发送给进程的命令。\nbinder_driver_return_protocol包含18个命令：\n此处暂略  下面以一次Binder请求过程来详细看一下Binder协议是如何通信的：\n对上图的说明：\n Binder是C/S架构的，通信过程牵涉到：Client，Server以及Binder驱动三个角色 Client对于Server的请求以及Server对于Client回复都需要通过Binder驱动来中转数据 BC_XXX命令是进程发送给驱动的命令 BR_XXX命令是驱动发送给进程的命令 整个通信过程由Binder驱动控制\n需要补充说明的是Binder协议的通信过程中，不仅仅是发送请求和接受数据这些命令。同时包括了对于引用计数的管理和对于死亡通知的管理（告知一方，通讯的另外一方已经死亡）等功能。这些功能的通信过程和上面这幅图是类似的：一方发送BC_XXX，然后由驱动控制通信过程，接着发送对应的BR_XXX命令给通信的另外一方。因为这种相似性，对于这些内容就不再赘述了。  任何进程使用Binder前都需要先通过open(\u0026quot;/dev/binder\u0026rdquo;)打开Binder设备。用户空间的open系统调用对应了驱动中的binder_open函数。\n在打开Binder设备之后，进程还会通过mmap进行内存映射。mmap的作用有如下两个：\n 申请一块内存空间，用来接收Binder通信过程中的数据 对这块内存进行地址映射，以便将来访问  binder_mmap函数对应了mmap系统调用的处理，使用Binder机制，数据只需要经历一次拷贝就可以了，其原理就在这个函数中。\nbinder_mmap这个函数中，会申请一块物理内存，然后在用户空间和内核空间同时对应到这块内存上。在这之后，当有Client要发送数据给Server的时候，只需一次，将Client发送过来的数据拷贝到Server端的内核空间指定的内存地址即可，由于这个内存地址在服务端已经同时映射到用户空间，因此无需再做一次复制，Server即可直接访问，整个过程如下图所示：\n Server在启动之后，调用对/dev/binder设备调用mmap 内核中的binder_mmap函数进行对应的处理：申请一块物理内存，然后在用户空间和内核空间同时进行映射 Client通过BINDER_WRITE_READ命令发送请求，这个请求将先到驱动中，同时需要将数据从Client进程的用户空间拷贝到内核空间 驱动通过BR_TRANSACTION通知Server有人发出请求，Server进行处理。由于这块内存也在用户空间进行了映射，因此Server进程的代码可以直接访问  binder_mmap的时候，会申请一个PAGE_SIZE(通常是4K)的内存。而实际使用过程中，一个PAGE_SIZE的大小通常是不够的。\n在Binder驱动中，并不是真的将对象在进程间来回序列化，而是通过特定的标识来进行对象的传递。通过flat_binder_object来描述需要跨越进程传递的对象。\nflat_binder_object\n1 2 3 4 5 6 7 8 9 10  struct flat_binder_object { __u32\ttype; __u32\tflags; union { binder_uintptr_t\tbinder; /* local object */ __u32\thandle;\t/* remote object */ }; binder_uintptr_t\tcookie; };   Binder驱动负责对这个flat_binder_object描述对象进行翻译。\n每个Binder Server在驱动中会有一个binder_node进行对应。同时，Binder驱动会负责在进程间传递服务对象，并负责底层的转换\nSystemServer的Binder地址是固定的，这个Binder中有一个列表，其他注册服务的Binder会存在这个列表中。\n其他应用想要找第三方服务都在SystemServer的Binder找到相应服务的Binder进行通信。\n当系统启动时调用open()函数打开Binder驱动，然后调用mmap()函数开辟接收IPC数据的Buffer\nServiceManager、IServiceManager、ServiceManagerNative\n先看下三者的类关系：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  public interface IServiceManager extends IInterface{ ... } public abstract class ServiceManagerNative extends Binder implements IServiceManager{ /** * Cast a Binder object into a service manager interface, generating * a proxy if needed. */ static public IServiceManager asInterface(IBinder obj){ if (obj == null) { return null; } IServiceManager in = (IServiceManager)obj.queryLocalInterface(descriptor); if (in != null) { return in; } return new ServiceManagerProxy(obj); } ... class ServiceManagerProxy implements IServiceManager { private IBinder mRemote; public ServiceManagerProxy(IBinder remote) { mRemote = remote; } public IBinder asBinder() { return mRemote; } ... } } public final class ServiceManager { private static IServiceManager sServiceManager; private static IServiceManager getIServiceManager() { if (sServiceManager != null) { return sServiceManager; } // Find the service manager  sServiceManager = ServiceManagerNative .asInterface(Binder.allowBlocking(BinderInternal.getContextObject())); return sServiceManager; } ... }   Framework层 Binder Framework的C++部分的实现位于/frameworks/native/libs/binder/目录下，这部分最终会编译成libbinder.so供其他进程链接使用。\nlibbinder中，将实现分为Proxy和Native两端。Proxy即是Client端，Native是Server端。类名中带有小写字母p的（例如BpInterface），就是指Proxy端。类名带有小写字母n的（例如BnInterface），就是指Native端。\nBpBinder \u0026ndash; BpBinder的实例代表Proxy(Client)端，BpBinder提供了transact方法，用于将Client端的调用的参数封装好发送的Binder驱动。\n1 2 3 4 5 6 7 8 9 10 11 12 13  status_t BpBinder::transact( uint32_t code, const Parcel\u0026amp; data, Parcel* reply, uint32_t flags) { // Once a binder has died, it will never come back to life.  if (mAlive) { status_t status = IPCThreadState::self()-\u0026gt;transact( mHandle, code, data, reply, flags); if (status == DEAD_OBJECT) mAlive = 0; return status; } return DEAD_OBJECT; }   由于每个Binder服务通常都会提供多个服务接口，而这个方法中的参数uint32_t code参数就是用来对服务接口进行编号区分的。当Server端收到请求时(onTransact方法中)根据这个code区分调用了哪个接口。\nBBinder \u0026ndash; BBinder的实例代表了Native(Server)端。它描述了服务的提供方，所有Binder服务的实现者都要继承这个类（的子类），在继承类中，最重要的就是实现onTransact方法，是所有Proxy(Client)端发送请求(通过transact方法)到Native(Server)端的入口。因此onTransact也有code对调用方法接口进行区分。在Java部分的IBinder类中定义了code的范围。\n1 2 3 4 5 6  public interface IBinder { int FIRST_CALL_TRANSACTION = 0x00000001; int LAST_CALL_TRANSACTION = 0x00ffffff; ... }   比如AIDL中我们定义了一个方法getPerson，build后AS会自动帮我们生成如下：\n1 2 3 4 5 6  public interface IMyAidlInterface extends android.os.IInterface{ ... static final int TRANSACTION_basicTypes = (android.os.IBinder.FIRST_CALL_TRANSACTION + 0); static final int TRANSACTION_getPerson = (android.os.IBinder.FIRST_CALL_TRANSACTION + 1); ... }   Binder服务既有自身实现服务的类，也要有给客户端进程调用的类。为了便于开发，这两中类里面的服务接口应当是一致的，例如：假设服务实现方提供了一个接口为add(int a, int b)的服务方法，那么其远程接口中也应当有一个add(int a, int b)方法。因此为了实现方便，本地实现类和远程接口类需要有一个公共的描述服务接口的基类（即上图中的IXXXService）来继承。而这个基类通常是IInterface的子类，IInterface的定义如下：\nIInterface.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  //IInterface.h class IInterface : public virtual RefBase { public: IInterface(); static sp\u0026lt;IBinder\u0026gt; asBinder(const IInterface*); static sp\u0026lt;IBinder\u0026gt; asBinder(const sp\u0026lt;IInterface\u0026gt;\u0026amp;); protected: virtual ~IInterface(); virtual IBinder* onAsBinder() = 0; }; // ----------------------------------------------------------------------  template\u0026lt;typename INTERFACE\u0026gt; inline sp\u0026lt;INTERFACE\u0026gt; interface_cast(const sp\u0026lt;IBinder\u0026gt;\u0026amp; obj) { return INTERFACE::asInterface(obj); } // ----------------------------------------------------------------------  template\u0026lt;typename INTERFACE\u0026gt; class BnInterface : public INTERFACE, public BBinder { public: virtual sp\u0026lt;IInterface\u0026gt; queryLocalInterface(const String16\u0026amp; _descriptor); virtual const String16\u0026amp; getInterfaceDescriptor() const; protected: virtual IBinder* onAsBinder(); }; // ----------------------------------------------------------------------  template\u0026lt;typename INTERFACE\u0026gt; class BpInterface : public INTERFACE, public BpRefBase { public: explicit BpInterface(const sp\u0026lt;IBinder\u0026gt;\u0026amp; remote); protected: virtual IBinder* onAsBinder(); };   BnInterface和BpInterface是两个模板类。INTERFACE便是我们Binder服务接口的基类。BnInterface还继承了BBinder类，由此可以通过复写onTransact方法来提供实现。\nBpInterface继承了BpRefBase，通过这个类的remote方法可以获取到指向服务实现方的句柄。在客户端接口的实现类中，每个接口在组装好参数之后，都会调用remote()-\u0026gt;transact来发送请求，而这里其实就是调用的BpBinder的transact方法，这样请求便通过Binder到达了服务实现方的onTransact中。\n为了对Binder服务进行区分每个Binder服务需要指定一个唯一的标识，这个标识通过getInterfaceDescriptor返回，类型是一个字符串。\n为了便于调用者获取到调用接口，服务接口的公共基类需要提供一个android::sp\u0026lt;IXXX\u0026gt; asInterface方法来返回基类对象指针。\nProcessState是一个Singleton（单例）类型的类，在一个进程中，只会存在一个实例。通过ProcessState::self()接口获取这个实例。一旦获取这个实例，便会执行其构造函数(构造函数中调用open_driver()和mmap()函数)，由此完成了对于Binder设备的初始化工作。\n负责与Binder驱动通信的IPCThreadState也是一个单例类。但这个类不是一个进程只有一个实例，而是一个线程有一个实例。因为mmap需要在内核开辟空间，因此大小是需要限制的，ProcessState定义了其大小BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)。Binder一次通信的数据大小不应大于BINDER_VM_SIZE。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  status_t BBinder::onTransact( uint32_t code, const Parcel\u0026amp; data, Parcel* reply, uint32_t /*flags*/) { switch (code) { case INTERFACE_TRANSACTION: reply-\u0026gt;writeString16(getInterfaceDescriptor()); return NO_ERROR; case DUMP_TRANSACTION: { int fd = data.readFileDescriptor(); int argc = data.readInt32(); Vector\u0026lt;String16\u0026gt; args; for (int i = 0; i \u0026lt; argc \u0026amp;\u0026amp; data.dataAvail() \u0026gt; 0; i++) { args.add(data.readString16()); } return dump(fd, args); } case SHELL_COMMAND_TRANSACTION: { int in = data.readFileDescriptor(); int out = data.readFileDescriptor(); int err = data.readFileDescriptor(); int argc = data.readInt32(); Vector\u0026lt;String16\u0026gt; args; for (int i = 0; i \u0026lt; argc \u0026amp;\u0026amp; data.dataAvail() \u0026gt; 0; i++) { args.add(data.readString16()); } sp\u0026lt;IShellCallback\u0026gt; shellCallback = IShellCallback::asInterface( data.readStrongBinder()); sp\u0026lt;IResultReceiver\u0026gt; resultReceiver = IResultReceiver::asInterface( data.readStrongBinder()); // XXX can\u0026#39;t add virtuals until binaries are updated.  //return shellCommand(in, out, err, args, resultReceiver);  (void)in; (void)out; (void)err; if (resultReceiver != NULL) { resultReceiver-\u0026gt;send(INVALID_OPERATION); } return NO_ERROR; } case SYSPROPS_TRANSACTION: { report_sysprop_change(); return NO_ERROR; } default: return UNKNOWN_TRANSACTION; } }   理解 Android Binder 机制（一）：驱动篇\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-bitmap%E7%BC%93%E5%AD%98%E4%B8%8E%E5%A4%8D%E7%94%A8%E5%8F%8A%E9%95%BF%E5%9B%BE%E5%8A%A0%E8%BD%BD/",
	"title": "Android-Bitmap缓存与复用及长图加载",
	"tags": ["android"],
	"categories": [],
	"series": ["android"],
	"description": "Android-Bitmap缓存与复用及长图加载",
	"content": "bitmap.getPixels();\nbitmap.getRowBytes();\nbitmap.getByteCount();\nbitmap.getAllocationByteCount();\n图像基础知识 ARGB_8888 RGB_565 Bitmap API解析 Bitmap BitmapFactory BitmapFactory.Options  inPreferredConfig\n设置图片解码后的像素格式，如：ARGB8888、RGB565 inSampleSize\n设置图片采样率进行图片缩放显示，比如是2，那么加载的图片的长、宽都是原来的1/2，不改变格式的情况下所占内存大小就是原来的1/4，inSampleSize必须是2的幂  BitmapRegionDecoder "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-context/",
	"title": "Android-Context",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "Android-Context",
	"content": "前言  Context\n抽象基类  ContextImpl\nContext功能真正的实现类 ContextWraper\n看名字就知道ContextWraper虽然继承自Context，但其实它并没有做很多事情，主要通过attachBaseContext(Context newBase)将mBase变量设置成ContextImpl实例，由mBase来代理完成大部分的功能。  Application Service ContextThemeWrapper\n继承自ContextWraper，是一个带有主体功能的Context。ContextThemeWrapper包含一个mTheme变量，可以通过setTheme来设置。  Activity\n继承自ContextThemeWrapper。        Conetext的区别    功能 Application Service Activity     Start an Activity NO1 NO1 YES   Show a Dialog NO NO YES   Layout Inflation YES YES YES   Start a Service YES YES YES   Bind to a Service YES YES YES   Send a Broadcast YES YES YES   Register BroadcastRecivier YES YES YES   Load Resource Values YES YES YES    *NO1表示有条件支持，Application和Service需要在一个新的Task来承载启动的Activity，即启动时Intent需要添加FLAG_ACTIVITY_NEW_TASKflag，否则会报错：\n1 2 3 4  java.lang.RuntimeException: Unable to create application com.xxx.xxx.MyApplication: android.util.AndroidRuntimeException: Calling startActivity() from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag. Is this really what you want?   因为当我们Activity启动Activity时已经存在任务栈，启动默认放在启动Activity的任务栈。但Application和Service启动Activity时程序并不知道当前是否有任务栈或要放到那个任务栈。\n另外只有Activity创建Dialog，如果在其他地方创建会报错：\n1 2  Caused by: java.lang.IllegalStateException: You need to use a Theme.AppCompat theme (or descendant) with this activity.   因为Dialog也是一个Window，但Dialog的Window是一个子Window，它需要依附于一个主Window上。\ngetApplication()和getApplicationContext() 两者最终获取的是同一对象，只是getApplication()是在Activity定义的，getApplicationContext()是在ContextWrapper中定义的。\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-drawondraw/",
	"title": "Android-draw&amp;onDraw",
	"tags": ["android", "自定义view"],
	"categories": [],
	"series": ["自定义view"],
	"description": "Android-draw&amp;onDraw",
	"content": "前言 Android应用将经过测量、布局、绘制的surface缓存数据通过SurfaceFlinger渲染到显示屏幕上，通过Android的刷新机制来刷新绘制。\n应用层负责绘制，系统层负责渲染。\nPaint 初始化一般都需要添加抗锯齿：\nvar paint: Paint = Paint(Paint.ANTI_ALIAS_FLAG)\nPaint.Style 指定绘制的基本体样式。默认FILL\n Paint.Style.FILL 使用填充样式填充几何图形和文本，忽略绘制中与stroke相关的设置。 Paint.Style.STROKE 使用stroke相关的设置绘制几何图形和文本的边线。 Paint.Style.FILL_AND_STROKE 同时填充几何图形和文字及使用stroke相关的设置绘制边线。如果几何图形方向是逆时针可能会产生意外的效果，但单独的FILL或STROKE则没有此问题  Paint.Align Align指定drawText如何相对于[x，y]坐标对齐其文本。默认LEFT\n Paint.Align.LEFT 文本绘制在x，y原点的右侧 Paint.Align.CENTER 文本在x，y原点水平居中绘制 Paint.Align.RIGHT文本绘制在x，y原点的左侧  Paint.Cap 指定了边线和路径的开始和结束的处理方式。默认BUTT\n Paint.Cap.BUTT 线条以实际path长度结束。不超出path Paint.Cap.ROUND stroke呈半圆突出，中心在path的末端.即首尾两端是strokewidth长度直径的半圆。首尾相加多出一个直径（strokewidth）的长度。即实际长度=设置的线条长度+strokewidth Paint.Cap.SQUARE stroke呈方形突出，中心在path的末端.即首尾两端是strokewidth长度边上的正方形。首尾相加多出一个变长（strokewidth）的长度。即实际长度=设置的线条长度+strokewidth  Paint.Join 指定线条和曲线段在线条路径上连接的处理方式。默认为MITER\n Paint.Join.MITER 接合处的外缘以锐角相交 Paint.Join.ROUND 连接的外缘以圆弧相交 Paint.Join.BEVEL 接合处的外缘与直线相交。相交的外部会被切除。  API解析  set(src)将src中的字段复制到此paint。这相当于对所有src字段调用get，并在此字段上调用相应的set方法 getTypeface()/setTypeface(typeface) 获取/设置字体样式。 getTextSize()/setTextSize(textSize) 获取/设置字体大小 getFontMetrics(metrics) 给定paint字体样式和字体大小设置后用此方法获取推荐的行间距 getFontMetricsInt(fmi) getFontMetrics类似，只是结果已经转成int。 getFontSpacing() 该方法直接调用的getFontMetrics(null) getStyle()/setStyle(style) 获取/设置style，canvas.drawBitmap()方法始终假定填充模式 setARGB(int a, int r, int g, int b) getColor()/setColor(color) 获取/设置颜色 setColorFilter(filter) 设置ColorFilter setAlpha(a) 设置alpha。保留setColor(color)中color的r,g,b。只改变a值。 setBlendMode(blendmode) 设置合成模式。混合模式定义源像素（由绘图命令生成）与目标像素（渲染目标的内容）的合成方式。 setStartHyphenEdit(startHyphen) setFontFeatureSettings(settings) setFontVariationSettings(fontVariationSettings) setFlags(flags) setHinting(mode) mode:HINTING_OFF/HINTING_ON 设置字体微调, 由于当今手机密度高，此方法已无用武之地 setAntiAlias(aa)/setDither(dither) 抗锯齿/防抖动 setLetterSpacing(letterSpacing) 设置字母间距。以'EM'为单位。轻微展开间距的典型值是0.05，负值则表示收紧间距 setWordSpacing(float wordSpacing) 设置paint的额外文字间距 setStrokeCap(cap)/setStrokeWidth(width) setMaskFilter(MaskFilter maskfilter) setPathEffect(PathEffect effect) setShader(Shader shader) setStartHyphenEdit(int startHyphen) setStrokeJoin(Join join) setStrokeMiter(float miter) setTextAlign(Align align) 设置文本对其方式 setTextLocales(LocaleList locales) 根据设置的locales绘制文字。比如日语和中文的同一汉字写法可能不一样。 setTextScaleX(float scaleX) 设置文本的水平缩放因子。默认1.0；\u0026lt;1变窄，\u0026gt;1变宽 setTextSkewX(float skewX) 为paint绘制文本的的水平错切因子。默认值为0。对于近似倾斜文本，请使用-0.25左右的值。 setXfermode(Xfermode xfermode) getTextWidths(CharSequence text, int start, int end,float[] widths) getTextRunCursor(CharSequence text, int contextStart, int contextEnd, boolean isRtl, int offset,int cursorOpt) getRunAdvance(CharSequence text, int start, int end, int contextStart,int contextEnd, boolean isRtl, int offset) getOffsetForAdvance(CharSequence text, int start, int end, int contextStart,int contextEnd, boolean isRtl, float advance) getTextRunAdvances(char[] chars, int index,int count, int contextIndex,int contextCount, boolean isRtl,\nfloat[] advances,int advancesIndex) getTextPath(String text, int start, int end,float x, float y, Path path) getTextBounds(CharSequence text, int start, int end,Rect bounds) 返回文字最小矩形边界，什么是最小矩形边界？如果对比measureText会发现measureText计算的文字宽度要大于getTextBounds返回的文字宽度，因为measureText是添加两边了系统默认文字间距的宽度，getTextBounds则是不带系统默认文字间距的 getUnderlinePosition() getUnderlineThickness() setUnderlineText(boolean underlineText) 是都设置下划线 breakText(String text, boolean measureForwards,float maxWidth, float[] measuredWidth) breakText(CharSequence text, int start, int end,boolean measureForwards,float maxWidth, float[] measuredWidth) clearShadowLayer() equalsForTextMeasurement(Paint other) isStrikeThruText() getStrikeThruThickness() getStrikeThruPosition() getFillPath(Path src, Path dst) measureText(CharSequence text, int start, int end) 返回text的宽度。 setShadowLayer(float radius, float dx, float dy, int shadowColor) getShadowLayerRadius() getShadowLayerDx()/getShadowLayerDy() getShadowLayerColor() setFilterBitmap(boolean filter) setElegantTextHeight(boolean elegant) setSubpixelText(boolean subpixelText) setStrikeThruText(boolean strikeThruText) 是否设置删除线 setLinearText(boolean linearText) setFakeBoldText(boolean fakeBoldText) 设置或清除flag:FAKE_BOLD_TEXT_FLAG 是否使用伪粗体 ascent() descent() hasGlyph(String string) reset()  Path Path是由直线、二次曲线和三次曲线组成的复合几何路径。由于其复合及相对无规则性，判断哪些区域是path区域显得尤其重要。换句话说就是判断一个点是不是path内部点。一个点是内部点还是外部点的判断依赖于Direction和FillType。\nPath应用场景\n绘制：可以使用canvas.drawPath(path，paint)绘制，是填充还是描边是由paint样式决定的。\n裁剪：clipPath(path)等\n绘制文字：drawTextOnPath(text, path, hOffset,vOffset, paint)。\nPath.Direction  Path.Direction.CW clockwise 顺时针 Path.Direction.CCW counter-clockwise 逆时针  Path.FillType 填充类型，FillType默认是WINDING\n Path.FillType.WINDING 从判断点延伸出一条射线，判断其交点（该射线不能与path图形相切），假如path从左边穿过射线计数+1，path从右边穿过射线计数-1，若结构不为0则认为该店是path内部点。例如：  1 2 3 4 5  override fun onDraw(canvas: Canvas) { path.addCircle(200f, 200f, 100f, Path.Direction.CW) path.addCircle(300f, 200f, 100f, Path.Direction.CCW) canvas.drawPath(path, paint) }   为什么用Path绘制相交的两个圆如果Direction相同，相交部分会被填充？如果Direction相反相交部分不会被填充？因为Direction相同是相交部分是内部点，Direction相反是相交部分是外部点。我们来分析以下：\n取两圆相交部分一点延伸出一条射线，因为FillType默认是WINDING，不难判断两个圆Direction相反时，两圆从射线两边穿过，计数是0，即该点不是内部点。相反如果两个圆方向相同，两圆从射线同一边穿过，计数为2或-2，非0，即该点是内部点。\n Path.FillType.EVEN_ODD 从判断点延伸出一条射线，判断其交点（该射线不能与path图形相切），若相交点计数是奇数则判断该点是内部点，反之则是内部点。 Path.FillType.INVERSE_WINDING 与WINDING相反 Path.FillType.INVERSE_EVEN_ODD 与EVEN_ODD相反  Path.Op 组合两条path的操作或者说是两个Path对象的逻辑运算，类似集合运算。\nPath.Op.DIFFERENCE 从第一条路径中减去第二条路径\nPath.Op.INTERSECT 两条路径的交集\nPath.Op.UNION 两条路径的并集\nPath.Op.XOR 两个path异或操作。与INTERSECT相反，即并集减去交集。\nPath.Op.REVERSE_DIFFERENCE 从第二条路径中减去第一条路径\nPathMeasure API解析  isEmpty() path是否包含直线或者曲线 reset() 清除path上所有直线和曲线。但不会改变fillType的设置。reset()后path.isEmpty()=true rewind() 清除path上所有直线和曲线且会重置fillType。但会保留内部数据结构以加快重用 op() 多个path做逻辑操作。true表示操作成功，false表示失败 getFillType()/setFillType(FillType ft) 获取/设置fillType isConvex() 返回由路径内容定义的路径凸性。如果一条路径只有一个轮廓，并且只有一个方向的曲线，那么它就是凸的 isInverseFillType() 是否是INVERSE_xx的FillType变量 toggleInverseFillType() 如果FillType是INVERSE_xx修改为xx，如果是xx则修改为INVERSE_xx approximate(float acceptableError) 1 2 3 4 5 6 7 8 9  //将path拆分为一系列的线段。每三个float元素表示一个点。该三个点分别表示1.起始点到这个点的长度占整个path的比例2.x坐标3.y坐标 //acceptableError 路径上的连段可接受的误差。通常这是0.5，以便误差小于半像素 @Size(min = 6, multiple = 3) public float[] approximate(@FloatRange(from = 0) float acceptableError) { if (acceptableError \u0026lt; 0) { throw new IllegalArgumentException(\u0026#34;AcceptableError must be greater than or equal to 0\u0026#34;); } return nApproximate(mNativePath, acceptableError); }    close() 闭合当前轮廓。如果当前点不等于轮廓的第一个点会自动添加一个点段链接当前点和第一个点闭合轮廓。 incReserve(extraPtCount) 提示path准备添加更多点。这可以更有效地给path分配存储。extraPtCount：添加到path的额外点数 setLastPoint(dx,dy) 设置path的最后一个点。dx：相对于当前path最后一个点的x偏移量；dy：相对于当前path最后一个点的x偏移量 transform(matrix) 通过矩阵变换path中的点 transform(matrix, dst) 通过矩阵变换path中的点，并将变换结果写入dst。如果dst为空，则修改原始path offset(dx,dy) 将当前path偏移指定dx,dy offset(dx,dy,dst) 偏移指定dx,dy后将变换的结果写入dst。如果dst为空，则修改原始path set(src) 将当前path内容替换为src的内容 isRect(rect) 当前path边界是否是矩形，如果是矩形返回true，并且rect不为null的情况下将path边界数据赋值给rect。如果不是矩形则返回false并忽略参数rect computeBounds(bounds, exact) 计算路径控制点边界并将结果写入bounds。如果路径没有控制点或者只有一个控制点，则bounds返回(0,0,0,0) moveTo(x, y) 一般是path下一个轮廓的开始，即将下一个轮廓的起点设置为点(x, y) lineTo(x, y) 添加一条直线从轮廓最后一个点到指定点(x, y)，做没有使用moveTo(x, y)开始这个轮廓则默认第一个点是(0, 0) addRect() 向path添加一个闭合的矩形轮廓 addRoundRect() 将闭合的圆角矩形轮廓添加到path addArc(oval, startAngle, sweepAngle) 将指定的圆弧作为一个新轮廓添加到path中。oval：定义圆弧形状和大小的椭圆边界；startAngle：开始角度(x正轴是0度)；sweepAngle：startAngle开始顺时针方向的角度。 arcTo(oval, startAngle, sweepAngle,forceMoveTo) 将指定的圆弧作为一个新轮廓添加到path中，如果路径的最后一个点不同于圆弧的起始点则添加一个lineTo操作连接最后一个点和圆弧起点。如果路径是空的则添加一个moveTo操作，移动到圆弧的起点。oval：定义圆弧形状和大小的椭圆边界；startAngle：开始角度(x正轴是0度)；sweepAngle：startAngle开始顺时针方向的角度；forceMoveTo：是否强制使用moveTo移动到圆弧起点，若为true，则路径的最后一个点不同于圆弧的起始点是使用moveTo而不是lineTo。addArc相当于arcTo(oval, startAngle, sweepAngle,true) addCircle() 将闭合的圆形轮廓添加到path addOval() 将闭合的椭圆形轮廓添加到path addPath(src) 将src副本添加到path addPath(src, dx, dy) 将经过平移dx,dy的src副本添加到path addPath(src, matrix) 将经过matrix变换的src副本添加到path quadTo(x1, y1, x2, y2) 将一个以路径最后一个点为起始点，(x1, y1)为控制点，(x2, y2)为结束点的二阶贝塞尔轮廓添加到路径。做没有使用moveTo(x, y)开始这个轮廓则默认第一个点是(0, 0) cubicTo(x1, y1, x2, y2,x3, y3) 将一个以路径最后一个点为起始点，(x1, y1)为第一控制点，(x2, y2)为第二控制点，(x3, y3)为结束点的三阶贝塞尔轮廓添加到路径。做没有使用moveTo(x, y)开始这个轮廓则默认第一个点是(0, 0) rXXX() 相应操作的相对模式  Region Region.Op 组合两个Region的操作或者说是两个Region对象的逻辑运算，类似集合运算。\nRegion.Op.DIFFERENCE 从第一个Region中减去第二个Region\nRegion.Op.INTERSECT 两个Region区域的交集\nRegion.Op.UNION 两个Region区域的并集\nRegion.Op.XOR 两个Region异或操作。与INTERSECT相反，即并集减去交集。\nRegion.Op.REVERSE_DIFFERENCE 从第二个Region区域中减去第一个Region区域\nRegion.Op.REPLACE 只取第二个Region部分\nAPI解析  isEmpty() Region是否为空 setEmpty() 设置Region为空region getBounds() 返回Region的矩形边界 getBoundaryPath() 将Region的边界作为path返回。若Region为空，返回的path也是空path isComplex() 如果Region包含超过一个矩形则返回true isRect() 如果Region包含有一个矩形返回true contains(x, y) 如果点(x,y)包含在Region内返回true quickContains(r) 如果Region是单个矩形(即非复杂图形，isComplex()=false)且Region区域包含矩形r则返回true。返回false并不代表Region区域不包含矩形r区域，有可能是因为Region是一个复杂图形，即isComplex()=true quickReject(r) 如果Region是空或者和矩形r区域不相交则返回true。返回flase并不保证相交但返回true一定保证不相交 quickReject(rgn) 如果Region是空或者和区域rgn不相交则返回true。返回flase并不保证相交但返回true一定保证不相交 set(r[|region]) 设置Region区域为指定的矩形r（或执行的区域region） setPath(path, clip) 将Region设置为path和clip所描述的区域，如果该区域不是空则返回true。此方法将生成一个与path相同的像素绘制区域（无抗锯齿）。path中超过clip的区域将被裁剪。 translate(dx, dy, dst) 将变换dx, dy后的Region结果赋给dst，若dst为null，则修改自己。 op(rect, region,op) 将Region与rect和region经过op操作后的结果设置给Region。  RegionIterator\u0026amp;Region的绘制 canvas并没有直接绘制Region的方法。但可以通过RegionIterator\n1 2 3 4 5 6 7 8 9 10 11  override fun onDraw(canvas: Canvas) path.addCircle(500f, 500f, 300f, Path.Direction.CW); val region = Region(); region.setPath(path, Region(0, 0, 700, 600)); val iterator = RegionIterator(region); val rect = Rect(); while (iterator.next(rect)) { canvas.drawRect(rect, paint); } }   从绘制代码可以看出Region的绘制机制实际上是把自己切分成多个细小的矩形区域进制绘制，三个矩形区域可能是一像素或者几个像素宽高，所以当Region是path时可能无法在整体上做到抗锯齿。实际上Region主要作用并不是用于绘制，所以也没必要做抗锯齿。\nPath\u0026amp;Region 以上可以知道Region无直接绘制方法且可能无法做到抗锯齿，而Path可以。Path还几乎可以做Region所能做的所有操作，为什么不直接用Path替代Region呢？因为Region有一点是Path无法替代的：判断某个点是否在某个区域。比如一个不规则区域(圆形按钮)，我们想实现非不规则区域不响应点击事件可以使用Region判断。\nCanvas API解析  isHardwareAccelerated() canvas 是否使用了硬件加速 4.0后默认开启硬件加速。可以通过view.setLayerType(View.LAYER_TYPE_SOFTWARE,null)关闭view硬件加速 setBitmap(Bitmap bitmap) 重置之前的所有状态然后绘制bitmap。在API26之前，当前矩阵和剪辑堆栈被保留。bitmap:必须是可变的，即bitmap.isMutable=true setMatrix(Matrix matrix) 使用指定矩阵替换当前矩阵。如果matrix是null，则当前矩阵会被重置为单位矩阵。官方建议使用concat(Matrix)/scale(float, float)/translate(float, float)/rotate(float)代替此方法 drawBitmap(bitmap, src, dst, paint) src：需要绘制bitmap的区域(部分)，可以裁剪图片。 dst：需要绘制到canvas哪个区域 drawBitmap(bitmap, left, top, paint) left:绘制bitmap（在canvas）的左边起始位置 top：绘制bitmap（在canvas）的上边起始位置 drawBitmap(bitmap, matrix, paint) 使用指定matrix绘制bitmap drawBitmapMesh(@NonNull Bitmap bitmap, int meshWidth, int meshHeight,float[] verts, int vertOffset, int[] colors, int colorOffset,Paint paint) 使用网格绘制bitmap meshWidth:横向网格数或网格列数 meshHeight：纵向网格数或网格行数 verts：顶点数，两个一对表示一个定点的x,y值，verts的大小至少是(meshWidth+1) * (meshHeight+1) * 2 + vertOffset vertOffset：绘制前要跳过的顶点元素数 colors:可能为空。指定每个顶点处的颜色，该颜色与在相应单元格内的位图颜色叠加。如果不为空，则数组中必须至少有（meshWidth+1）*（meshHeight+1）+colorOffset值 colorOffset：绘制前要跳过的颜色元素数 drawPath(path, paint) 绘制path，path是被填充还是绘制边宽依赖paint的Style drawRGB(r, g, b) 使用srcover porterduff模式，用指定的RGB颜色填充整个画布的位图（仅限于当前clip区域） drawARGB(a, r, g, b) 使用srcover porterduff模式，用指定的ARGB颜色填充整个画布的位图（仅限于当前clip区域） drawColor(int color, PorterDuff.Mode mode) 用指定的颜色和porterduff xfermode填充整个画布的位图（仅限于当前clip区域） drawColor(int color, BlendMode mode) 用指定的颜色和blendmode填充整个画布的位图（仅限于当前clip区域） drawArc(oval, startAngle, sweepAngle, useCenter, paint) oval:扇形椭圆区域 startAngle：开始角度(x正轴是0度)；sweepAngle：startAngle开始顺时针方向的角度 useCenter：是否包含椭圆区域中心，false则只绘制扇形两点相连的区域 true会绘制扇形亮点分别与椭圆区域中心相连的区域 drawCircle(cx, cy, radius, paint) 不解释。 drawOval(RectF oval, Paint paint) 不解释。 drawRect(RectF rect, Paint paint) 不解释。 ddrawRoundRect(RectF rect, float rx, float ry, Paint paint) 不解释。 drawDoubleRoundRect(RectF outer, float[] outerRadii,RectF inner, float[] innerRadii, Paint paint) drawLine() 绘制一条直线 drawLines(float[] pts, int offset, int count,Paint paint) offset:绘制前从pts跳过的个数 count：从offset绘制的个数 drawPoints(float[] pts, int offset, int count,Paint paint) 类比drawLines drawPicture(Picture picture, RectF dst) 绘制Picture。Picture的作用是提高绘制效率，比如你用canvas连续绘制多个几个图形不如先在Picture上绘制连续的多个几何图形，在使用canvas绘制picture，这样效率更高。 drawText(CharSequence text, int start, int end, float x, float y, Paint paint) start:要绘制的文本中第一个字符的索引 end:要绘制的文本中最后一个字符的索引，不包含end x：文本绘制位置的原点x坐标 y：文本绘制位置的原点y坐标 drawTextOnPath(String text, Path path, float hOffset, float vOffset, Paint paint) 沿path绘制文字，paint的Align决定了沿path何处开始绘制文本 hOffset：沿路径绘制文本的水平偏移量 vOffset：沿路径绘制文本的纵向偏移量 drawTextRun(CharSequence text, int start, int end, int contextStart,int contextEnd, float x, float y, boolean isRtl, Paint paint) 绘制文本，和drawText的区别是增加了文字上下文支持。什么是文字上下文？在一些文字中，比如阿拉伯文字，一个文字单独写和这个文字与某些其他文字一起写时写法是不一样的，我们熟悉的汉字和英文是没有这种情况的。知道这些我们应该知道contextStart和contextEnd的意义了。0 \u0026lt;= contextStart \u0026lt;= start \u0026lt;= end \u0026lt;= contextEnd\u0026lt;= text.length drawTextRun(MeasuredText text, int start, int end, int contextStart,int contextEnd, float x, float y, boolean isRtl, Paint paint) MeasuredTexts是Android Q增加的用于处理文字的类。具体看文档 drawVertices(VertexMode mode, int vertexCount, float[] verts,int vertOffset, float[] texs, int texOffset, int[] colors,int colorOffset, short[] indices, int indexOffset, int indexCount, Paint paint) 类似于opengl drawRenderNode(RenderNode renderNode) RenderNode需要Android Q版本。 drawPaint(Paint paint) 使用指定的paint填充整个画布的位图（仅限于当前clip区域），这相当于（但速度更快）使用指定的paint绘制无限大的矩形。 setDrawFilter(DrawFilter filter) 在canvas层面设置绘制过滤器。DrawFilter的唯一子类PaintFlagsDrawFilter可以使用：canvas.setDrawFilter(PaintFlagsDrawFilter(0, Paint.ANTI_ALIAS_FLAG))，这样在canvas层面增加抗锯齿效果（即使paint没有添加抗锯齿效果） clipPath(Path path) 裁剪path区域 clipOutPath(Path path) 裁剪path意外区域 clipRect(RectF rect) 裁剪rect区域 clipOutRect(RectF rect) 裁剪rect意外区域 getClipBounds() 当前剪辑的边界（在本地坐标中）。 concat(Matrix matrix) 使用指定矩阵matrix叠加当前矩阵。matrix是null则不做任何操作 rotate(float degrees, float px, float py) 画布旋转，不解释 scale(float sx, float sy, float px, float py) 画布缩放，不解释 skew(float sx, float sy) 画布错切，不解释 translate(float dx, float dy) 画布位移，不解释 save() save()是和restore()配合使用的。save()保存当前matrix和clip到私有堆栈上，随后对translate、scale、rotate、skew、concat或clipRect、clipPath的调用将在调用restore()后被忘记并回复到save()之前的设置。返回值是restoreToCount(int saveCount)时回复到指定save状态需要传递的参数。简单来说save()后的各种操作是在当前图层绘制和操作而后面的saveLayer则是在新的离屏图层绘制操作。 saveLayer(RectF bounds, Paint paint) 行为和save()相同，但它还将分配并重定向到离屏的渲染目标。注意：这种方法非常昂贵，对包含的内容产生的渲染成本是原来的两倍多。尽可能避免使用此方法，而是在视图上使用View#LAYER_TYPE_HARDWARE hardware 图层来应用xfermode、color filter或alpha，因为它的性能比此方法好得多。所有绘图调用都指向新分配的离屏渲染目标。只有在调用restore()时，才会将离屏缓冲区内容绘制到上一图层（嵌套调用时）或者canvas画布上。 saveLayerAlpha(RectF bounds, int alpha) 类似saveLayer()。 getSaveCount() 等于save()调用次数-restore()调用次数 restore() 返回最近一次save()的状态，删除最近一次save()之后对matrix/clip状态的所有修改。restore()调用次数不应该多于save()次数。 restoreToCount(int saveCount) 返回指定的某次save()状态。restore()是返回最近一次save()状态；restoreToCount(int saveCount)返回指定的save()=saveCount的状态 quickReject(RectF rect, EdgeType type) 如果指定的rect区域在被当前矩阵变换后完全位于当前剪辑之外，则返回true。调用此函数以检查要绘制的区域是否被剪裁掉。EdgeType.BW(Black-and-White)：非抗锯齿 EdgeType.AA(Antialiased):抗拒次，表示实际检测区域是rect的抗锯齿区域，即比rect范围大。 quickReject(Path path, EdgeType type) 如果指定的path区域在被当前矩阵变换后完全位于当前剪辑之外，则返回true。调用此函数以检查要绘制的区域是否被剪裁掉。 disableZ() 禁用Z轴支持（比如：translationZ），防止在此点之后绘制的任何rendernode被可视地重新排序或渲染阴影。这不受任何ave()或restore()调用的影响，因为它不被视为当前矩阵或剪辑的一部分 enableZ() 启用Z轴支持 setDensity(int density) 见参考android大屏幕解决图片被放大问题 isOpaque() 是否不透明，如果当前层绘制的设备不透明，则返回true（即不支持每像素alpha）。 getWidth()/getHeight() 返回当前绘图层的宽度/高度 getMaximumBitmapWidth()/getMaximumBitmapHeight() 返回使用此画布绘制的位图所允许的最大宽度。尝试使用比此值更宽的位图绘制将导致错误。  为什么使用save()和restore()？你可能有疑问我们画的时候可以做相应偏移缩放旋转啊，理论上是可以但是有时候使用画布做相应变化更简便容易。\ndrawXXX和使用path实现的区别 比如drawLine(100，100，200，200)和下面代码中利用path实现\n1 2 3 4 5 6  path.moveTo(100, 100) path.lineTo(200, 200) paint.strokeWidth = Utils.dp2px(5f) override fun onDraw(canvas: Canvas) { canvas.drawPath(path, paint) }   两者有何区别？\n你会发现drawLine()可以绘制，drawPath却不一定可以绘制，只有paint.style非Paint.Style.FILL时，使用path实现的代码才能绘制出一条直线。线段是没有大小的，而drawLine()会忽略paint.style的设置直接使用Paint.Style.STROKE。drawPath()则不会。\nAndroid绘制的基础知识 文字的测量及绘制 canvas.drawText(CharSequence text, int start, int end, float x, float y, Paint paint) x/y分别是绘制文字的x,y起点。但需要注意的是绘制文字的起点并不是文字的左上角。而是文字边界的x坐标值和文字baseline的y坐标值。当我们指定paint.textAlign = Paint.Align.CENTER时x指的是文字水平宽度的中心坐标值，y依然是baseline的y坐标值。\n如何文字居中？\n 横向对其\n默认的系统都会给文字左右留有间距。当字号相差较大且换行时看起来文字左边并不对其。如果想绘制时想避免间距可以绘制时做相应偏移 1 2  val textBounds = Rect() canvas.drawText(text, 0, text.length, -textBounds.left, 300f, paint)    纵向对齐   使用getTextBounds计算 1 2 3 4 5  val textBounds = Rect() paint.getTextBounds(text, 0,text.length, textBounds) val offsetY = (textBounds.top + textBounds.bottom) / 2f //假设我们期望的中心坐标值是(centerX,centerY)，只需要 canvas.drawText(text,0,text.length,centerX,centerY - offsetY,paint)   该方法的好处是文字中体绝对居中，但部分文字比如：a,p,q字母看起来没那么居中，而b这样的字母看起来居中。另外如果文字是动态的那么可能出现文字跳动的情况，以为前一次文字可能是aaaa,而后变为ppppp，中心位置发生了变化。\n 使用getFontMetrics() 1 2 3 4  val fontMetrics = paint.fontMetrics val offsetY = (fontMetrics.ascent + fontMetrics.descent) / 2f //假设我们期望的中心坐标值是(centerX,centerY)，只需要 canvas.drawText(text,0,text.length,centerX,centerY - offsetY,paint)   该方法整体没有getTextBounds那么绝对居中，而且如果文字都是aaaa看起来会靠下一些，但基本满足要求而且当文字动态时不会出现跳动的情况。\n   多行绘制  StaticLayout paint.breakText()    Path在Android中的使用 Picture Xfermode PorterDuffXfermode\nShader Shader（着色器）是一个绘制期间返回水平跨度颜色的基类对象。当调用paint.setShader(shader)后使用该paint绘制的任何对象(除了位图)都将从shader获取颜色\n BitmapShader LinearGradient RadialGradient SweepGradient ComposeShader  RenderNode Camera及Camera坐标系 参考：\n android大屏幕解决图片被放大问题 Android硬件位图填坑之获取硬件画布 · Hiten’s Blog. 自定义控件其实很简单1/3  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-ffmpeg%E4%BD%BF%E7%94%A8/",
	"title": "Android-FFmpeg使用",
	"tags": ["ffmpeg", "音视频", "android"],
	"categories": [],
	"series": [""],
	"description": "Android中FFmpeg的使用",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-ffmpeg%E6%89%93%E9%80%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E6%92%AD%E6%94%BE%E5%99%A8/",
	"title": "Android-FFmpeg打造自己的播放器",
	"tags": ["ffmpeg", "音视频"],
	"categories": [],
	"series": ["音视频"],
	"description": "Android-FFmpeg打造自己的播放器",
	"content": "如何实现 播放音频  SDL2 AudioTrack OpenSLES ijksdl  播放视频  SDL2 SurfaceView ANativeWindow ijksdl  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-ffmpeg4.x%E7%BC%96%E8%AF%91/",
	"title": "Android-FFmpeg编译及数据结构分析",
	"tags": ["音视频"],
	"categories": [],
	"series": ["音视频"],
	"description": "Android-FFmpeg编译及数据结构分析",
	"content": "FFmpeg简介 以下翻译自官网About FFmpeg\nlibavutil FFmpeg公共的工具函数以及数据结构库，其中包括随机数生成器、AVFrame等。\nlibavcodec 用于音视频编码和解码的库。\nlibavformat 用于多媒体容器格式的封装(复用)和解封装(解复用)的库。\nlibavdevice 用于从设备中采集及向设备输出显示。可以从许多常见的多媒体输入/输出软件框架（包括Video4Linux，Video4Linux2，VfW和ALSA）中获取和呈现。\nlibavfilter 用于音视频过滤器的库，比如给视频加上水印、视频裁剪等。\nlibswscale 用于图像的缩放和格式转换的库。\nlibswresample 用于对音频转码的库，包括音频重采样，重矩阵化和样本格式转换操作。\nlibpostproc 用于后期效果处理的库，如图像的去块效应。\nlibavresample 已经被官方建议使用libswresample替代，两者的关系可以参考libswresample与libavresample\nffserver 用于直播的多媒体流服务器，4.xx.xx版本的FFmpeg已经将ffserver移除了。\nffplay 一个基于SDL和FFmpeg的多媒体播放器。ffplay也是很经典的，被很多初学播放器的开发者所学习。但是SDL官方给出的Android版本耦合严重，在Android上一般不会采用SDL来显示。\nffprobe 一个简单的多媒体流分析器，用于查看多媒体文件信息。\nFFmpeg4.1.5编译 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123  ABIs=(armeabi-v7a arm64-v8a) FFMPEG_DIR=$( cd \u0026#34;$(dirname $0)\u0026#34; pwd ) PREFIX=\u0026#34;$FFMPEG_DIR/android\u0026#34; NDK_HOME=\u0026#34;/Users/dscao/android-ndk/android-ndk-r20b\u0026#34; # 检查当前编译系统 host=$(uname | tr \u0026#39;A-Z\u0026#39; \u0026#39;a-z\u0026#39;) if [ $host = \u0026#34;darwin\u0026#34; ] || [ $host = \u0026#34;linux\u0026#34; ]; then echo \u0026#34;system: $host\u0026#34; else echo \u0026#34;unsupport system, only support Mac OS X and Linux now.\u0026#34; exit 1 fi machine=$(uname -m) TOOLCHAINS=${NDK_HOME}/toolchains/llvm/prebuilt/${host}-${machine} checkError(){ if [ $1 -ne 0 ]; then if [ -n $2 ];then echo $2 else echo \u0026#34;error building ffmpeg\u0026#34; fi exit 1 fi } makeDir() { if [ ! -x \u0026#34;$1\u0026#34; ]; then mkdir -p \u0026#34;$1\u0026#34; fi } build_and(){ ABI=$1 ARCH=$2 CPU=$3 AAPI=$4 SYSROOT=$5 CROSS_PREFIX=$6 CC=$7 ECFLAGS=$8 cd $FFMPEG_DIR LIB_X264_DIR=\u0026#34;${FFMPEG_DIR}/x264\u0026#34; LIB_FDKAAC_DIR=\u0026#34;$(dirname $(pwd))/fdk-aac/android\u0026#34; rm -rf ${PREFIX}/${ABI} makeDir ${PREFIX}/${ABI} checkError $? \u0026#34;ffmpeg 创建${PREFIX}/${ABI}目录失败\u0026#34; ./configure \\  --prefix=${PREFIX}/${ABI} \\  --arch=${ARCH} \\  --cpu=${CPU} \\  --target-os=android \\  --enable-cross-compile \\  --disable-static \\  --enable-shared \\  --extra-cflags=\u0026#34;-I${LIB_X264_DIR}/${ABI}/include -I${LIB_FDKAAC_DIR}/${ABI}/include -DANDROID -lc -lm -ldl\u0026#34; \\  --extra-ldflags=\u0026#34;-L${LIB_X264_DIR}/${ABI}/lib -L${LIB_FDKAAC_DIR}/${ABI}/lib -L${SYSROOT}/usr/lib -lc -lm -ldl\u0026#34; \\  --enable-gpl \\  --enable-version3 \\  --enable-nonfree \\  --enable-protocols \\  --enable-avresample \\  --enable-neon \\  --enable-mediacodec \\  --enable-jni \\  --enable-pthreads \\  --enable-libfdk-aac \\  --enable-encoder=libfdk_aac \\  --enable-decoder=aac \\  --enable-decoder=aac_latm \\  --enable-libx264 \\  --enable-encoder=libx264 \\  --enable-decoder=h264 \\  --enable-pic \\  --disable-programs \\  --disable-ffmpeg \\  --disable-ffplay \\  --disable-ffprobe \\  --disable-doc \\  --disable-asm \\  --disable-symver \\  --cc=\u0026#34;${TOOLCHAINS}/bin/${CC}${AAPI}-clang\u0026#34; \\  --cxx=\u0026#34;${TOOLCHAINS}/bin/${CC}${AAPI}-clang++\u0026#34; \\  --cross-prefix=\u0026#34;${TOOLCHAINS}/bin/${CROSS_PREFIX}\u0026#34;\\  --sysroot=\u0026#34;${TOOLCHAINS}/sysroot\u0026#34; \\  --extra-cflags=\u0026#34;-D__ANDROID_API__=${AAPI}${ECFLAGS}\u0026#34; \\  --extra-ldflags=\u0026#34;\u0026#34; \\  make clean checkError $? \u0026#34;ffmpeg make clean 过程出错\u0026#34; make -j4 \u0026amp;\u0026amp; make install checkError $? \u0026#34;ffmpeg make\u0026amp;make install 过程出错\u0026#34; } # build start if [ -z \u0026#34;$NDK_HOME\u0026#34; ]; then echo \u0026#34;NDK_HOME not set\u0026#34; exit 1 fi echo \u0026#34;$(dirname $(pwd))/x264\u0026#34; for abi in ${ABIs[*]}; do case $abi in armeabi-v7a) build_and $abi \u0026#34;arm\u0026#34; \u0026#34;armv7-a\u0026#34; \u0026#34;16\u0026#34; \u0026#34;${NDK_HOME}/sysroot\u0026#34; \u0026#34;arm-linux-androideabi-\u0026#34; \u0026#34;armv7a-linux-androideabi\u0026#34; \u0026#34;-marm -U_FILE_OFFSET_BITS -DBIONIC_IOCTL_NO_SIGNEDNESS_OVERLOAD -Os -fPIC -DANDROID -D__thumb__ -mthumb -Wfatal-errors -Wno-deprecated -mfloat-abi=softfp\u0026#34; ;; arm64-v8a) build_and $abi \u0026#34;aarch64\u0026#34; \u0026#34;armv8-a\u0026#34; \u0026#34;21\u0026#34; \u0026#34;${NDK_HOME}/sysroot\u0026#34; \u0026#34;aarch64-linux-android-\u0026#34; \u0026#34;aarch64-linux-android\u0026#34; \u0026#34;-U_FILE_OFFSET_BITS -DBIONIC_IOCTL_NO_SIGNEDNESS_OVERLOAD -Os -fPIC -DANDROID -D__thumb__ -mthumb -Wfatal-errors -Wno-deprecated -mfloat-abi=softfp\u0026#34; ;; esac done exit 0   数据结构解析 AVFrame AVFrame是（解码后的）原始的音频和视频数据，因为AVFrame既表示音频数据又要表示视频数据，所以结构体中有些成员是对音频有效视频无效的，有些是对视频有效音频无效的。同时AVFrame既表示是解码后的数据又是编码前的数据\nAVFrame必须通过av_frame_alloc()/av_frame_free()一对函数分别分配内存和释放内存。当我们想重复使用一个AVFrame对象时可以通过av_frame_alloc()先分配内存，当接收使用过数据后使用av_frame_unref()释放该帧持有的任何引用并重置为分配内存时的原始状态重新使用，最后在不需要的时候再调用av_frame_free()释放内存。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367  typedef struct AVFrame { #define AV_NUM_DATA_POINTERS 8 /** * data指向picture/channel的planes，如data[0]=plane0,data[1]=plane1,data[2]=plane2；如果只有一个plane则只有data[0]有数据 * 对于打包(packet)格式： * 1.音频，如双声道L,R两个channel，其数据LRLRLR形式交织存储在一个plane * 1.视频，如NV21 YYYYYYYYVUVU形式存储在一个plane中 * 对于平面(planar)格式： * 1.音频，如双声道L,R两个channel，其数据LLLRRR形式存储在两个plane 中，data[0]=planeL,data[1]=planeR * 1.视频，如YU12(I420) YYYYYYYYUUVV形式存储在三个plane中，data[0]=planeY,data[1]=planeU,data[2]=planeV */ uint8_t *data[AV_NUM_DATA_POINTERS]; /** * 对于视频指的是图像每一行的字节大小 * 对于视频则是每个plane的大小，对于packet格式的音频数据只有一个plane,对于planar格式的音频数据每个channel的plane又必须相同大小 * 所以对于音频数据实际上只使用inesize[0] * * 对于视频linesizes的大小应该是CPU对齐首选项的倍数，对于现代计算机来说就是16或者32。 * 对于有些代码需要这样的对齐否则运行会很慢，而有些则不需要 * * linesize可能大于实际可用数据的大小，因为出于性能原因可能会有额外的填充 */ int linesize[AV_NUM_DATA_POINTERS]; /** * pointers to the data planes/channels. * * For video, this should simply point to data[]. * * For planar audio, each channel has a separate data pointer, and * linesize[0] contains the size of each channel buffer. * For packed audio, there is just one data pointer, and linesize[0] * contains the total size of the buffer for all channels. * * Note: Both data and extended_data should always be set in a valid frame, * but for planar audio with more channels that can fit in data, * extended_data must be used in order to access all channels. */ uint8_t **extended_data; /** * 仅限视频帧有效，视频帧的像素尺寸大小 */ int width, height; /** * @} */ /** * 音频帧（每个通道）的采样数 */ int nb_samples; /** * 音频 AVSampleFormat的枚举值 * 视频 AVPixelFormat的枚举值 * -1表示未设置或者未知的格式 */ int format; /** * 1表示是关键帧(I帧)，0表示是非关键帧 */ int key_frame; /** * 视频帧类型，见：AVPictureType */ enum AVPictureType pict_type; /** * 视频帧(采样)的纵横比，0表示未知，1表示位指定 */ AVRational sample_aspect_ratio; /** * 向用户显示(播放)帧的时间戳(以time_base为单位) */ int64_t pts; #if FF_API_PKT_PTS /** * 解码成AVFrame时从AVPacket复制的pts，已被废弃，推荐使用pts代替,大于等于57的api中已不在定义该字段 */ attribute_deprecated int64_t pkt_pts; #endif /** * 解码时从AVPacket复制的dts。这也是AVFrame的pts如果AVPacket只有dts而没有pts */ int64_t pkt_dts; /** * 编码流中的图像序号 */ int coded_picture_number; /** * 帧在显示序列的图像序号 */ int display_picture_number; /** * 质量(1(好)~FF_LAMBDA_MAX(坏)) */ int quality; /** * 用户想要在帧中携带的私有数据 */ void *opaque; #if FF_API_ERROR_FRAME /** * @deprecated unused */ attribute_deprecated uint64_t error[AV_NUM_DATA_POINTERS]; #endif /** * When decoding, this signals how much the picture must be delayed. * extra_delay = repeat_pict / (2*fps) */ int repeat_pict; /** * 图像逐行/隔行模式标识。图像的内容是否隔行扫描（交错帧） */ int interlaced_frame; /** * 如果内容是交错的，则会首先显示顶部字段 */ int top_field_first; /** * 告诉用户应用程序调色板已从上一帧更改。 */ int palette_has_changed; /** * reordered opaque 64 bits (generally an integer or a double precision float * PTS but can be anything). * The user sets AVCodecContext.reordered_opaque to represent the input at * that time, * the decoder reorders values as needed and sets AVFrame.reordered_opaque * to exactly one of the values provided by the user through AVCodecContext.reordered_opaque * @deprecated in favor of pkt_pts */ int64_t reordered_opaque; /** * 音频采样率 */ int sample_rate; /** * 声道布局AV_CH_XX */ uint64_t channel_layout; /** * AVBuffer references backing the data for this frame. If all elements of * this array are NULL, then this frame is not reference counted. This array * must be filled contiguously -- if buf[i] is non-NULL then buf[j] must * also be non-NULL for all j \u0026lt; i. * * There may be at most one AVBuffer per data plane, so for video this array * always contains all the references. For planar audio with more than * AV_NUM_DATA_POINTERS channels, there may be more buffers than can fit in * this array. Then the extra AVBufferRef pointers are stored in the * extended_buf array. */ AVBufferRef *buf[AV_NUM_DATA_POINTERS]; /** * For planar audio which requires more than AV_NUM_DATA_POINTERS * AVBufferRef pointers, this array will hold all the references which * cannot fit into AVFrame.buf. * * Note that this is different from AVFrame.extended_data, which always * contains all the pointers. This array only contains the extra pointers, * which cannot fit into AVFrame.buf. * * This array is always allocated using av_malloc() by whoever constructs * the frame. It is freed in av_frame_unref(). */ AVBufferRef **extended_buf; /** * extended_buf元素个数 */ int nb_extended_buf; AVFrameSideData **side_data; /* * side_data元素个数 */ int nb_side_data; /** * @defgroup lavu_frame_flags AV_FRAME_FLAGS * @ingroup lavu_frame * Flags describing additional frame properties. * * @{ */ /** * The frame data may be corrupted, e.g. due to decoding errors. */ #define AV_FRAME_FLAG_CORRUPT (1 \u0026lt;\u0026lt; 0)/** * A flag to mark the frames which need to be decoded, but shouldn\u0026#39;t be output. */ #define AV_FRAME_FLAG_DISCARD (1 \u0026lt;\u0026lt; 2)/** * @} */ /** * Frame flags, a combination of @ref lavu_frame_flags */ int flags; /** * MPEG vs JPEG YUV range. * - encoding: Set by user * - decoding: Set by libavcodec */ enum AVColorRange color_range; enum AVColorPrimaries color_primaries; enum AVColorTransferCharacteristic color_trc; /** * YUV colorspace type. * - encoding: Set by user * - decoding: Set by libavcodec */ enum AVColorSpace colorspace; enum AVChromaLocation chroma_location; /** * 流时间基为单位使用启发式方法估算的帧的时间戳，通常作为帧的pts使用，正常情况和pts是一样的。 * 使用best_effort_timestamp作为帧的pts是更好的选择 * - encoding: unused * - decoding: set by libavcodec, read by user. */ int64_t best_effort_timestamp; /** * reordered pos from the last AVPacket that has been input into the decoder * - encoding: unused * - decoding: Read by user. */ int64_t pkt_pos; /** * 以流时间基为单位的packet的持续时间，如果是0表示未知 * - encoding: unused * - decoding: Read by user. */ int64_t pkt_duration; /** * metadata. * - encoding: Set by user. * - decoding: Set by libavcodec. */ AVDictionary *metadata; /** * decode error flags of the frame, set to a combination of * FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there * were errors during the decoding. * - encoding: unused * - decoding: set by libavcodec, read by user. */ int decode_error_flags; #define FF_DECODE_ERROR_INVALID_BITSTREAM 1#define FF_DECODE_ERROR_MISSING_REFERENCE 2 /** * 音频通道数 * - encoding: unused * - decoding: Read by user. */ int channels; /** * size of the corresponding packet containing the compressed * frame. * It is set to a negative value if unknown. * - encoding: unused * - decoding: set by libavcodec, read by user. */ int pkt_size; #if FF_API_FRAME_QP /** * QP table */ attribute_deprecated int8_t *qscale_table; /** * QP store stride */ attribute_deprecated int qstride; attribute_deprecated int qscale_type; attribute_deprecated AVBufferRef *qp_table_buf; #endif /** * For hwaccel-format frames, this should be a reference to the * AVHWFramesContext describing the frame. */ AVBufferRef *hw_frames_ctx; /** * AVBufferRef for free use by the API user. FFmpeg will never check the * contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when * the frame is unreferenced. av_frame_copy_props() calls create a new * reference with av_buffer_ref() for the target frame\u0026#39;s opaque_ref field. * * This is unrelated to the opaque field, although it serves a similar * purpose. */ AVBufferRef *opaque_ref; /** * @anchor cropping * @name Cropping * Video frames only. The number of pixels to discard from the the * top/bottom/left/right border of the frame to obtain the sub-rectangle of * the frame intended for presentation. * @{ */ size_t crop_top; size_t crop_bottom; size_t crop_left; size_t crop_right; /** * @} */ /** * AVBufferRef for internal use by a single libav* library. * Must not be used to transfer data between libraries. * Has to be NULL when ownership of the frame leaves the respective library. * * Code outside the FFmpeg libs should never check or change the contents of the buffer ref. * * FFmpeg calls av_buffer_unref() on it when the frame is unreferenced. * av_frame_copy_props() calls create a new reference with av_buffer_ref() * for the target frame\u0026#39;s private_ref field. */ AVBufferRef *private_ref; } AVFrame;   AVPacket 1  //占坑，敬请期待   AVStream 1  //占坑，敬请期待   参考：\n FFmpeg官网 Examples libswresample与libavresample  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-ffplay%E8%A7%A3%E6%9E%90/",
	"title": "Android-ffplay解析",
	"tags": ["ffmpeg", "音视频"],
	"categories": [],
	"series": ["ffmpeg", "音视频"],
	"description": "Syntax highlighting test",
	"content": "首先移植到Android，在SDL2源码的Android项目(android-project)中添加编译好的ffmpeg的so。\n然后复制config.h、cmdutils.h、cmdutils.c、ffplay即可。\n本文中ffplay源码是以ffmpeg4.1.5版本为基础做了部分省略的。\n讲在开始前 PacketQueue开始是以flush_pkt这个data指向自身的特殊packet标志开始。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  int decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *sub) { if (pkt.data == flush_pkt.data) {//表示开始，做初始化，并不真正解码  avcodec_flush_buffers(d-\u0026gt;avctx); d-\u0026gt;finished = 0; d-\u0026gt;next_pts = d-\u0026gt;start_pts; d-\u0026gt;next_pts_tb = d-\u0026gt;start_pts_tb; } else {//其他正常解码  if (avcodec_send_packet(d-\u0026gt;avctx, \u0026amp;pkt) == AVERROR(EAGAIN)) { av_log(d-\u0026gt;avctx, AV_LOG_ERROR, \u0026#34;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\u0026#34;); d-\u0026gt;packet_pending = 1;//预读取  av_packet_move_ref(\u0026amp;d-\u0026gt;pkt, \u0026amp;pkt); } av_packet_unref(\u0026amp;pkt); } }   当读到文件尾调用packet_queue_put_nullpacket放置一个data为null的packet作为结束标志。\nffplay中的主要类型、变量和方法 类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177  enum ShowMode { SHOW_MODE_NONE = -1, SHOW_MODE_VIDEO = 0, //显示视频  SHOW_MODE_WAVES, //显示音频音浪  SHOW_MODE_RDFT, //  SHOW_MODE_NB }; enum {//同步方式  AV_SYNC_AUDIO_MASTER,//视频向音频同步  AV_SYNC_VIDEO_MASTER,//音频向视频同步  AV_SYNC_EXTERNAL_CLOCK, //使用外部时钟，音视频都以外部时钟为准做同步 }; typedef struct AudioParams { int freq; int channels; int64_t channel_layout; enum AVSampleFormat fmt; int frame_size; int bytes_per_sec; } AudioParams; typedef struct Clock { double pts; /* clock base */ double pts_drift; /* clock base minus time at which we updated the clock */ double last_updated; double speed; int serial; /* clock is based on a packet with this serial */ int paused; int *queue_serial; /* pointer to the current packet queue serial, used for obsolete clock detection */ } Clock; typedef struct MyAVPacketList {//packet链表  AVPacket pkt; struct MyAVPacketList *next; int serial; } MyAVPacketList; typedef struct PacketQueue {//解码前数据packet队列  MyAVPacketList *first_pkt, *last_pkt; int nb_packets; int size; int64_t duration; int abort_request; int serial; SDL_mutex *mutex; SDL_cond *cond; } PacketQueue; typedef struct Frame {//帧数据  AVFrame *frame; AVSubtitle sub; int serial; double pts; /* presentation timestamp for the frame */ double duration; /* estimated duration of the frame */ int64_t pos; /* byte position of the frame in the input file */ int width; int height; int format; AVRational sar; int uploaded; int flip_v; } Frame; typedef struct FrameQueue {//解码后数据frame队列  Frame queue[FRAME_QUEUE_SIZE]; int rindex; int windex; int size; int max_size; int keep_last; int rindex_shown; SDL_mutex *mutex; SDL_cond *cond; PacketQueue *pktq; } FrameQueue; typedef struct Decoder { AVPacket pkt; PacketQueue *queue; AVCodecContext *avctx; int pkt_serial; int finished; int packet_pending; SDL_cond *empty_queue_cond; int64_t start_pts; AVRational start_pts_tb; int64_t next_pts; AVRational next_pts_tb; SDL_Thread *decoder_tid; } Decoder; typedef struct VideoState { SDL_Thread *read_tid; AVInputFormat *iformat; int abort_request; int force_refresh; int paused; int last_paused; int queue_attachments_req; int seek_req; //标识一次SEEK请求  int seek_flags;//SEEK标志，诸如AVSEEK_FLAG_BYTE等  int64_t seek_pos;//SEEK的目标位置(当前位置+增量)  int64_t seek_rel;//本次SEEK的位置增量  int read_pause_return; AVFormatContext *ic; int realtime; Clock audclk; Clock vidclk; Clock extclk; FrameQueue pictq; FrameQueue sampq; Decoder auddec; Decoder viddec; int audio_stream; int av_sync_type; double audio_clock; int audio_clock_serial; double audio_diff_cum; /* used for AV difference average computation */ double audio_diff_avg_coef; double audio_diff_threshold; int audio_diff_avg_count; AVStream *audio_st; PacketQueue audioq; int audio_hw_buf_size; uint8_t *audio_buf; uint8_t *audio_buf1; unsigned int audio_buf_size; /* in bytes */ unsigned int audio_buf1_size; int audio_buf_index; /* in bytes */ int audio_write_buf_size; int audio_volume; int muted;//是否静音  struct AudioParams audio_src; struct AudioParams audio_tgt; struct SwrContext *swr_ctx; int frame_drops_early;//丢弃视频packet计数  int frame_drops_late;//丢弃视频frame计数  enum ShowMode show_mode; int16_t sample_array[SAMPLE_ARRAY_SIZE]; int sample_array_index; int last_i_start; RDFTContext *rdft; int rdft_bits; FFTSample *rdft_data; int xpos; double last_vis_time; SDL_Texture *vis_texture;//字幕纹理  SDL_Texture *vid_texture;//视频纹理  double frame_timer; double frame_last_returned_time; double frame_last_filter_delay; int video_stream; AVStream *video_st; PacketQueue videoq; double max_frame_duration; // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity  struct SwsContext *img_convert_ctx; struct SwsContext *sub_convert_ctx; int eof; char *filename; int width, height, xleft, ytop; int step; int last_video_stream, last_audio_stream; SDL_cond *continue_read_thread; } VideoState;   变量 static int seek_by_bytes = -1;//是否是AVSEEK_FLAG_BYTE。另外还有其他几种seek方式：\n1 2 3 4  #define AVSEEK_FLAG_BACKWARD 1 ///\u0026lt; seek backward #define AVSEEK_FLAG_BYTE 2 ///\u0026lt; seeking based on position in bytes #define AVSEEK_FLAG_ANY 4 ///\u0026lt; seek to any frame, even non-keyframes #define AVSEEK_FLAG_FRAME 8 ///\u0026lt; seeking based on frame number   static AVPacket flush_pkt;//PacketQueue中的第一个元素\nstatic int startup_volume = 100;//音量\nstatic int av_sync_type = AV_SYNC_AUDIO_MASTER;//同步类型\nstatic int64_t start_time = AV_NOPTS_VALUE;//起始/开始播放时间点\nstatic int64_t duration = AV_NOPTS_VALUE;//播放时长\nstatic int infinite_buffer = -1;//缓存无限容量，当是实时流（rtp/rtsp/sdp/udp）时为无限容量\nstatic int autoexit = 1; //播放完自动退出（即执行do_exit方法）\nstatic int loop = 1;//0为循环播放\u0026gt;0则表示播放次数\nstatic int framedrop = -1;//当cpu解码太慢或者添加filter后导致显示时间已过时是否丢弃帧\n方法 packet_queue_xxx\nframe_queue_xxx\nstream_xxx\ndecode_xxx\nxxx_clock_xxx\nread_thread\nvideo_thread\naudio_thread\nvideo_image_display\nvideo_audio_display\nupload_texture\ndo_exit\nfflpay的具体流程 初始化  main方法   创建SDL_Window/SDL_Renderer 调用stream_open方法   stream_open方法   初始化SDL窗口显示位置，视频流、音频流及字幕流的PacketQueue和FrameQueue 初始化同步要用到的视频时钟、音频时钟及外部时钟 初始化其他变量初始音量、是否静音及音视频同步类型。 创建SDL线程，该线程执行read_thread方法循环读数据   read_thread方法   初始化video_stream（视频流）及audio_stream（音频流索引），初始化eof=0。eof表示是否读取音视频文件尾。 为AVFormatContext分配空间 avformat_open_input打开文件/流。 初始化max_frame_duration，如果允许时间戳不连续(ic-\u0026gt;iformat-\u0026gt;flags \u0026amp; AVFMT_TS_DISCONT)则为10，否则是3600。 初始化视频起始播放点全局变量start_time，即从哪个时间开始播放。这里要注意AVFormatContext也有个start_time属性，这个start_time是媒体文件第一帧的位置。然后调用int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)seek到指定位置。其中ts的单位是索引为stream_index的流的单位。如果stream_index==-1，则以AV_TIME_BASE为单位。 av_find_best_stream查找视频流。获取视频宽高及长宽比。 1 2 3 4 5 6 7 8 9 10 11  if (st_index[AVMEDIA_TYPE_VIDEO] \u0026gt;= 0) { AVStream *st = ic-\u0026gt;streams[st_index[AVMEDIA_TYPE_VIDEO]]; AVCodecParameters *codecpar = st-\u0026gt;codecpar; //根据流和帧长宽比猜测帧的采样长宽比。  //由于帧纵横比是由编解码器设置的，而流纵横比是由解复用器设置的，所以这两者可能不相等。如果要显示帧，此函数将尝试返回应使用的值。  //基本逻辑是如果它流的一些设置正常则使用流长宽比，否则使用帧长宽比。这样的容器设置通常易于修改帧中可以覆盖的的编码值。  AVRational sar = av_guess_sample_aspect_ratio(ic, st, NULL); if (codecpar-\u0026gt;width) { set_default_window_size(codecpar-\u0026gt;width, codecpar-\u0026gt;height, sar); } }    调用stream_component_open打开音视频流。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239  int stream_component_open(VideoState *is, int stream_index) { ... avctx = avcodec_alloc_context3(NULL);//为AVCodecContext分配空间  if (!avctx) return AVERROR(ENOMEM); //将解码器中的参数填充到AVCodecContext中，比如codec_id  ret = avcodec_parameters_to_context(avctx, ic-\u0026gt;streams[stream_index]-\u0026gt;codecpar); avctx-\u0026gt;pkt_timebase = ic-\u0026gt;streams[stream_index]-\u0026gt;time_base; //根据解码器上下文中的codec_id查找解码器，上下文中的codec_id来自stream  codec = avcodec_find_decoder(avctx-\u0026gt;codec_id); switch (avctx-\u0026gt;codec_type) { case AVMEDIA_TYPE_AUDIO : is-\u0026gt;last_audio_stream = stream_index; break; case AVMEDIA_TYPE_VIDEO : is-\u0026gt;last_video_stream = stream_index; break; default: break; } ... avctx-\u0026gt;codec_id = codec-\u0026gt;id; ... if ((ret = avcodec_open2(avctx, codec, \u0026amp;opts)) \u0026lt; 0) { goto fail; } is-\u0026gt;eof = 0; ic-\u0026gt;streams[stream_index]-\u0026gt;discard = AVDISCARD_DEFAULT; switch (avctx-\u0026gt;codec_type) { case AVMEDIA_TYPE_AUDIO: ... break; case AVMEDIA_TYPE_VIDEO: is-\u0026gt;video_stream = stream_index; is-\u0026gt;video_st = ic-\u0026gt;streams[stream_index]; //初始化Decoder  decoder_init(\u0026amp;is-\u0026gt;viddec, avctx, \u0026amp;is-\u0026gt;videoq, is-\u0026gt;continue_read_thread); //调用video_thread，video_thread中开启循环解码。  if ((ret = decoder_start(\u0026amp;is-\u0026gt;viddec, video_thread, is)) \u0026lt; 0) goto out; is-\u0026gt;queue_attachments_req = 1; break; } } int video_thread(void *arg) { VideoState *is = (VideoState *) arg; AVFrame *frame = av_frame_alloc(); double pts; double duration; int ret; AVRational tb = is-\u0026gt;video_st-\u0026gt;time_base; AVRational frame_rate = av_guess_frame_rate(is-\u0026gt;ic, is-\u0026gt;video_st, NULL); if (!frame) { return AVERROR(ENOMEM); } for (;;) { ret = get_video_frame(is, frame); if (ret \u0026lt; 0) goto the_end; if (!ret) { continue; } duration = (frame_rate.num \u0026amp;\u0026amp; frame_rate.den ? av_q2d( (AVRational) {frame_rate.den, frame_rate.num}) : 0); pts = (frame-\u0026gt;pts == AV_NOPTS_VALUE) ? NAN : frame-\u0026gt;pts * av_q2d(tb); //将解码的frame封装成Frame存放到framequeue  ret = queue_picture(is, frame, pts, duration, frame-\u0026gt;pkt_pos, is-\u0026gt;viddec.pkt_serial); av_frame_unref(frame); if (ret \u0026lt; 0) { goto the_end; } } the_end: av_frame_free(\u0026amp;frame); return 0; } int get_video_frame(VideoState *is, AVFrame *frame) { int got_picture; if ((got_picture = decoder_decode_frame(\u0026amp;is-\u0026gt;viddec, frame, NULL)) \u0026lt; 0) { return -1; } if (got_picture) { double dpts = NAN; if (frame-\u0026gt;pts != AV_NOPTS_VALUE) //在decoder_decode_frame中解码的frame的pts设置的都是以流时间基为单位的，所以这里要乘以流的时间基，得到真正的时间。  dpts = av_q2d(is-\u0026gt;video_st-\u0026gt;time_base) * frame-\u0026gt;pts; //根据流和帧长宽比猜测帧的采样长宽比。  //由于帧纵横比是由编解码器设置的，而流纵横比是由解复用器设置的，所以这两者可能不相等。如果要显示帧，此函数将尝试返回应使用的值。  //基本逻辑是如果它流的一些设置正常则使用流长宽比，否则使用帧长宽比。这样的容器设置通常易于修改帧中可以覆盖的的编码值。  frame-\u0026gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-\u0026gt;ic, is-\u0026gt;video_st, frame); //设置为丢弃或者音视频同步方式不是同步到视频,如果是同步到视频方式，此时没必要丢弃视频帧  if (framedrop \u0026gt; 0 || (framedrop \u0026amp;\u0026amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) { if (frame-\u0026gt;pts != AV_NOPTS_VALUE) { double diff = dpts - get_master_clock(is); if (!isnan(diff) \u0026amp;\u0026amp; fabs(diff) \u0026lt; AV_NOSYNC_THRESHOLD \u0026amp;\u0026amp; diff - is-\u0026gt;frame_last_filter_delay \u0026lt; 0 \u0026amp;\u0026amp; is-\u0026gt;viddec.pkt_serial == is-\u0026gt;vidclk.serial \u0026amp;\u0026amp; is-\u0026gt;videoq.nb_packets) { is-\u0026gt;frame_drops_early++; av_frame_unref(frame); got_picture = 0; } } } } return got_picture; } //从packetqueue中取packet解码成frame int decoder_decode_frame(Decoder *d, AVFrame *frame, AVSubtitle *sub) { int ret = AVERROR(EAGAIN); for (;;) { AVPacket pkt; if (d-\u0026gt;queue-\u0026gt;serial == d-\u0026gt;pkt_serial) { do { if (d-\u0026gt;queue-\u0026gt;abort_request) return -1; switch (d-\u0026gt;avctx-\u0026gt;codec_type) { case AVMEDIA_TYPE_VIDEO: ret = avcodec_receive_frame(d-\u0026gt;avctx, frame); if (ret \u0026gt;= 0) { //注意这里frame pts的设定。  //best_effort_timestamp是ffmpeg为我们估算的基于流时间基的帧时间戳  //如果设置了重排则使用解码器解码packet的时间，即dts  if (decoder_reorder_pts == -1) { frame-\u0026gt;pts = frame-\u0026gt;best_effort_timestamp; } else if (!decoder_reorder_pts) { frame-\u0026gt;pts = frame-\u0026gt;pkt_dts; } } break; case AVMEDIA_TYPE_AUDIO: ret = avcodec_receive_frame(d-\u0026gt;avctx, frame); if (ret \u0026gt;= 0) { AVRational tb = (AVRational) {1, frame-\u0026gt;sample_rate}; if (frame-\u0026gt;pts != AV_NOPTS_VALUE) frame-\u0026gt;pts = av_rescale_q(frame-\u0026gt;pts, d-\u0026gt;avctx-\u0026gt;pkt_timebase, tb); else if (d-\u0026gt;next_pts != AV_NOPTS_VALUE) frame-\u0026gt;pts = av_rescale_q(d-\u0026gt;next_pts, d-\u0026gt;next_pts_tb, tb); if (frame-\u0026gt;pts != AV_NOPTS_VALUE) { d-\u0026gt;next_pts = frame-\u0026gt;pts + frame-\u0026gt;nb_samples; d-\u0026gt;next_pts_tb = tb; } } break; default: break; } if (ret == AVERROR_EOF) { d-\u0026gt;finished = d-\u0026gt;pkt_serial; avcodec_flush_buffers(d-\u0026gt;avctx); return 0; } if (ret \u0026gt;= 0) return 1; } while (ret != AVERROR(EAGAIN));//EAGAIN：当前帧解码完毕  } do { if (d-\u0026gt;queue-\u0026gt;nb_packets == 0)//如果packetqueue没有packet，发送empty_queue_cond信号告诉read_thread继续读数据  SDL_CondSignal(d-\u0026gt;empty_queue_cond); if (d-\u0026gt;packet_pending) {//如果预先已从packetqueue取出packet数据，则将该数据复制给pkt用于解码  av_packet_move_ref(\u0026amp;pkt, \u0026amp;d-\u0026gt;pkt); d-\u0026gt;packet_pending = 0; } else {//否则从packetqueue取数据,小于0表示abort_request=1，退出播放  if (packet_queue_get(d-\u0026gt;queue, \u0026amp;pkt, 1, \u0026amp;d-\u0026gt;pkt_serial) \u0026lt; 0) return -1; } } while (d-\u0026gt;queue-\u0026gt;serial != d-\u0026gt;pkt_serial); if (pkt.data == flush_pkt.data) { //重置内部解码器状态/刷新内部缓冲区。例如，在seek或切换到其他流时应调用。  avcodec_flush_buffers(d-\u0026gt;avctx); d-\u0026gt;finished = 0; d-\u0026gt;next_pts = d-\u0026gt;start_pts; d-\u0026gt;next_pts_tb = d-\u0026gt;start_pts_tb; } else { //当前状态下不接受输入-用户必须使用avcodec_receive_frame()读取输出（读取所有输出后，应重新发送数据包，并且调用不会因EAGAIN失败）。  if (avcodec_send_packet(d-\u0026gt;avctx, \u0026amp;pkt) == AVERROR(EAGAIN)) { av_log(d-\u0026gt;avctx, AV_LOG_ERROR, \u0026#34;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\\n\u0026#34;); d-\u0026gt;packet_pending = 1; av_packet_move_ref(\u0026amp;d-\u0026gt;pkt, \u0026amp;pkt); } av_packet_unref(\u0026amp;pkt); } } } //从packetqueue中取出packet int packet_queue_get(PacketQueue *q, AVPacket *pkt, int block, int *serial) { MyAVPacketList *pkt1; int ret; SDL_LockMutex(q-\u0026gt;mutex); for (;;) { if (q-\u0026gt;abort_request) { ret = -1; break; } pkt1 = q-\u0026gt;first_pkt; if (pkt1) { q-\u0026gt;first_pkt = pkt1-\u0026gt;next; if (!q-\u0026gt;first_pkt) q-\u0026gt;last_pkt = NULL; q-\u0026gt;nb_packets--; q-\u0026gt;size -= pkt1-\u0026gt;pkt.size + sizeof(*pkt1);//AVpacket大小+MyAVPacketList大小才是packetqueue一个元素真正的大小  q-\u0026gt;duration -= pkt1-\u0026gt;pkt.duration; *pkt = pkt1-\u0026gt;pkt; if (serial) *serial = pkt1-\u0026gt;serial;//将decoder的pkt_serial指向新的MyAVPacketList的serial  av_free(pkt1); ret = 1; break; } else if (!block) { ret = 0; break; } else { SDL_CondWait(q-\u0026gt;cond, q-\u0026gt;mutex); } } SDL_UnlockMutex(q-\u0026gt;mutex); return ret; }    循环读取数据，循环读取前先判断各个状态。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  //如果有seek操作 if (is-\u0026gt;seek_req) { int64_t seek_target = is-\u0026gt;seek_pos;//is-\u0026gt;seek_pos期望seek到的目标位置，is-\u0026gt;seek_rel此次seek增量  int64_t seek_min = is-\u0026gt;seek_rel \u0026gt; 0 ? seek_target - is-\u0026gt;seek_rel + 2 : INT64_MIN; int64_t seek_max = is-\u0026gt;seek_rel \u0026lt; 0 ? seek_target - is-\u0026gt;seek_rel - 2 : INT64_MAX; // FIXME the +-2 is due to rounding being not done in the correct direction in generation of the seek_pos/seek_rel variables  ret = avformat_seek_file(is-\u0026gt;ic, -1, seek_min, seek_target, seek_max, is-\u0026gt;seek_flags); if (ret \u0026lt; 0) { LOGE(LOG_TAG, \u0026#34;%s: error while seeking\\n\u0026#34;, is-\u0026gt;ic-\u0026gt;url); } else { if (is-\u0026gt;audio_stream \u0026gt;= 0) { packet_queue_flush(\u0026amp;is-\u0026gt;audioq);//清空数据  packet_queue_put(\u0026amp;is-\u0026gt;audioq, \u0026amp;flush_pkt); } if (is-\u0026gt;video_stream \u0026gt;= 0) { packet_queue_flush(\u0026amp;is-\u0026gt;videoq);//清空数据  packet_queue_put(\u0026amp;is-\u0026gt;videoq, \u0026amp;flush_pkt); } //seek后重置时钟  if (is-\u0026gt;seek_flags \u0026amp; AVSEEK_FLAG_BYTE) { set_clock(\u0026amp;is-\u0026gt;extclk, NAN, 0); } else { set_clock(\u0026amp;is-\u0026gt;extclk, seek_target / (double) AV_TIME_BASE, 0); } } //重置seek状态  is-\u0026gt;seek_req = 0; is-\u0026gt;queue_attachments_req = 1; is-\u0026gt;eof = 0; if (is-\u0026gt;paused) { step_to_next_frame(is); }     }\n//如果不是无限容量的buffer且队列总大小已大于MAX_QUEUE_SIZE或者已足够多的packet（即：packets大于MIN_FRAMES且时长大于1s）\nif (infinite_buffer \u0026lt; 1 \u0026amp;\u0026amp;\n(is-\u0026gt;audioq.size + is-\u0026gt;videoq.size \u0026gt; MAX_QUEUE_SIZE ||\n(stream_has_enough_packets(is-\u0026gt;audio_st, is-\u0026gt;audio_stream, \u0026amp;is-\u0026gt;audioq) \u0026amp;\u0026amp;\nstream_has_enough_packets(is-\u0026gt;video_st, is-\u0026gt;video_stream, \u0026amp;is-\u0026gt;videoq)))) {\n//等待10毫秒\nSDL_LockMutex(wait_mutex);\nSDL_CondWaitTimeout(is-\u0026gt;continue_read_thread, wait_mutex, 10);\nSDL_UnlockMutex(wait_mutex);\ncontinue;\n}\nif (!is-\u0026gt;paused \u0026amp;\u0026amp;\n(!is-\u0026gt;audio_st || (is-\u0026gt;auddec.finished == is-\u0026gt;audioq.serial \u0026amp;\u0026amp;\nframe_queue_nb_remaining(\u0026amp;is-\u0026gt;sampq) == 0)) \u0026amp;\u0026amp;\n(!is-\u0026gt;video_st || (is-\u0026gt;viddec.finished == is-\u0026gt;videoq.serial \u0026amp;\u0026amp;\nframe_queue_nb_remaining(\u0026amp;is-\u0026gt;pictq) == 0))) {//播放完毕到达文件尾\nif (loop != 1 \u0026amp;\u0026amp; (!loop || \u0026ndash;loop)) {//loop!=1(仅播放一次)且loop!=0(循环播放)或者loop自减仍大于0(播放多次)\n//回到start_time/0(初始)位置重新开始播放\nstream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n} else if (autoexit) {//如果设置了自动退出则在播放完毕退出\nret = AVERROR_EOF;\ngoto fail;\n}\n}\nret = av_read_frame(ic, pkt);//读取数据\nif (ret \u0026lt; 0) {//如果错误或者eof，放置一个空数据的pkt到PacketQueue队列\nif ((ret == AVERROR_EOF || avio_feof(ic-\u0026gt;pb)) \u0026amp;\u0026amp; !is-\u0026gt;eof) {//end of file\nif (is-\u0026gt;video_stream \u0026gt;= 0)\npacket_queue_put_nullpacket(\u0026amp;is-\u0026gt;videoq, is-\u0026gt;video_stream);\nif (is-\u0026gt;audio_stream \u0026gt;= 0)\npacket_queue_put_nullpacket(\u0026amp;is-\u0026gt;audioq, is-\u0026gt;audio_stream);\nis-\u0026gt;eof = 1;\n}\nif (ic-\u0026gt;pb \u0026amp;\u0026amp; ic-\u0026gt;pb-\u0026gt;error) break;//遇到错误循环中断，否则可能是不明错误，等待10ms重试一次\nSDL_LockMutex(wait_mutex);\nSDL_CondWaitTimeout(is-\u0026gt;continue_read_thread, wait_mutex, 10);\nSDL_UnlockMutex(wait_mutex);\ncontinue;\n} else {\nis-\u0026gt;eof = 0;\n}\n//检查数据包是否在用户指定的播放范围内，然后排队，否则丢弃/释放掉\nstream_start_time = ic-\u0026gt;streams[pkt-\u0026gt;stream_index]-\u0026gt;start_time;\npkt_ts = pkt-\u0026gt;pts == AV_NOPTS_VALUE ? pkt-\u0026gt;dts : pkt-\u0026gt;pts;\npkt_in_play_range =\nduration == AV_NOPTS_VALUE ||\n(pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) *\nav_q2d(ic-\u0026gt;streams[pkt-\u0026gt;stream_index]-\u0026gt;time_base) -\n(double) (start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000 \u0026lt;=\n((double) duration / 1000000);\nif (pkt-\u0026gt;stream_index == is-\u0026gt;audio_stream \u0026amp;\u0026amp; pkt_in_play_range) {\npacket_queue_put(\u0026amp;is-\u0026gt;audioq, pkt);\n} else if (pkt-\u0026gt;stream_index == is-\u0026gt;video_stream \u0026amp;\u0026amp; pkt_in_play_range\n\u0026amp;\u0026amp; !(is-\u0026gt;video_st-\u0026gt;disposition \u0026amp; AV_DISPOSITION_ATTACHED_PIC)) {\npacket_queue_put(\u0026amp;is-\u0026gt;videoq, pkt);\n} else {\nav_packet_unref(pkt);\n}\n ### 开启循环读取解码数据显示/播放 ``` c++ void event_loop(VideoState *cur_stream) { SDL_Event event; double incr, pos, frac; for (;;) { double x; refresh_loop_wait_event(cur_stream, \u0026amp;event); switch (event.type) { ... case SDL_QUIT: case FF_QUIT_EVENT: do_exit(cur_stream);// break; default: break; } } } void refresh_loop_wait_event(VideoState *is, SDL_Event *event) { double remaining_time = 0.0; SDL_PumpEvents(); while (!SDL_PeepEvents(event, 1, SDL_GETEVENT, SDL_FIRSTEVENT, SDL_LASTEVENT)) { ... if (remaining_time \u0026gt; 0.0) //睡眠下一次刷新时间 av_usleep((int64_t) (remaining_time * 1000000.0)); //REFRESH_RATE刷新频率 remaining_time = REFRESH_RATE; if (is-\u0026gt;show_mode != SHOW_MODE_NONE \u0026amp;\u0026amp; (!is-\u0026gt;paused || is-\u0026gt;force_refresh)) video_refresh(is, \u0026amp;remaining_time); SDL_PumpEvents(); } } void video_refresh(void *opaque, double *remaining_time) { ... if (!display_disable \u0026amp;\u0026amp; is-\u0026gt;show_mode != SHOW_MODE_VIDEO \u0026amp;\u0026amp; is-\u0026gt;audio_st) { //获取自某个未指定起点(一般是系统启动时)以来的当前时间（微秒）。 // 在支持它的平台上，时间来自一个单调时钟这个特性使得这个时间源成为测量相对时间的理想时间源。 // 在没有单调时钟的平台上，返回值可能不是单调的。 time = av_gettime_relative() / 1000000.0; if (is-\u0026gt;force_refresh || is-\u0026gt;last_vis_time + rdftspeed \u0026lt; time) { video_display(is); is-\u0026gt;last_vis_time = time; } *remaining_time = FFMIN(*remaining_time, is-\u0026gt;last_vis_time + rdftspeed - time); } if (is-\u0026gt;video_st) {//如果存在视频流 retry: if (frame_queue_nb_remaining(\u0026amp;is-\u0026gt;pictq) == 0) { // 如果FrameQueue中已经没有解码的数据了，没得显示，不做任何操作 } else { double last_duration, duration, delay; Frame *vp, *lastvp; /* dequeue the picture */ lastvp = frame_queue_peek_last(\u0026amp;is-\u0026gt;pictq); vp = frame_queue_peek(\u0026amp;is-\u0026gt;pictq); if (vp-\u0026gt;serial != is-\u0026gt;videoq.serial) {// frame_queue_next(\u0026amp;is-\u0026gt;pictq); goto retry; } if (lastvp-\u0026gt;serial != vp-\u0026gt;serial) is-\u0026gt;frame_timer = av_gettime_relative() / 1000000.0; if (is-\u0026gt;paused) goto display; /* compute nominal last_duration */ last_duration = vp_duration(is, lastvp, vp); delay = compute_target_delay(last_duration, is); time = av_gettime_relative() / 1000000.0; if (time \u0026lt; is-\u0026gt;frame_timer + delay) { *remaining_time = FFMIN(is-\u0026gt;frame_timer + delay - time, *remaining_time); goto display; } is-\u0026gt;frame_timer += delay; if (delay \u0026gt; 0 \u0026amp;\u0026amp; time - is-\u0026gt;frame_timer \u0026gt; AV_SYNC_THRESHOLD_MAX) is-\u0026gt;frame_timer = time; SDL_LockMutex(is-\u0026gt;pictq.mutex); if (!isnan(vp-\u0026gt;pts)) update_video_pts(is, vp-\u0026gt;pts, vp-\u0026gt;pos, vp-\u0026gt;serial); SDL_UnlockMutex(is-\u0026gt;pictq.mutex); if (frame_queue_nb_remaining(\u0026amp;is-\u0026gt;pictq) \u0026gt; 1) { Frame *nextvp = frame_queue_peek_next(\u0026amp;is-\u0026gt;pictq); duration = vp_duration(is, vp, nextvp); if (!is-\u0026gt;step \u0026amp;\u0026amp; (framedrop \u0026gt; 0 || (framedrop \u0026amp;\u0026amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) \u0026amp;\u0026amp; time \u0026gt; is-\u0026gt;frame_timer + duration) { is-\u0026gt;frame_drops_late++; frame_queue_next(\u0026amp;is-\u0026gt;pictq); goto retry; } } ... frame_queue_next(\u0026amp;is-\u0026gt;pictq); is-\u0026gt;force_refresh = 1; if (is-\u0026gt;step \u0026amp;\u0026amp; !is-\u0026gt;paused) stream_toggle_pause(is); } display: /* display picture */ if (!display_disable \u0026amp;\u0026amp; is-\u0026gt;force_refresh \u0026amp;\u0026amp; is-\u0026gt;show_mode == SHOW_MODE_VIDEO \u0026amp;\u0026amp; is-\u0026gt;pictq.rindex_shown) video_display(is); } is-\u0026gt;force_refresh = 0; } void video_display(VideoState *is) { if (!is-\u0026gt;width) video_open(is); SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255); SDL_RenderClear(renderer); if (is-\u0026gt;audio_st \u0026amp;\u0026amp; is-\u0026gt;show_mode != SHOW_MODE_VIDEO) video_audio_display(is);//显示音频图像 else if (is-\u0026gt;video_st) video_image_display(is);//显示视频图像 SDL_RenderPresent(renderer); } void video_image_display(VideoState *is) { Frame *vp; Frame *sp = NULL; SDL_Rect rect; vp = frame_queue_peek_last(\u0026amp;is-\u0026gt;pictq); calculate_display_rect(\u0026amp;rect, is-\u0026gt;xleft, is-\u0026gt;ytop, is-\u0026gt;width, is-\u0026gt;height, vp-\u0026gt;width, vp-\u0026gt;height, vp-\u0026gt;sar); if (!vp-\u0026gt;uploaded) { //这里做渲染 if (upload_texture(\u0026amp;is-\u0026gt;vid_texture, vp-\u0026gt;frame, \u0026amp;is-\u0026gt;img_convert_ctx) \u0026lt; 0) return; vp-\u0026gt;uploaded = 1; vp-\u0026gt;flip_v = vp-\u0026gt;frame-\u0026gt;linesize[0] \u0026lt; 0; } set_sdl_yuv_conversion_mode(vp-\u0026gt;frame); //将源纹理的一部分复制到当前渲染目标，并围绕给定的中心旋转一定角度这里angle=0所以没有任何改变 SDL_RenderCopyEx(renderer, is-\u0026gt;vid_texture, NULL, \u0026amp;rect, 0, NULL, vp-\u0026gt;flip_v ? (SDL_RendererFlip) SDL_FLIP_VERTICAL : (SDL_RendererFlip) 0); set_sdl_yuv_conversion_mode(NULL); } int upload_texture(SDL_Texture **tex, AVFrame *frame, struct SwsContext **img_convert_ctx) { int ret = 0; Uint32 sdl_pix_fmt; SDL_BlendMode sdl_blendmode; get_sdl_pix_fmt_and_blendmode(frame-\u0026gt;format, \u0026amp;sdl_pix_fmt, \u0026amp;sdl_blendmode); if (realloc_texture(tex, sdl_pix_fmt == SDL_PIXELFORMAT_UNKNOWN ? SDL_PIXELFORMAT_ARGB8888 : sdl_pix_fmt, frame-\u0026gt;width, frame-\u0026gt;height, sdl_blendmode, 0) \u0026lt; 0) return -1; switch (sdl_pix_fmt) { case SDL_PIXELFORMAT_UNKNOWN: /* This should only happen if we are not using avfilter... */ *img_convert_ctx = sws_getCachedContext(*img_convert_ctx, frame-\u0026gt;width, frame-\u0026gt;height, frame-\u0026gt;format, frame-\u0026gt;width, frame-\u0026gt;height, AV_PIX_FMT_BGRA, sws_flags, NULL, NULL, NULL); if (*img_convert_ctx != NULL) { uint8_t *pixels[4]; int pitch[4]; if (!SDL_LockTexture(*tex, NULL, (void **) pixels, pitch)) { sws_scale(*img_convert_ctx, (const uint8_t *const *) frame-\u0026gt;data, frame-\u0026gt;linesize, 0, frame-\u0026gt;height, pixels, pitch); SDL_UnlockTexture(*tex); } } else { av_log(NULL, AV_LOG_FATAL, \u0026quot;Cannot initialize the conversion context\\n\u0026quot;); ret = -1; } break; case SDL_PIXELFORMAT_IYUV: if (frame-\u0026gt;linesize[0] \u0026gt; 0 \u0026amp;\u0026amp; frame-\u0026gt;linesize[1] \u0026gt; 0 \u0026amp;\u0026amp; frame-\u0026gt;linesize[2] \u0026gt; 0) { ret = SDL_UpdateYUVTexture(*tex, NULL, frame-\u0026gt;data[0], frame-\u0026gt;linesize[0], frame-\u0026gt;data[1], frame-\u0026gt;linesize[1], frame-\u0026gt;data[2], frame-\u0026gt;linesize[2]); } else if (frame-\u0026gt;linesize[0] \u0026lt; 0 \u0026amp;\u0026amp; frame-\u0026gt;linesize[1] \u0026lt; 0 \u0026amp;\u0026amp; frame-\u0026gt;linesize[2] \u0026lt; 0) { ret = SDL_UpdateYUVTexture(*tex, NULL, frame-\u0026gt;data[0] + frame-\u0026gt;linesize[0] * (frame-\u0026gt;height - 1), -frame-\u0026gt;linesize[0], frame-\u0026gt;data[1] + frame-\u0026gt;linesize[1] * (AV_CEIL_RSHIFT(frame-\u0026gt;height, 1) - 1), -frame-\u0026gt;linesize[1], frame-\u0026gt;data[2] + frame-\u0026gt;linesize[2] * (AV_CEIL_RSHIFT(frame-\u0026gt;height, 1) - 1), -frame-\u0026gt;linesize[2]); } else { av_log(NULL, AV_LOG_ERROR, \u0026quot;Mixed negative and positive linesizes are not supported.\\n\u0026quot;); return -1; } break; default: if (frame-\u0026gt;linesize[0] \u0026lt; 0) { ret = SDL_UpdateTexture(*tex, NULL, frame-\u0026gt;data[0] + frame-\u0026gt;linesize[0] * (frame-\u0026gt;height - 1), -frame-\u0026gt;linesize[0]); } else { ret = SDL_UpdateTexture(*tex, NULL, frame-\u0026gt;data[0], frame-\u0026gt;linesize[0]); } break; } return ret; } 退出释放内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  static void do_exit(VideoState *is) { if (is) { stream_close(is); } if (renderer) SDL_DestroyRenderer(renderer); if (window) SDL_DestroyWindow(window); uninit_opts(); #if CONFIG_AVFILTER av_freep(\u0026amp;vfilters_list); #endif avformat_network_deinit(); if (show_status) printf(\u0026#34;\\n\u0026#34;); SDL_Quit(); av_log(NULL, AV_LOG_QUIET, \u0026#34;%s\u0026#34;, \u0026#34;\u0026#34;); exit(0); } void stream_close(VideoState *is) { /* XXX: use a special url_shutdown call to abort parse cleanly */ is-\u0026gt;abort_request = 1; SDL_WaitThread(is-\u0026gt;read_tid, NULL); /* close each stream */ if (is-\u0026gt;audio_stream \u0026gt;= 0) stream_component_close(is, is-\u0026gt;audio_stream); if (is-\u0026gt;video_stream \u0026gt;= 0) stream_component_close(is, is-\u0026gt;video_stream); if (is-\u0026gt;subtitle_stream \u0026gt;= 0) stream_component_close(is, is-\u0026gt;subtitle_stream); avformat_close_input(\u0026amp;is-\u0026gt;ic); packet_queue_destroy(\u0026amp;is-\u0026gt;videoq); packet_queue_destroy(\u0026amp;is-\u0026gt;audioq); packet_queue_destroy(\u0026amp;is-\u0026gt;subtitleq); /* free all pictures */ frame_queue_destory(\u0026amp;is-\u0026gt;pictq); frame_queue_destory(\u0026amp;is-\u0026gt;sampq); frame_queue_destory(\u0026amp;is-\u0026gt;subpq); SDL_DestroyCond(is-\u0026gt;continue_read_thread); sws_freeContext(is-\u0026gt;img_convert_ctx); sws_freeContext(is-\u0026gt;sub_convert_ctx); av_free(is-\u0026gt;filename); if (is-\u0026gt;vis_texture) SDL_DestroyTexture(is-\u0026gt;vis_texture); if (is-\u0026gt;vid_texture) SDL_DestroyTexture(is-\u0026gt;vid_texture); if (is-\u0026gt;sub_texture) SDL_DestroyTexture(is-\u0026gt;sub_texture); av_free(is); }   总结 事实上播放器的难点主要是音视频同步。其他部分ffmpeg帮我们做了，只要熟悉api看看官网示例就基本可以做出来了。\n参考： * [ffplay源码分析7-播放控制](https://www.cnblogs.com/leisure_chn/p/10316225.html) -- "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-flutter/",
	"title": "Android-Flutter",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android-Flutter使用",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-glide%E5%88%86%E6%9E%90/",
	"title": "Android-Glide分析",
	"tags": ["android", "glide"],
	"categories": [],
	"series": [],
	"description": "Glide分析",
	"content": "前言 本节源码分析基于 Glide 4.11.0\nGlide优势 Glide的常见用法 源码解析 Glide缓存又两类四种：\n 内存缓存  活动缓存(ActiveResource) 正在显示的图片 内存缓存(Memory Cache) 最近被加载过但不是正在显示的图片   磁盘缓存  资源缓存(Resource) 经过缩放裁剪变换的图片 数据缓存(Data) 原始图片    其中活动缓存和内存缓存是互斥的。\nGlide类 要分析Glide，要先从Glide入口说起。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86  public class Glide implements ComponentCallbacks2 { private static final String DEFAULT_DISK_CACHE_DIR = \u0026#34;image_manager_disk_cache\u0026#34;; private static final String TAG = \u0026#34;Glide\u0026#34;; private static volatile Glide glide; private static volatile boolean isInitializing; private final Engine engine; private final BitmapPool bitmapPool; private final MemoryCache memoryCache; private final GlideContext glideContext; private final Registry registry; private final ArrayPool arrayPool; private final RequestManagerRetriever requestManagerRetriever; private final ConnectivityMonitorFactory connectivityMonitorFactory; private final List\u0026lt;RequestManager\u0026gt; managers = new ArrayList\u0026lt;\u0026gt;(); private final RequestOptionsFactory defaultRequestOptionsFactory; private MemoryCategory memoryCategory = MemoryCategory.NORMAL; @GuardedBy(\u0026#34;this\u0026#34;) @Nullable private BitmapPreFiller bitmapPreFiller; .... @VisibleForTesting public static void init(@NonNull Context context, @NonNull GlideBuilder builder) { GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules(context); synchronized (Glide.class) { if (Glide.glide != null) { tearDown(); } initializeGlide(context, builder, annotationGeneratedModule); } } @NonNull public static Glide get(@NonNull Context context) { if (glide == null) { GeneratedAppGlideModule annotationGeneratedModule = getAnnotationGeneratedGlideModules(context.getApplicationContext()); synchronized (Glide.class) { if (glide == null) { checkAndInitializeGlide(context, annotationGeneratedModule); } } } return glide; } @VisibleForTesting public static synchronized void tearDown() { if (glide != null) { glide.getContext().getApplicationContext().unregisterComponentCallbacks(glide); glide.engine.shutdown(); } glide = null; } @NonNull public static RequestManager with(@NonNull Context context) { return getRetriever(context).get(context); } @NonNull public static RequestManager with(@NonNull Activity activity) { return getRetriever(activity).get(activity); } @NonNull public static RequestManager with(@NonNull FragmentActivity activity) { return getRetriever(activity).get(activity); } @NonNull public static RequestManager with(@NonNull Fragment fragment) { return getRetriever(fragment.getContext()).get(fragment); } @NonNull public static RequestManager with(@NonNull View view) { return getRetriever(view.getContext()).get(view); } ... }     tearDown() 卸载Glide，清除内存缓存和磁盘缓存。\n  with(Activity activity)\n如果是非主线程走with(Context context)，否则查看pendingRequestManagerFragmentsMap是否存在(activity已添加了)RequestManagerFragment，如果添加了RequestManagerFragment直接从中获取到RequestManager，如果没有添加，则实例化一个RequestManagerFragment添加到activity，并将RequestManagerFragment以FragmentManager为keyRequestManagerFragment对象为value放入pendingRequestManagerFragments这个Map集合。\n  with(FragmentActivity activity)\n类似with(Activity activity)，只是Fragment是SupportRequestManagerFragment，查询和放入的Map是pendingSupportRequestManagerFragments。\n  with(Fragment fragment)\n类似with(FragmentActivity activity)，只是SupportRequestManagerFragment添加到的不是Activity，而是作为子Fragment添加到fragment中。\n  with(View view)\n如果是非主线程走with(Context context)，否则先根据view找到Activity，再根据Activity找到Fragment。如果不存在fragment或view不在某个fragment中则走with(Activity activity)或with(FragmentActivity activity)的流程，如果Activity存在fragment且view在某个fragment当中走with(Fragment fragment)的流程。\n  with(Context context)\n如果当前是主线程且不是context不是Application，根据context类型以及递归判断conext.getBaseContext()的类型，最终走with(Activity activity)或with(FragmentActivity activity)的流程。如果当前非主线程或者context是Application则通过getApplicationManager(Context context)实例化单例glide对象，用这个单例对象构建一个RequestManager。\n  总结：Glide通过添加fragment感知声明周期实现离开界面自动释放。\nRequestManager 上面的Glide通过静态的Glide.with()构建一个RequestManager对象。\n load(Bitmap bitmap)\n构建RequestBuilder且使用不缓存策略 load(Drawable drawable)\n构建RequestBuilder且使用不缓存策略 load(String string)\n构建RequestBuilder load(Uri uri)\n构建RequestBuilder load(File file)\n构建RequestBuilder load(@RawRes @DrawableRes Integer resourceId)\n构建RequestBuilder，会对资源的缓存Key使用版本号和夜间模式签名。 load(byte[] model)\n构建RequestBuilder，如果没有设置磁盘缓存策略则设置不缓存，如果设置了内存缓存则强制跳过内存缓存。 load(Object model)\n构建RequestBuilder  RequestBuilder   into(ImageView view)\n最终ImageView会被包装成ViewTarget\u0026lt;ImageView, TranscodeType\u0026gt;调用into(Y target)。\n  into(Y target)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  private \u0026lt;Y extends Target\u0026lt;TranscodeType\u0026gt;\u0026gt; Y into( @NonNull Y target, @Nullable RequestListener\u0026lt;TranscodeType\u0026gt; targetListener, BaseRequestOptions\u0026lt;?\u0026gt; options, Executor callbackExecutor) { Preconditions.checkNotNull(target); if (!isModelSet) { throw new IllegalArgumentException(\u0026#34;You must call #load() before calling #into()\u0026#34;); } Request request = buildRequest(target, targetListener, options, callbackExecutor); Request previous = target.getRequest(); //如果存在Request且新旧Request一致  if (request.isEquivalentTo(previous) \u0026amp;\u0026amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) { if (!Preconditions.checkNotNull(previous).isRunning()) { previous.begin(); } return target; } requestManager.clear(target); target.setRequest(request); requestManager.track(target, request); return target; }     最终会调用到SingleRequest#begin()-\u0026gt;SingleReques#onSizeReady-\u0026gt;Engine.load()。\nEngine#load()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  public \u0026lt;R\u0026gt; LoadStatus load( GlideContext glideContext, Object model, Key signature, int width, int height, Class\u0026lt;?\u0026gt; resourceClass, Class\u0026lt;R\u0026gt; transcodeClass, Priority priority, DiskCacheStrategy diskCacheStrategy, Map\u0026lt;Class\u0026lt;?\u0026gt;, Transformation\u0026lt;?\u0026gt;\u0026gt; transformations, boolean isTransformationRequired, boolean isScaleOnlyOrNoTransform, Options options, boolean isMemoryCacheable, boolean useUnlimitedSourceExecutorPool, boolean useAnimationPool, boolean onlyRetrieveFromCache, ResourceCallback cb, Executor callbackExecutor) { long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0; EngineKey key = keyFactory.buildKey( model, signature, width, height, transformations, resourceClass, transcodeClass, options); EngineResource\u0026lt;?\u0026gt; memoryResource; synchronized (this) { memoryResource = loadFromMemory(key, isMemoryCacheable, startTime); if (memoryResource == null) { return waitForExistingOrStartNewJob( glideContext, model, signature, width, height, resourceClass, transcodeClass, priority, diskCacheStrategy, transformations, isTransformationRequired, isScaleOnlyOrNoTransform, options, isMemoryCacheable, useUnlimitedSourceExecutorPool, useAnimationPool, onlyRetrieveFromCache, cb, callbackExecutor, key, startTime); } } // Avoid calling back while holding the engine lock, doing so makes it easier for callers to  // deadlock.  cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE); return null; }   Engine#load()中调用了两个方法：loadFromMemory和waitForExistingOrStartNewJob。\nloadFromMemory 则是从内存查找，查找的过程是先从活动缓存ActiveResources查找，如果没有再去内存缓存MemoryCache查找，如果找到就将其从MemoryCache移除并加入到活动缓存ActiveResources，如果没有找到向下走到waitForExistingOrStartNewJob。\nwaitForExistingOrStartNewJob 从磁盘缓存查找，如果磁盘缓存中不存再从网络或文件加载。这里的磁盘缓存有两种：Resource和Data。Resource是经过裁剪、缩放、变换过的资源，再次加载时不用再次处理直接加载到内存即可用，而Data是原始资源，再次加载时可能需要处理。Resource有多种类型：DrawableResource、BitmapResource等。加载外部资源时使用的ModelLoader也有多种方式：FileLoader、StringLoader、HttpUriLoader等。\nqueue = new ReferenceQueue(); while(true){ //此处remove()是阻塞的，当queue中Value回收时唤醒 Referencevalue = queue.remove(); } ``` ## MemoryCache 使用LRU算法 严格来说ActiveCache和MemoryCache都是内存（区域）中的缓存。ActiveCache缓存是当前正在使用的资源的缓存，有了内存缓存为什么还要ActiveCache呢？因为LRU有最大值且可能资源使用较少但正在使用导致被回收。当资源正在使用时将资源从MemoryCache移动到ActiveCache，当没有使用时将资源从ActiveCache移动到MemoryCache，资源在ActiveCache和MemoryCache只能二选一 glide自动加了UA导致服务器拒绝不能加载图片 -- "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-gradle%E5%BA%94%E7%94%A8/",
	"title": "Android-Gradle应用",
	"tags": ["gradle"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": "Gradle插件开发 开发Gradle插件的三种方式  直接写在build.gradle中，适合简单逻辑，只对该build.gradle可见 在项目下新建buildSrc目录，将代码放在src/main/java或者src/main/groovy中 独立的Java项目/模块，可以发布到仓库(jcenter)，可以被其他项目引用  插件编写  新建一个类继承org.gradle.api.Plugin 在插件项目的build.gradle的dependencies中引入gradle implementation 'com.android.tools.build:gradle:3.6.2' 或 implementation gradleApi()  注册Plugin 在main文件夹新建resources文件夹，在resources下再新建MATE-INF文件夹，再在MATE-INF文件夹再新建gradle-plugins文件夹，再在gradle-plugins文件夹下新建xxxxx.properties文件。xxxxx为你发布是引入的名字，如：apply plugin: \u0026lsquo;com.android.application\u0026rsquo;，xxxxx相当于com.android.application。在xxxxx.properties中添加 implementation-class=xxx.xxx.xxx.MyPlugin xxx.xxx.xxx是MyPlugin包名\n  https://developer.android.google.cn/studio/build\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-jnindk/",
	"title": "Android-JNI&amp;NDK",
	"tags": ["android", "ndk"],
	"categories": [],
	"series": ["ndk"],
	"description": "Android JNI&amp;NDK",
	"content": "前言 Linux系统Native动态库(.so)、静态库(.a)及目标文件(.o)。\nWindows系统Native动态库(.dll)、静态库(.lib)及目标文件(.obj)。\n目标文件(.o/.obj)是与源代码对应的二进制文件。静态库(.a/.lib)是多个目标文件的集合。\nJNI JNI是Java实现的Java代码与本地代码的交互规范和API。\nJNI的方法使用native修饰且没有方法体，如：public native int nativeMethod(String s);\n类型对应关系\njava类型 | jni类型 | 描述\n\u0026mdash;\u0026mdash;\u0026mdash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;|\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\nboolean | jboolean | unsigned 8 bits\nbyte | jbyte | signed 8 bits\nchar | jchar | unsigned 16 bits\nshort | jshort | signed 16 bits\nint | jint | signed 32 bits\nlong | jlong | signed 64 bits\nfloat | jfloat | signed 32bit\ndouble | jdouble | signed 64 bits\nClass | jcalss | class类对象\nString | jstring | 字符串对象\nObject | jobject | 任何java对象\nbyte[] | jbyteArray | byte数组\nJNI C++的实现和C的实现 JNI 并没有完全使用C++实现，而是通过对C对JNI实现的包装来实现，即C++的实现是通过调用C的实现来完成的，因此C++中的JNI函数的JNIEnv实际上是(JNINativeInterface的)二级指针。\nJNI注册 JNI注册分静态注册和动态注册两种。\n静态注册 编写Java类JNITest.java，添加JNI(本地)方法。\n在将JNITest.java编译成class文件夹后使用javah path/to/JNITest生成头文件。然后添加.c/.cpp源文件，include头文件实现相应的方法。\n另外还有一种是在项目cpp文件夹添加一个源文件按相应规则可以将项目中所有JNI方法添加到这个文件。\n静态注册简单，但编写不方便，步骤也多，还需要遵循相应的命名规范，名字比较长。另外由于初次调用native函数时需要根据函数名在JNI层搜索对应的JNI(本地)函数建立对应关系的过程会比较耗时影响运行效率。\n动态注册 在JNI_OnLoad中注册，JNI_OnUnload中卸载。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  #define AUDIO_RECORDER_CLASS_PATH \u0026#34;com/osshare/media/record/AudioRecorder\u0026#34; JNINativeMethod audioRecorderMethods[] = { {\u0026#34;nativeEncode\u0026#34;, \u0026#34;([B)I\u0026#34;, (void *) audioEncode}, {\u0026#34;nativeStart\u0026#34;, \u0026#34;(Ljava/lang/String;)I\u0026#34;, (void *) audioStart}, {\u0026#34;nativeStop\u0026#34;, \u0026#34;()I\u0026#34;, (void *) audioStop} }; jint JNI_OnLoad(JavaVM *vm, void *reserved) { JNIEnv *env = NULL; jint ret = vm-\u0026gt;GetEnv((void **) \u0026amp;env, JNI_VERSION_1_6); if (ret != JNI_OK) { return ret; } jclass audioRecorderClazz = env-\u0026gt;FindClass(AUDIO_RECORDER_CLASS_PATH); ret = env-\u0026gt;RegisterNatives(audioRecorderClazz, audioRecorderMethods, sizeof(audioRecorderMethods) / sizeof(audioRecorderMethods[0])); if (ret != JNI_OK) { return ret; } return JNI_VERSION_1_6; } void JNI_OnUnload(JavaVM *vm, void *reserved) { JNIEnv *env = NULL; jint ret = vm-\u0026gt;GetEnv((void **) \u0026amp;env, JNI_VERSION_1_6); if (ret != JNI_OK) { return; } jclass audioRecorderClazz = env-\u0026gt;FindClass(AUDIO_RECORDER_CLASS_PATH); env-\u0026gt;UnregisterNatives(audioRecorderClazz); }   JNI签名    数据类型 签名     boolean Z   byte B   char C   short S   int I   long J   float F   double D   void V   object L + 以/分割的完整类型 + ;   Array [ + 数据元素类型的签名    示例：\nString \u0026ndash;\u0026gt; Ljava/lang/String;\nint[] \u0026ndash;\u0026gt; [I\nString[] \u0026ndash;\u0026gt; [Ljava/lang/String;\nint[][] \u0026ndash;\u0026gt; [[I\nJNI引用 在 JNI 规范中定义了三种引用:局部引用(Local Reference)、全局引用(Global Reference)、弱全局引用(Weak Global Reference)。\n  局部引用\n局部引用在本地方法执行完毕后一般会自动释放，但如果局部引用还被其他引用引用着就需要调用env-\u0026gt;DeleteLocalRef(jobject localRef)手动释放。\nenv-\u0026gt;NewLocalRef(jobject ref)\nenv-\u0026gt;DeleteLocalRef(jobject localRef)\n  全局引用\n全局变量需要调用env-\u0026gt;DeleteGlobalRef(jobject globalRef)手动释放。全局引用可以跨线程。\nenv-\u0026gt;NewGlobalRef(jobject obj)\nenv-\u0026gt;DeleteGlobalRef(jobject globalRef)\n  弱全局引用\n弱全局引用和全局引用在使用上是一致的(可以跨线程)，只是在JVM认为应该回收它的时候(比如内存紧张的时候)进行回收而被释放。或调用 DeleteWeakGlobalRef手动释放。\nenv-\u0026gt;NewWeakGlobalRef(jobject obj)\nenv-\u0026gt;DeleteWeakGlobalRef(jweak obj)\n  JNI常用方法介绍   GetXXX()和Releasexxx()\n对于构造方法的name是\u0026rdquo;\u0026lt;init\u0026gt;\u0026rdquo;\nGetMethodID()获取构造方法：GetMethodID(clazz,\u0026ldquo;\u0026rdquo;,\u0026quot;()V\u0026rdquo;);\n  env-\u0026gt;CallXXXMethod()、env-\u0026gt;CallXXXMethodA()和env-\u0026gt;CallXXXMethodV()\n  env-\u0026gt;Throw(jthrowable obj)和env-\u0026gt;ThrowNew(jclass clazz, const char* message)\n  env-\u0026gt;FindClass()、env-\u0026gt;DefineClass()、env-\u0026gt;GetObjectClass()、env-\u0026gt;GetSuperclass()\n  env-\u0026gt;AllocObject()\n  ExceptionCheck()、ExceptionClear()、ExceptionDescribe()、ExceptionOccurred()、FatalError()、Throw()和ThrowNew()\n ExceptionOccurred() 检查是否发生JNI异常 ExceptionClear() 清空JNI异常 ThrowNew() ThrowNew向Java抛出异常，让Java处理。    env-\u0026gt;FromReflectedField()、env-\u0026gt;FromReflectedMethod()、env-\u0026gt;ToReflectedField()和env-\u0026gt;ToReflectedMethod()\n  env-\u0026gt;NewXXX()  env-\u0026gt;RegisterNatives()和env-\u0026gt;UnregisterNatives()\n  env-\u0026gt;PopLocalFrame()和env-\u0026gt;PushLocalFrame()\n  env-\u0026gt;SetXXX()\n  野指针 异常处理 JNI的异常和Java中的异常处理流程是不一样的，Java遇到异常如果没有捕获，程序会立即停 止运行。而JNI遇到未决的异常不会改变程序的运行流程，也就是程序会继续往下走。\nJNI缓存机制 静态局部变量会缓存。\n1 2 3 4 5 6 7 8 9  extern \u0026#34;C\u0026#34; JNIEXPORT jint JNICALL Java_com_osshare_lcc_media_MMediaPlayer_nativeSetSurface(JNIEnv *env, jobject thiz,jobject surface){ static jfieldID fieldID = NULL; if(fieldID == NULL){ env-\u0026gt;GetFieldID(...); printf(\u0026#34;-----GetFieldID-----\\n\u0026#34;); } }   上面示例中静态局部变量是会缓存的，当在Java中多次调用Java_com_osshare_lcc_media_MMediaPlayer_nativeSetSurfaceJNI方法时，GetFieldID只会调用一次(\u0026mdash;\u0026ndash;GetFieldID\u0026mdash;\u0026ndash;只会打印一次)。\n什么是NDK NDK是Android提供的一个Native开发工具包。它实现了在Android中的JNI功能。它还提供了交叉编译器，将Native代码编译生成动态(.so)/静态(.a)库并打包到Apk的能力。\nC/C++编译器  gcc\nGNU C编译器。原本只能处理C语言，很快扩展，变得可处理C++ g++\nGNU c++编译器，后缀为.c的源文件，gcc把它当作是C程序，而g++当作是C++程序；后缀为.cpp的，两者都会认为是c++程序，g++会自动链接c++标准库stl，gcc不会，gcc不会定义__cplusplus宏，而g++会 clang\n一个C、C++、Object-C的轻量级编译器，基于LLVM（用于开发编译器相关的库），速度相比 gcc/g++更快。 GDB(GNU Project debugger)\nGUN开源组织发布的Unix/Linux下功能强大的基于命令行的程序调试工具。  静态库/动态库  静态库\n编译期链接函数库。即把所有用到的对象文件和函数库打包进来，运行时不在需要这些函数库一起使用，因此通常编译出来的文件会比较大。 动态库\n运行时链接函数库。这样不需要把函数库都提前打包进来。这可以实现进程间资源的共享，共享库编译出来的文件比较小。在Android中可以显著减小Apk大小。  本地编译/交叉编译  本地编译\n当前机器编译，当前机器使用，无法运行到其他类型的机器上 交叉编译\n当前机器编译目标机器使用的程序，比如编译FFmpeg，在Mac OS上编译Android可以使用的库需要交叉编译。  ABI(应用程序二进制接口)    ABI 支持的指令集 备注     armeabi ARMV5TE和更高版本 Thumb-1 在r16中已弃用，在r17中已移除。无硬浮点数   armeabi-v7a armeabi TThumb-2 TVFPv3-D16 与ARMv5、ARMv6设备不兼容   arm64-v8a AArch64    x86 x86(IA-32) MMX SSE/2/3 SSSE3 不支持MOVBE或SSE4   x86_64 x86-64 MMX SSE/2/3 SSSE3 SSE4.1、4.2 POPCNT     System.load(filename)和System.loadLibrary(libname)  System.load(filename) 加载native库，必须是native库文件的绝对路径 System.loadLibrary(libname) 通过库名加载native库，需要配置native库  linux shell脚本基础 ndk-build 在CMake之前Android基本都是通过编写Application.mk和Android.mk文件，使用ndk-build命令来完C/C++成编译。\n关于Application.mk和Android.mk的内容及规范见Android NDK指南的ndk-build部分。\n编写好Application.mk和Android.mk后进入到相应文件夹下(Android一般为jni)执行ndk-build命令\nAndroid CMake CMake使用见Android NDK\n参考：\n Android NDK Simpleperf Using the GNU Compiler Collection (GCC) 3.19.5 ARM Options  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-lottie/",
	"title": "Android-lottie",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android lottie动画",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E9%9F%B3%E8%A7%86%E9%A2%91%E4%B9%8Bmediacodec/",
	"title": "Android-MediaCodec",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "Android-MediaCodec",
	"content": "前言 API介绍 MediaFormat 配置类，略。\nMediaCodec createEncoderByType(type) \u0026ndash; 创建一个将输入数据编码成type类型的编码器。\n常见type类型：\nMediaFormat.MIMETYPE_VIDEO_AVC //H264 MediaFormat.MIMETYPE_AUDIO_AAC //AAC createDecoderByType(type) \u0026ndash; 创建用来解码type类型数据的解码器，type类型同createEncoderByType(type)\ncreateByCodecName(name) \u0026ndash;\ncreatePersistentInputSurface() \u0026ndash; API 23可用。\nconfigure(format,surface, crypto, flags) \u0026ndash; 配置MediaCodec。format：当mediaCodec是编码器时表示将输入数据的编码成什么格式，当mediaCodec是解码器时表示输入数据的编码格式。surface：指定显示解码器解码后显示的surface，当编码或不需要显示时设置为null。crypto：加密时使用，flags：当编码时需要执行flag为MediaCodec.CONFIGURE_FLAG_ENCODE。\ncreateInputSurface() \u0026ndash; 创建一个输入Surface替代输入缓冲区队列。MediaCodec将从Surface中取数据进行编码。\ndequeueInputBuffer(timeoutUs) \u0026ndash; 从输入缓冲区队列中获取一个缓冲区，如果有可用队列返回该队列索引，-1表示获取失败。timeoutUs表示获取超时时间。\ngetInputBuffer(index) \u0026ndash; 根据dequeueInputBuffer返回的索引获取可写的ByteBuffer对象。ByteBuffer的空间指向的是输入缓冲区队列中的一个缓冲区。可向ByteBuffer对象中put音视频数据。\ngetInputImage(index) \u0026ndash; 根据dequeueInputBuffer返回的索引获取可写的Image对象。\nqueueInputBuffer(index,offset, size, presentationTimeUs, flags) \u0026ndash; 将dequeueInputBuffer出队的缓冲区入队。\ndequeueOutputBuffer(info, timeoutUs) \u0026ndash; 从输出缓冲队列中出队一个(编码/解码后的)输出缓冲区。\ngetOutputBuffer(index) \u0026ndash; 根据dequeueOutputBuffer返回的索引返回一个只读的ByteBuffer对象，从ByteBuffer对象取出编码/解码后的数据。\nreleaseOutputBuffer(index, render) \u0026ndash; 释放缓冲区。如果mediaCodec.configure配置了Surface，render设置为true表示这个OutputBuffer的数据会在Surface上显示。\nsignalEndOfInputStream() \u0026ndash;\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-mvcmvp%E5%8F%8Amvvm/",
	"title": "Android-MVC、MVP及MVVM",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android-MVC、MVP及MVVM",
	"content": "MVC Model+View+Controller\nModel：Java bean\nView：视图层\nController：控制器\nMVC在Java Web开发中很常见，但并不适合Android中使用。因为Androi中dActivity既是View又是Controller，达不到分层解耦的目的。\nMVP Model+View+Presenter\nModel：数据\nView：视图\nPresenter：业务逻辑控制，是Model和View的桥梁\nMVP是将Activity的业务逻辑部分抽象出来放到Presenter处理，Activity尽量只负责显示。Model则负责数据部分，如请求网络或查找缓存以及对请求数据的缓存策略及其他数据管理。三者通过接口回调相互关联。View接口中定义几个状态的方法回调，Activity实现在定义的状态回调中展示相应状态页面。\nMVVM Model+View+ViewModel\nMVVM并不是M+V+V+M，而是M+V+VM\nModel：业务数据模型\nView：视图\nViewModel：联系Model和View，实现双向绑定\nMVVM相比MVP的优势是实现了数据的双向绑定，动态感知，不像MVP需要一堆回调。然而在Android界面通常是一个XML，实现双向绑定并不易。\nGoogle推出了DataBing来支持MVVM模式。\nDataBinding DataBinding使用 Module下的build.gradle中\ndataBinding { enabled true } 进入xml页面，选中根元素，mac下option+回车，点击Convert to data binding layout\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;data class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;import alias=\u0026#34;\u0026#34; type=\u0026#34;com.osshare.dsh.dm.Chapter\u0026#34; /\u0026gt; \u0026lt;variable name=\u0026#34;chapter\u0026#34; type=\u0026#34;Chapter\u0026#34; /\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tvText\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/aqua\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;@{chapter.name}\u0026#34; android:textColor=\u0026#34;@color/white\u0026#34; android:textSize=\u0026#34;@dimen/textSize16\u0026#34; /\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; \u0026lt;/layout\u0026gt;    data\n默认情况下DataBinding会按照布局文件名的驼峰格式+Binding为类名生成Binding类，如：activity_main.xml，Binding类即为：ActivityMainBinding\n如果你想自定义这个类名可以使用data节点有个class属性设置自己想要的类名。 import\ntypes属性是绑定数据的全限定名，alias属性指定别名，如果不指定默认是不包含包路径的类名 variable\nname属性是绑定到xml中时所使用的名字，type是该变量的类型，如果import设置了alias属性即是alias，如果不设置即为不包含包路径的类名  Activity中\n1 2 3 4 5 6 7 8  override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) mBinding = DataBindingUtil.setContentView(this, getLayoutId()) val chapter=... //数据绑定  mBinding.chapter=chapter }   Fragment中可以使用mBinding= DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false)\n另外还可以绑定单击长按等事件\n 定义事件发生要执行的方法\nclass MyHandlers {\nfun onClickFriend(view: View) { \u0026hellip; }\n} xml中注册 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  \u0026lt;layout xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; xmlns:app=\u0026#34;http://schemas.android.com/apk/res-auto\u0026#34;\u0026gt; \u0026lt;data class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;import alias=\u0026#34;\u0026#34; type=\u0026#34;com.osshare.dsh.dm.Chapter\u0026#34; /\u0026gt; \u0026lt;variable name=\u0026#34;chapter\u0026#34; type=\u0026#34;Chapter\u0026#34; /\u0026gt; \u0026lt;variable name=\u0026#34;handlers\u0026#34; type=\u0026#34;com.example.MyHandlers\u0026#34;/\u0026gt; \u0026lt;/data\u0026gt; \u0026lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/tvText\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/aqua\u0026#34; android:gravity=\u0026#34;center\u0026#34; android:text=\u0026#34;@{chapter.name}\u0026#34; android:onClick=\u0026#34;@{handlers::onClickFriend}\u0026#34; android:textColor=\u0026#34;@color/white\u0026#34; android:textSize=\u0026#34;@dimen/textSize16\u0026#34; /\u0026gt; \u0026lt;/androidx.coordinatorlayout.widget.CoordinatorLayout\u0026gt; \u0026lt;/layout\u0026gt;    实现MVVM双向绑定\n只需要将android:text=\u0026quot;@{chapter.name}\u0026quot;改成android:text=\u0026quot;@={chapter.name}\u0026quot;\n双向绑定的情况下当我们调用dataBinding.tvText.text = \u0026quot;yyyyyyxxxxxx\u0026quot;时，dataBinding中的chapter的name也会被修改  另外结合ViewModel LiveData Room\nViewModel 确保数据在设备配置更改(如横竖屏切换导致的销毁重建)后仍然存在。\nRoom 在数据库发生更改时通知 LiveData，LiveData 进而使用修订后的数据更新界面。\nLiveData 具有生命周期感知的组件，并且可以感知数据的变化\n一般是ViewModel持有LiveData。\nRoom + ViewModel + LiveData + DataBinding 是比较完美的MVVM框架\nDataBinding原理 使用DataBinding后layout的xml文件会被拆分为两部分：\n build/intermediates/data_binding_layout_info_type_merge下的layout_info文件 xx  当 xml使用@{xx.xx}或使用@Bindable注解属性的get方法时，DataBinding会生成相应的BR文件属性\n0) { mBinding.setVariable(variableId, mViewModel) -- } "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-pthread/",
	"title": "Android-pthread",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "Android-pthread",
	"content": "占坑，敬请期待\u0026hellip;\nPosix(Portable Operating System Interface) Posix，可移植操作系统接口。是IEEE为要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称，其正式称呼为IEEE Std 1003，国际标准名称为ISO/IEC 9945。X是表明其对Unix API的传承。\nBionic Bionic是Android的Linux内核库，包括libc、libdl、libm、libstdc++、linker等。\npthread(Posix Thread) Android中的Bionic实现的pthread并没有对Posix Thread完全实现，比如没有实现int pthread_cancel(pthread_t)\n创建线程\nint pthread_create(pthread_t* __pthread_ptr, pthread_attr_t const* __attr, void* (*__start_routine)(void*), void*);\n线程退出\nvoid pthread_exit(void *)\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-retrofit%E5%88%86%E6%9E%90/",
	"title": "Android-Retrofit分析",
	"tags": ["android", "retrofit"],
	"categories": [],
	"series": [],
	"description": "Retrofit分析",
	"content": "前言 官方介绍：A type-safe HTTP client for Android and Java.\nRetrofit是通过动态代理实现对OkHttp封装实现面向接口编程的经典网络库。并通过附加库(转换器和适配器)实现对各反序列化库和RxJava等插拔式的支持。\n为什么我说是反序列化库而不是JSON？因为Retrofit支持的反序列化并不只有JSON库，还有非JSON的ProtoBuf、XML方式等。\n目前转换器支持：Gson、Jackson、Moshi、ProtoBuf、JAXB、Guava等。\n目前适配器支持：RxJava、Guava等。\n原理及核心代码分析 原理：动态代理(关于动态代理详见动态代理)，但Retrofit不是通常的动态代理用法，经典的动态代理仍然是有一个继承接口的实现类的，但Retrofit并没有，取而代之的是将接口的注解和参数封装成ServiceMethod对象，再通过ServiceMethod组装成包装了okhttp3.Call的OkHttpCall对象，再经过适配器(如RxJava2CallAdapter)转换成相应的对象(如Observable\u0026lt;Response\u0026lt;R\u0026raquo;)。OkHttpCall被包含在适配器转换后的对象内。\n转换器则是先由Retrofit内置转换器BuiltInConverters转换后再交给其他转换器(如GsonConverterFactory)接力转换\n代理部分核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public \u0026lt;T\u0026gt; T create(final Class\u0026lt;T\u0026gt; service) { validateServiceInterface(service); return (T) Proxy.newProxyInstance( service.getClassLoader(), new Class\u0026lt;?\u0026gt;[] {service}, new InvocationHandler() { private final Platform platform = Platform.get(); private final Object[] emptyArgs = new Object[0]; @Override public @Nullable Object invoke(Object proxy, Method method, @Nullable Object[] args) throws Throwable { // 如果是Object中声明的方法(hashCode,toString等)，不代理  if (method.getDeclaringClass() == Object.class) { return method.invoke(this, args); } args = args != null ? args : emptyArgs; return platform.isDefaultMethod(method)//是否是接口的default方法  ? platform.invokeDefaultMethod(method, service, proxy, args) : loadServiceMethod(method).invoke(args);//Android使用正常逻辑走这里  } }); }   适配器(以RxJava2CallAdapter为例)部分核心代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  @Override public Object adapt(Call\u0026lt;R\u0026gt; call) { Observable\u0026lt;Response\u0026lt;R\u0026gt;\u0026gt; responseObservable = isAsync ? new CallEnqueueObservable\u0026lt;\u0026gt;(call) : new CallExecuteObservable\u0026lt;\u0026gt;(call); Observable\u0026lt;?\u0026gt; observable; if (isResult) { observable = new ResultObservable\u0026lt;\u0026gt;(responseObservable); } else if (isBody) { observable = new BodyObservable\u0026lt;\u0026gt;(responseObservable); } else { observable = responseObservable; } if (scheduler != null) { observable = observable.subscribeOn(scheduler); } if (isFlowable) { return observable.toFlowable(BackpressureStrategy.LATEST); } if (isSingle) { return observable.singleOrError(); } if (isMaybe) { return observable.singleElement(); } if (isCompletable) { return observable.ignoreElements(); } return RxJavaPlugins.onAssembly(observable); }   使用简单介绍 一般Retrofit的使用：\n1 2 3 4 5 6 7 8  public static Retrofit provide(OkHttpClient client, String baseUrl) { return new Retrofit.Builder() .client(client) .baseUrl(baseUrl) .addCallAdapterFactory(RxJava2CallAdapterFactory.create()) .addConverterFactory(GsonConverterFactory.create()) .build(); }   注解使用示例：\n略\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-surface%E8%AF%A6%E8%A7%A3/",
	"title": "Android-Surface详解",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "Android-Surface详解",
	"content": "占坑，敬请期待\u0026hellip;\nSurfaceView  子线程绘制 双缓冲模式\nSurfaceView有两个缓冲区：前台缓冲区和后台缓冲区。在后台线程绘制并将绘制数据缓存起来，绘制完毕后再回到UI线程一次性将所有的绘制渲染到屏幕，及后台线程绘制，UI线程渲染。  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-vrarmr/",
	"title": "Android-VR&amp;AR",
	"tags": ["vr", "ar", "mr"],
	"categories": [],
	"series": [""],
	"description": "Android-VR&amp;AR",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-webview%E4%BD%BF%E7%94%A8/",
	"title": "Android-WebView使用",
	"tags": ["android"],
	"categories": [],
	"series": ["android"],
	"description": "Android-WebView使用",
	"content": "占坑，敬请期待\u0026hellip;\n前言 Android4.4以前采用的是WebKit内核，Android4.4及以后采用的是chromium内核。\n这里只讨论Android5.0及以后的WebView。\n一般在项目中使用WebView时为了防止WebView页面Crash影响整个App都会将WebView放在单独的进程中。\nWebView WebView主要用于加载管理，生命周期管理，状态管理。\nloadUrl(url) \u0026ndash; 加载一个网页。可以从网络加载也可以从Apk包中加载，也可以从手机本地加载。\n示例：\n1 2 3  webView.loadUrl(\u0026#34;http://www.google.com/\u0026#34;);//网络加载 webView.loadUrl(\u0026#34;file:///android_asset/test.html\u0026#34;); //Apk加载 webView.loadUrl(\u0026#34;content://com.android.htmlfileprovider/sdcard/test.html\u0026#34;);   loadUrl(url, additionalHttpHeaders) \u0026ndash; 加载一个网页。同loadUrl(url)，可以添加Http头字段。\nloadData(data, mimeType, encoding) \u0026ndash; 加载HTML页面的一小段内容。\n示例：\n1  webView.loadData(\u0026#34;\u0026#34;,\u0026#34;text/html\u0026#34;,\u0026#34;utf-8\u0026#34;);   loadDataWithBaseURL(baseUrl, data,mimeType, encoding, historyUrl)\nonResume() \u0026ndash; 激活WebView为活跃状态，能正常执行网页的响应\nonPause() \u0026ndash; 通过onPause动作通知内核暂停所有的动作，比如DOM的解析、plugin的执行、JavaScript执行。\npauseTimers() \u0026ndash; 当应用程序被切换到后台时，暂停所有(不仅仅是当前的)webview的layout，parsing，javascripttimer。降低CPU功耗。\nresumeTimers() \u0026ndash; 回复pauseTimers()前状态\nclearCache(includeDiskFiles) \u0026ndash; 清除网页访问留下的缓存。由于内核缓存是全局的因此这个方法不仅仅针对webview而是针对整个应用程序。\nclearHistory() \u0026ndash; 清除WebView的所有历史访问记录除了当前正在访问的页面。\nclearFormData() \u0026ndash; 仅清除自动完成填充的表单数据，并不会清除WebView存储到本地的数据。\n销毁WebView \u0026ndash; 在关闭了Activity时需要销毁Webview，如果Webview的音乐或视频还在播放就必须销毁Webview 但是注意：webview调用destory时，webview仍绑定在Activity上这是由于自定义WebView构建时传入了该Activity的context对象因此需要先从父容器中移除WebView,然后再销毁WebView\n1 2  webViewParentLayout.removeView(webView); webView.destroy();   WebSettings WebSettings主要用于配置WebView。\nsetJavaScriptEnabled(flag) \u0026ndash; 是否支持Native与JS交互。\nsetUseWideViewPort(use) \u0026ndash; 是否支持页面内容自适应屏幕，和setLoadWithOverviewMode配合使用。\nsetLoadWithOverviewMode(overview) \u0026ndash; 页面缩放至屏幕的大小，和setUseWideViewPort配合使用。\nsetSupportZoom(support) \u0026ndash; 是否支持缩放操作。\nsetBuiltInZoomControls(enabled) \u0026ndash;\nsetDisplayZoomControls(support) \u0026ndash;\nsetCacheMode(mode) 设置缓存模式。\nLOAD_DEFAULT 根据cache-control决定是否从网络上取数据。\nLOAD_CACHE_ELSE_NETWORK 只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。\nLOAD_NO_CACHE 不使用缓存，只从网络获取数据。\nLOAD_CACHE_ONLY 不使用网络，只读取本地缓存数据。\nWebViewClient 主要对页面各种通知的管理。\nshouldOverrideUrlLoading(view, request) \u0026ndash; 重写shouldOverrideUrlLoading()方法，使得打开网页时不调用系统浏览器， 而是在本WebView中显示。\n1 2 3 4 5 6 7  webView.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, WebResourceRequest request) { webView.loadUrl(request.getUrl().toString(),request.getRequestHeaders()); return true; } });   onPageStarted(view, url, favicon) \u0026ndash; 页面开始加载\nonPageFinished(view,url) \u0026ndash; 页面加载结束\nonLoadResource(view, url) \u0026ndash; 加载页面资源(如图片等)时的回调。\nonReceivedError(view, request, error) \u0026ndash; 加载页面服务器返回错误(比如404)时回调。可以在这里加载一个本地html页面友好提示用户而不是将原错误页面显示在这里。\nonReceivedSslError(view, handler, error) \u0026ndash; webView默认是不处理https请求的，页面显示空白，如果需要处理HTTPS需要重写该方法，加上handler.proceed()，5.1以上默认禁止了https和http混用，可以使用下面方式是开启 ：\n1 2 3  if (Build.VERSION.SDK_INT \u0026gt;= Build.VERSION_CODES.LOLLIPOP) { mWebView.getSettings().setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); }   WebChromeClient 主要用来辅助与JS的交互。如处理 Javascript 的对话框，网站图标，网站标题等等\nonProgressChanged(view, newProgress) \u0026ndash; 页面加载进度回调。\nonReceivedTitle(view, title) \u0026ndash; 获取页面标题回调。\nonJsAlert(view, url, message,result)\nonJsConfirm(view, url, message,result)\nonJsPrompt(view, url, message,defaultValue, result)\nonJsBeforeUnload(view, url, message,result)\nWebView与Native交互 Native调用JS：\n webView.loadUrl(url)\n方便简介，效率低，获取返回值麻烦。 evaluateJavascript(script, resultCallback)\n效率高，方便获取返回值，只能Android4.4以上使用。\n需要注意的是执行JS需要在onPageFinished()回调之后，否则可能不会执行。\nJS调用Native： addJavascriptInterface(obj, interfaceName)\n该方式方便简洁，通过对象映射实现，4.2之前存在漏洞。适合4.2以上的简单互调场景。 WebViewClient#shouldOverrideUrlLoading(view, request)\n该方法中拦截url，根据事先协商好的规则执行响应操作。该方式不存在漏洞但使用相对复杂，传值繁琐。适合不需要返回值的场景。 WebChromeClient的onJsAlert、onJsConfirm、onJsPrompt\n该方式不存在漏洞，但使用复杂，需要事先协议约束，能满足大多数的互调场景。  缓存机制 WebView漏洞   任意代码执行漏洞\n漏洞原因：\n WebView#addJavascriptInterface() 接口\nAndroid 4.2 版本中规定对被调用的函数以 @JavascriptInterface进行注解从而避免漏洞攻击。 WebView内置导出的searchBoxJavaBridge_对象可能被利用，实现远程任意代码\nWebView对象创建时使用removeJavascriptInterface移除searchBoxJavaBridge_对象。 webView.removeJavascriptInterface(\u0026quot;searchBoxJavaBridge_\u0026quot;);  []()WebView 内置导出的 accessibility 和 accessibilityTraversalObject对象，可被利用实现远程任意代码执行\nWebView对象创建时使用removeJavascriptInterface移除accessibility和accessibilityTraversalObject对象。 webView.removeJavascriptInterface(\u0026quot;accessibility\u0026quot;); webView.removeJavascriptInterface(\u0026quot;accessibilityTraversal\u0026quot;);     密码明文存储漏洞\nAndroid默认开启密码保存功能。在用户输入密码时，会弹出提示框：询问用户是否保存密码；如果选择”是”，密码会被明文保到 /data/data/com.package.name/databases/webview.db 中，这样就有被盗取密码的危险。\n解决方案：使用WebSettings.setSavePassword(false) 取消保存密码。\n  域控制不严格漏洞\n即 A 应用可以通过 B 应用导出的 Activity 让 B 应用加载一个恶意的 file 协议的 url，从而可以获取 B 应用的内部私有文件带来数据泄露威胁。\n解决方案：\n1 2 3 4 5 6 7 8 9  // 需要使用 file 协议 setAllowFileAccess(true); setAllowFileAccessFromFileURLs(false); setAllowUniversalAccessFromFileURLs(false); // 禁止 file 协议加载 JavaScript if (url.startsWith(\u0026#34;file://\u0026#34;) { setJavaScriptEnabled(false); } else { setJavaScriptEnabled(true); }     性能优化 PWA(Progressive Web App) 开源第三方框架 Documentation Reference WebView\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E5%A2%9E%E9%87%8F%E6%9B%B4%E6%96%B0%E5%AE%9E%E7%8E%B0/",
	"title": "Android-增量更新实现",
	"tags": ["android"],
	"categories": [],
	"series": ["android"],
	"description": "Android-增量更新实现",
	"content": "占坑，敬请期待\u0026hellip;\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E8%BF%9B%E7%A8%8B%E5%8F%8Abinder/",
	"title": "Android-多进程意义及Binder",
	"tags": ["android"],
	"categories": [],
	"series": ["android"],
	"description": "Android多进程及Binder机制",
	"content": "进程 什么是进程 Android进程分类 Android中有五大进程：\n 前台进程 当前正与用户交互的进程 可见进程 在屏幕中显示，但处于不可交互状态，如startForeground()启动的Service。 服务进程 在后台为用户服务的进程，如startService()方法启动的Service。 后台进程 空进程 空进程的意义就是提高程序启动速度，有些程序退出后仍保留一个空进程，以便下次快速启动。  多进程App的意义  分担内存压力\nAndroid分配给每个进程都有一个最大内存限制，多进程下可以有效分担内存压力 隔离保护\n比如比较常说到的原因：WebView，因为WebView的漏洞不稳定性将其单独放到一个进程不至于影响其他部分。  一般下载比较耗内存，WebView有bug风险都会单独放在一个进程。\n进程间通信方式  共享内存 不需要copy 控制复杂，易用性差。依赖上层协议，访问接入点是开放的，不安全。 管道(pipe) Socket copy两次 基于C/S架构，作为一款通用接口，其传输效率低，开销大。依赖上层协议，访问接入点是开放的，不安全。 信号(signal) Binder copy一次 基于C/S架构，易用性高，为每个APP分配UID，支持实名和匿名  Binder 什么是Binder 从机制模型的角度Binder是Android中实现的一种跨进程通信方式，从模型的结构和组成说Binder是一种虚拟的物理设备驱动(Binder驱动)，用来连接Service进程、Client进程和Service Manager进程。从代码的角度讲Binder是一个实现了IBinder接口的Binder类。\nBinder数据传输 服务端的一块空间和内核空间映射在同一块物理内存(通过mmap内存映射)\n客户端发送数据：调用copy_from_user()将数据复制到内核缓冲区\nAIDL实现进程通信 线程的内存是共享的，进程的内存是隔离的，所以无法直接通信。\nAndroid中创建一个进程会分配一个UID，但传统的IPC机制并不会，但系统会要求进程把PID发送给系统，即是进程传递给系统，这和系统给进程分配的Android明显不一样。\n明显系统分配更安全。\n另外像共享内存、Socket的访问点是开放的，就像做公交车谁都可以在这个站点上车，Android因为记录了每个进程的UID能更好的掌控。另外Android进程通信还支持实名和匿名\nAIDL Android 接口定义语言，是对Binder通信流程的封装，所以其实不用AIDL也是可以实现两进程间Binder通信的，但肯定更麻烦。\nAIDL使用  service端创建AIDL接口文件，定义方法，如果该方法参数使用了自定义的类需要在方法前加in、out、inout\n其中in表示是client端传递过来的参数，out表示service端修改这个参数时client端能够感知到，inout是两者的合体。 适应自定义类除了定义的类继承Parcelable，还需要在aidl文件夹下相应包中建立aidl文件声明该类，声明分两部分：package和类型，如下： package com.osshare.lcc.service; parcelable Person;//parcelable首字母是小写  aidl文件和自定义类需要service端和client端各一份。另外service端还需要定义相关Service，client端需要做连接。  客户端：\nProxy是客户端请求服务端的入口\nProxy.xxxXXX()\n服务端：\n服务端Stub接收客户端的请求\nStub.onTransact()\n相当于做火车，\nIBinder是火车票，内核空间是火车，Proxy是进车站，Stub是出车站，Proxy.getXXX()是检票口，Stub.onTransact()是出站口\n当我们在客户端执行aidlInterface.getXXX()时会走到aidlInterface的实现类Proxy的getXXX()，在Proxy.getXXX()方法中当执行到mRemote.transact时就由客户端用户空间进入了内核空间，内核空间在IBiner机制作用下会走到服务端的Stub.onTransact()并执行Stub的实现类中相应方法。\n其中在客户端调用Proxy.getXXX()时你会发现由两个Parcel对象_data和_reply，其中_data承载我们的参数，_reply承载从服务端返回的数据\nAIDL文件分析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  public static abstract class Stub extends android.os.Binder implements com.osshare.lcc.IMyAidlInterface{ private static final java.lang.String DESCRIPTOR = \u0026#34;com.osshare.lcc.IMyAidlInterface\u0026#34;; public Stub(){ this.attachInterface(this, DESCRIPTOR); } public static com.osshare.lcc.IMyAidlInterface asInterface(android.os.IBinder obj){ if ((obj==null)) {//obj是服务端返回的IBinder  return null; } //查找描述符，因为只有服务端需要实例Stub，而描述符DESCRIPTOR只在Stub构造函数中传入  //如果没找到描述符DESCRIPTOR说明并没有实现Stub是同一进程，如果找到描述符DESCRIPTOR说明非同已进程  android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR); if (((iin!=null)\u0026amp;\u0026amp;(iin instanceof com.osshare.lcc.IMyAidlInterface))) {//如果是同一进程直接返回，同一进程不需要再通过IBinder通信  return ((com.osshare.lcc.IMyAidlInterface)iin); } //非同一进程返回代理，后面客户端执行相应方法会走代理  //这里可以任务不同进程返回的是服务的Proxy，即客户端  return new com.osshare.lcc.IMyAidlInterface.Stub.Proxy(obj); } ... private static class Proxy implements com.osshare.lcc.IMyAidlInterface { private android.os.IBinder mRemote; Proxy(android.os.IBinder remote) { mRemote = remote; } ... @Override public com.osshare.lcc.service.Person getPerson(java.lang.String name) throws android.os.RemoteException { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); com.osshare.lcc.service.Person _result; try { _data.writeInterfaceToken(DESCRIPTOR);//校验  _data.writeString(name); //此处transact方法的flag=0表示客户端可以请求服务端可以返回  //flag=1表示只能客户端请求服务端不能返回  boolean _status = mRemote.transact(Stub.TRANSACTION_getPerson, _data, _reply, 0); if (!_status \u0026amp;\u0026amp; getDefaultImpl() != null) { return getDefaultImpl().getPerson(name); } _reply.readException(); if ((0!=_reply.readInt())) { _result = com.osshare.lcc.service.Person.CREATOR.createFromParcel(_reply); } else { _result = null; } } finally { _reply.recycle(); _data.recycle(); } return _result; } ... } ... }   AIDL中客户端调用bindService，进入到ContextImpl的bindService-\u0026gt;bindServiceCommon，在bindServiceCommon有两个关键点\n 调用mPackageInfo.getServiceDispatcher返回IServiceConnection对象，mPackageInfo.getServiceDispatcher-\u0026gt;getServiceDispatcherCommon。而LoadedApk.ServiceDispatcher持有ServiceConnection和IServiceConnection对象IBinder对象。我们后面bindService成功拿到服务端IBinder时就是通过IServiceConnection对象回传给客户端的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  private IServiceConnection getServiceDispatcherCommon(ServiceConnection c, Context context, Handler handler, Executor executor, int flags) { ... LoadedApk.ServiceDispatcher sd = null; if (sd == null) { if (executor != null) { sd = new ServiceDispatcher(c, context, executor, flags); } else { sd = new ServiceDispatcher(c, context, handler, flags); } if (DEBUG) Slog.d(TAG, \u0026#34;Creating new dispatcher \u0026#34; + sd + \u0026#34; for conn \u0026#34; + c); if (map == null) { map = new ArrayMap\u0026lt;\u0026gt;(); mServices.put(context, map); } map.put(c, sd); } else { sd.validate(context, handler, executor); } return sd.getIServiceConnection(); }   我们再进入LoadedApk.ServiceDispatcher对象看到返回的其实就是ServiceDispatcher.InnerConnection对象，而ServiceDispatcher.InnerConnection是一个IBinder。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  private final ServiceDispatcher.InnerConnection mIServiceConnection; private static class InnerConnection extends IServiceConnection.Stub { @UnsupportedAppUsage final WeakReference\u0026lt;LoadedApk.ServiceDispatcher\u0026gt; mDispatcher; InnerConnection(LoadedApk.ServiceDispatcher sd) { mDispatcher = new WeakReference\u0026lt;LoadedApk.ServiceDispatcher\u0026gt;(sd); } public void connected(ComponentName name, IBinder service, boolean dead) throws RemoteException { LoadedApk.ServiceDispatcher sd = mDispatcher.get(); if (sd != null) { sd.connected(name, service, dead); } } }    通过以下代码进入到AMS，ActivityManager.getService()既是获取AMS对象，调用bindIsolatedService方法。Android7.0及以下版本使用的是ActivityManagerNative.getDefault()，但Android8.0及以上版本废弃了ActivityManagerNative直接使用了ActivityManager。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  ActivityManager.getService().bindIsolatedService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, instanceName, getOpPackageName(), user.getIdentifier()); //ActivityManager.getService() @UnsupportedAppUsage public static IActivityManager getService() { //这里吐过没有创建会调用IActivityManagerSingleton.create  return IActivityManagerSingleton.get(); } //IActivityManager实际上是IActivityManager.aidl编译的java文件，是Binder的接口文件 //ActivityManagerService就继承了IActivityManager.Stub @UnsupportedAppUsage private static final Singleton\u0026lt;IActivityManager\u0026gt; IActivityManagerSingleton = new Singleton\u0026lt;IActivityManager\u0026gt;() { @Override protected IActivityManager create() { //返回ServiceManager中缓存的AMS的IBinder  final IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE); //像我们写的AIDL一样，不同的进程，这里其实返回的ActivityManagerProxy，即请求AMS服务的客户端。  final IActivityManager am = IActivityManager.Stub.asInterface(b); return am; } }; //frameworks/base/core/java/android/os/ServiceManager.java /** @hide */ public final class ServiceManager { ... /** * Cache for the \u0026#34;well known\u0026#34; services, such as WM and AM. */ @UnsupportedAppUsage private static HashMap\u0026lt;String, IBinder\u0026gt; sCache = new HashMap\u0026lt;String, IBinder\u0026gt;(); ... @UnsupportedAppUsage public static IBinder getService(String name) { try { IBinder service = sCache.get(name); if (service != null) { return service; } else { return Binder.allowBlocking(rawGetService(name)); } } catch (RemoteException e) { Log.e(TAG, \u0026#34;error in getService\u0026#34;, e); } return null; } }     ServiceManager的作用：\n我们知道系统有很多服务在，这些服务并不和我们的App在一个进程，这时候我们需要通过Binder机制调用这些服务，这显然很麻烦，于是Android给我们提供了ServiceManager来管理这些服务使得更易用。ServiceManager持有这些服务的IBiner对象(开启启动是自行注册到ServiceManager中)。\n然后走到bindServiceLocked，bindServiceLocked主要有两步bringUpServiceLocked和requestServiceBindingLocked，即是A进程访问B进程的几种状态的处理\n第一步.bringUpServiceLocked处理：\n 服务所在进程没启动 服务进程启动了但Service没有创建\n其中bringUpServiceLocked的流程：\n服务所在进程没启动：bringUpServiceLocked-\u0026gt;AMS.startProcessLocked\n服务进程启动了但Service没有创建：bringUpServiceLocked-\u0026gt;realStartServiceLocked-\u0026gt;IApplicationThread.scheduleCreateService\n第二步.requestServiceBindingLocked处理： 服务进程启动了，Service也创建了，Service未绑定过，回调onBind 服务进程启动了，Service也创建了，Service绑定过，回调onRebind\n其中requestServiceBindingLocked的流程：requestServiceBindingLocked-\u0026gt;IApplicationThread.scheduleBindService  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116  int bindServiceLocked(IApplicationThread caller, IBinder token, Intent service, String resolvedType, final IServiceConnection connection, int flags, String instanceName, String callingPackage, final int userId) throws TransactionTooLargeException { ... if ((flags\u0026amp;Context.BIND_AUTO_CREATE) != 0) { s.lastActivity = SystemClock.uptimeMillis(); //一.bringUpServiceLocked处理：  //1.服务所在进程没启动  //2.服务进程启动了但Service没有创建  if (bringUpServiceLocked(s, service.getFlags(), callerFg, false, permissionsReviewRequired) != null) { return 0; } } ... if (s.app != null \u0026amp;\u0026amp; b.intent.received) { // Service is already running, so we can immediately  // publish the connection.  try { c.conn.connected(s.name, b.intent.binder, false); } catch (Exception e) { Slog.w(TAG, \u0026#34;Failure sending service \u0026#34; + s.shortInstanceName + \u0026#34; to connection \u0026#34; + c.conn.asBinder() + \u0026#34; (in \u0026#34; + c.binding.client.processName + \u0026#34;)\u0026#34;, e); } // If this is the first app connected back to this binding,  // and the service had previously asked to be told when  // rebound, then do so.  if (b.intent.apps.size() == 1 \u0026amp;\u0026amp; b.intent.doRebind) { //二.requestServiceBindingLocked处理：  //1.服务进程启动了，Service也创建了，Service未绑定过，回调onBind  //2.服务进程启动了，Service也创建了，Service绑定过，回调onRebind  requestServiceBindingLocked(s, b.intent, callerFg, true); } } else if (!b.intent.requested) { requestServiceBindingLocked(s, b.intent, callerFg, false); } ... } private String bringUpServiceLocked(ServiceRecord r, int intentFlags, boolean execInFg, boolean whileRestarting, boolean permissionsReviewRequired) throws TransactionTooLargeException { ... if (!isolated) { app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, false); if (app != null \u0026amp;\u0026amp; app.thread != null) {//app != null \u0026amp;\u0026amp; app.thread != null表示进程已经启动了  try { app.addPackage(r.appInfo.packageName, r.appInfo.longVersionCode, mAm.mProcessStats); //调用realStartServiceLocked启动服务  realStartServiceLocked(r, app, execInFg); return null; } catch (TransactionTooLargeException e) { throw e; } catch (RemoteException e) { Slog.w(TAG, \u0026#34;Exception when starting service \u0026#34; + r.shortInstanceName, e); } // If a dead object exception was thrown -- fall through to  // restart the application.  } } else { ... } if (app == null \u0026amp;\u0026amp; !permissionsReviewRequired) {//app=null表示服务进程还未创建  if ((app=mAm.startProcessLocked(procName, r.appInfo, true, intentFlags, hostingRecord, false, isolated, false)) == null) { String msg = \u0026#34;Unable to launch app \u0026#34; + r.appInfo.packageName + \u0026#34;/\u0026#34; + r.appInfo.uid + \u0026#34; for service \u0026#34; + r.intent.getIntent() + \u0026#34;: process is bad\u0026#34;; Slog.w(TAG, msg); bringDownServiceLocked(r); return msg; } if (isolated) { r.isolatedProc = app; } } ... } private final void realStartServiceLocked(ServiceRecord r, ProcessRecord app, boolean execInFg) throws RemoteException { ... app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); //scheduleCreateService创建Service  app.thread.scheduleCreateService(r, r.serviceInfo, mAm.compatibilityInfoForPackage(r.serviceInfo.applicationInfo), app.getReportedProcState()); r.postNotification(); created = true; ... } private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) throws TransactionTooLargeException { ... if ((!i.requested || rebind) \u0026amp;\u0026amp; i.apps.size() \u0026gt; 0) { bumpServiceExecutingLocked(r, execInFg, \u0026#34;bind\u0026#34;); r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); //bindService  r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.getReportedProcState()); if (!rebind) { i.requested = true; } i.hasBound = true; i.doRebind = false; } ... }   当执行到IApplicationThread.scheduleBindService就会离开AMS进入到ApplicationThread，ApplicationThread定义在ActivityThread，它其实是一个IBinder对象。ApplicationThread最终会进入到服务端的ActivityThread，调用的是ActivityThread.scheduleBindService-\u0026gt;sendMessage(H.BIND_SERVICE, s);发送一个绑定Service消息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45  public void handleMessage(Message msg) { ... switch (msg.what) { ... case BIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \u0026#34;serviceBind\u0026#34;); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; ... } ... } private void handleBindService(BindServiceData data) { Service s = mServices.get(data.token);//获取我们的服务端Service  if (DEBUG_SERVICE) Slog.v(TAG, \u0026#34;handleBindService s=\u0026#34; + s + \u0026#34; rebind=\u0026#34; + data.rebind); if (s != null) { try { data.intent.setExtrasClassLoader(s.getClassLoader()); data.intent.prepareToEnterProcess(); try { if (!data.rebind) { IBinder binder = s.onBind(data.intent);//获取IBinder对象  //ActivityManager.getService()获取AMS对象调用publishService给客户端返回对象  ActivityManager.getService().publishService( data.token, data.intent, binder); } else { s.onRebind(data.intent); ActivityManager.getService().serviceDoneExecuting( data.token, SERVICE_DONE_EXECUTING_ANON, 0, 0); } } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } } catch (Exception e) { if (!mInstrumentation.onException(s, e)) { throw new RuntimeException( \u0026#34;Unable to bind to service \u0026#34; + s + \u0026#34; with \u0026#34; + data.intent + \u0026#34;: \u0026#34; + e.toString(), e); } } } }   ActivityManagerService.publishService-\u0026gt;publishServiceLocked，在publishServiceLocked有如下一行代码c.conn.connected(r.name, service, false);，这里的c.conn即是前面的IServiceConnection对象，最终是通过客户端的ServiceConnection的onServiceConnected返回给客户端\nAIDL通信图解 总结 IBinder通信过程跨进程6次\n 客户端通过ServiceManager获取AMS的IBinder对象，因为AMS不和客户端App一个进程，所以需要跨进程获取。 客户端通过AMS获取服务端IBinder对象中间经过两次 服务端通过ServiceManager获取AMS的IBinder对象，因为AMS不和服务端App一个进程，所以需要跨进程获取。 服务端通过AMS返回IBinder对象给客户端中间经过两次  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E6%B7%BB%E5%8A%A0pdf%E5%8A%9F%E8%83%BD/",
	"title": "Android-添加pdf功能",
	"tags": ["android", "pdf"],
	"categories": [],
	"series": ["android"],
	"description": "Android-添加pdf功能",
	"content": "Android SDK自带PdfDocument，详见参考PdfDocument 功能相对简单\niText 适用java\niTextG iText的Android版本，iText几乎相同。去除了java.awt, javax.nio及其他在Android中被禁用的Java包的类\nMuPDF MuPDF是一个轻量级的PDF、XPS和电子书阅读器\nPdfium Google公司在经过与福昕软件的合作之后，与其达成协议，将对福昕软件的PDF源代码(主要是阅读器部分)进行开源的项目，详见参考Google开源福昕软件PDF源代码 项目名称PDFium及福昕软件官网。\n以上介绍可见MuPDF及Pdfium主要是用来查看PDF，iText则主要是制作PDF，但实际上MuPDF也是可以可以制作PDF的。\n参考：\nPdfDocument\nInstalling iText G for Android\nMuPDF Android SDK\nGoogle开源福昕软件PDF源代码 项目名称PDFium\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "Android-热更新",
	"tags": ["android", "插件化", "热更新"],
	"categories": [],
	"series": ["插件化", "热更新"],
	"description": "Syntax highlighting test",
	"content": "热修复方案介绍 AndFix Native层函数指针替换，即时生效\nQQ控件超级补丁 类加载/multidex，重启生效\nRobust 字节码插桩/Instant Run 即时生效\nTinker 类加载，重启生效\nSophix 号称目前最优秀的热修复方案。融合Native层函数指针替换和类加载两种技术\n由于官方不支持插件化和热更新（理由是安全问题）导致原生插件化和热更新只能另辟蹊径\n热更新分两种，一种是重启生效，一种是即时生效\n即时生效的原理是：这个过程相当复杂不易控制\n这里主要讲喜爱重启生效热更新模式的原理：\nClassLoader,java的ClassLoader双亲委托机制\n干预Android加载，既然要干预那就要首先了解其原加载过程\n双亲委托 简单说类加载器的双亲委托就是在当前类加载器加载某个类之前先逐级向上询问父类加载器是否已加载过(是否已有类的缓存)，如果已加载就返回，如果未加载则有当前类加载器加载该类。你可能会问ClassLoader本身也是一个类，它是怎么被加载的呢？在jvm启动的时候就有一个根ClassLoader,即：bootstrapclassloader\n设计双亲委托模式的好处：\n1.避免重复加载 2.安全，避免核心api被修改\nAndroid ClassLoader  BootClassLoader\n加载Framwork/SDK类的ClassLoader PathClassLoader\n加载第三方库包括AndroidX支持库的ClassLoader DexClassLoader\n这个应该原本是谷歌留给开发者使用的ClassLoader，与PathClassLoader基本没区别。  类的生命周期 加载 -\u0026gt; 验证 -\u0026gt; 准备 -\u0026gt; 解析 -\u0026gt; 初始化 -\u0026gt; 使用 -\u0026gt; 卸载\n其中 验证 -\u0026gt; 准备 -\u0026gt; 解析 又叫连接，即：加载 -\u0026gt; 连接 -\u0026gt; 初始化 -\u0026gt; 使用 -\u0026gt; 卸载\n加载阶段虚拟机主要做三件事：\n 通过一个类的全限定名获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区域的运行时数据结构 在Java堆中生成一个代表这个类的Class对象，作为方法区域数据的问入口  PathClassLoader和DexClassLoader源码分析 要做热更新就要用ClassLoader加载hotfix dex中的类,用哪个ClassLoader呢？我们在Activity中打印classLoader::class.java.name可以看到是dalvik.system.PathClassLoader\n查看PathClassLoader\n1 2 3 4 5 6  public PathClassLoader(String dexPath, ClassLoader parent) { super(dexPath, null, null, parent); } public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) { super(dexPath, null, librarySearchPath, parent); }   只有几个构造方法，但PathClassLoader继承自BaseDexClassLoader，继续进入BaseDexClassLoader查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // 首先检查是否已经加载过  Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //parent.loadClass可鞥在此抛出异常  } if (c == null) { c = findClass(name); } } return c; }   loadClass首先检查是不是已加载过这个类，若没有，调用父ClassLoader的loadClass，以此上推检查父ClassLoader是否加载过此类，若都没有加载则调用findClass\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { // First, check whether the class is present in our shared libraries.  if (sharedLibraryLoaders != null) { for (ClassLoader loader : sharedLibraryLoaders) { try { return loader.loadClass(name); } catch (ClassNotFoundException ignored) { } } } // Check whether the class in question is present in the dexPath that  // this classloader operates on.  List\u0026lt;Throwable\u0026gt; suppressedExceptions = new ArrayList\u0026lt;Throwable\u0026gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( \u0026#34;Didn\u0026#39;t find class \\\u0026#34;\u0026#34; + name + \u0026#34;\\\u0026#34; on path: \u0026#34; + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; }   最终执行到Class c = pathList.findClass(name, suppressedExceptions);，再继续查看DexPathList的findClass方法\n1 2 3 4 5 6 7 8 9 10 11 12 13  public Class\u0026lt;?\u0026gt; findClass(String name, List\u0026lt;Throwable\u0026gt; suppressed) { for (Element element : dexElements) { Class\u0026lt;?\u0026gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; }   再继续进入Element的findClass方法\n1 2 3  public Class\u0026lt;?\u0026gt; findClass(String name, ClassLoader definingContext,List\u0026lt;Throwable\u0026gt; suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed): null; }   我们只需要获取热更新补丁的dexElements与原dexElements合并，app再次重新启动就会完成修复\n使用d8编译热修复补丁   将java/kotlin文件编译成class文件\n  javac path/to/HotfixTest.java\n或\n  kotlinc path/to/HotfixTest.kt\n    d8是dex编译器，是dx的升级版，用于取代dx。路径：sdk/build_tools/buildtToolsVersion(如：28.0.3)/d8\n使用d8将class文件编译成dex\n./path/to/d8 path/to/HotfixTest.class\n  Android N热修复问题 由于Android N以后采用混合编译运行即：AOT编译，解释执行与JIT编译，见参考Android N混合编译与对热补丁影响解析。热点代码会缓存到base.art中，而且这个缓存是没法干预的，在程序启动前我们在Application干预前就已经存在了。如果我们要打补丁的类被优化到了base.art缓存就导致我们插入到dexElements并不会起作用，因为会优先从base.art查找。为此我们需要使用自定义的ClassLoader绕过。自定义一个PatchClassLoader并实例一个对象，再实例一个PathClassLoader，并将实例的PatchClassLoader设为PathClassLoader的父类加载器。使用该PathClassLoader替代App原有的PathClassLoader。为什么不直接用自定义的PatchClassLoader呢？看看DexFile类的注释文档你就会明白了。\n另外Android5.0之前Android的一个优化是会将没有直接引用其他dex的类打上CLASS_ISPREVERIFIED标志，如果被打上CLASS_ISPREVERIFIED标志的类不在同一个dex会导致崩溃。这个问题可以从字节码插桩来解决。即将一个空类编译成单独的dex文件，然后利用ASM操作字节码给需要热修复的类的无参构造方法中插入对这个空类的引用。这样所有需要修复的类都引用另外一个dex的类阻止被打上CLASS_ISPREVERIFIED标志。操作字节码可以利用Gradle插件。\n混淆的问题 读取混淆mapping文件将patch.dex中的类也按mapping混淆。\n如何知道哪些文件修改了需要编译进patch.dex呢？可以每次打包记录每个文件的MD5值，如果不相等即有改变就编译进patch.dex\n热修复中四大组件 1.利用代理activity启动插件化中的activity\n2.模仿系统加载启动activity\n总结 插件化在几年前火的一塌糊涂，由插件化延续到后来的热更新，近几年似乎没了当初的狂热\n插件化和热更新的意义在于动态化升级。不同于web只要后台发布用户前端的下次请求页面和逻辑都会改变，Android的UI及逻辑代码在手机上，发布需要经过各大市场，由审核时间，且就算发布到各大市场用户也不一定更新，强制用户更新的结果可能是被用户强制卸载。但是发布新功能/紧急修复bug的需求是巨大的。于是先有了\n 将web那一套搬到移动端的做法，但是web在移动端的性能让其体验很差，虽然出现了很多框架增强了许多，但还是有差距 原生的插件化和热更新 RectNative 热更新  RectNative用脚本语言js控制逻辑，使用c++桥接的形式控制原生控件显示，由于脚本语言不用编译，可以动态发布从而实现热更新\n参考：\nAndroid N混合编译与对热补丁影响解析\n安卓App热补丁动态修复技术介绍\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E9%9F%B3%E8%A7%86%E9%A2%91%E4%B9%8Brtmp/",
	"title": "Android-音视频之RTMP",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "Android-音视频之RTMP",
	"content": "占坑，敬请期待\u0026hellip;\nrtmp是基于TCP的应用层协议\nffmpeg也rtmp实现，但只能rtmp://域名/to/path，不能rtmp://ip:port/to/path\nlibrmtp则都可以\n直播中一般不要B帧，因为B帧解码需要前后关联，且解码时间耗时最长。 \u0026ndash;\u0026gt;\nAVPixelFormat\nAVOutputFormat\nAVInputFormat\nAVFilterContext\nAVFilter\nAVFilterGraph\nAVFilterFormats\nAVFilterInOut\nAVFormatContext\nAVIOContext\nAVCodecContext\nAVCodec\nAVCodecParameters\navformat_open_input 获取输入文件/网络的AVFormatContext\n根据AVFormatContext的AVCodecParameters参数获取AVCodec和AVCodecContext\navcodec_open2打开解码器\n循环\nav_read_frame 获取读取数据，使用avpacket接收数据\nav_packet_unref 释放\n放入packet队列\n循环从packet队列取数据\navcodec_send_packet 拿一个packet去解码\navcodec_receive_frame 接收解码后的frame放入frame队列\nANativeWindow不能直接显示YUV数据，需要转换\nAVStream\nAVPacket\nAVFrame\nAVBuffer\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%B8%80/",
	"title": "Android-音视频基础知识(一)",
	"tags": ["音视频", "android"],
	"categories": [],
	"series": ["音视频"],
	"description": "Android-音视频基础知识",
	"content": "RGB\u0026amp;YUV  RGB 红色(R)、绿色(G)、蓝色(B)三原色编码颜色。一般显示器上采用的标准。其中每个原色用一个字节(8bit)表示，一个像素点占用3字节(24bit)。 YUV YUV是一种颜色编码方式明亮度(Y)(Luminance/Luma)、色度(UV)(Chrominance/Chroma)，色度又包含色调、饱和度。YUV的出现是为了兼容黑白电视和彩色电视的显示，早期的黑白电视只有明亮度(Y)，出现彩色电视后为了兼容黑白电视和彩色电视发明了YUV颜色编码。YUV最大的优点就是占用极少宽带。  YUV\u0026amp;YCbCr YCbCr是YUV表示色彩信号的一种方式，Y是明亮度信息，Cb是蓝色偏移量，Cr是红色偏移量。一般我们将的YUV大多就是指YCbCr。\nYUV与RGB的转换 Y = 0.299 * R + 0.587 * G + 0.114 * B U = -0.147 * R - 0.289 * G + 0.436 * B V = 0.615 * R - 0.515 * G - 0.100 * B R = Y + 1.14 * V G = Y - 0.39 * U - 0.58 * V B = Y + 2.03 * U YUV的采样   YUV4:4:4\n其中YUV444P的码流及映射\n采样的码流：Y0 Y1 Y2 Y3 U0 U1 U2 U3 V0 V1 V2 V3 映射出的像素点 [Y0 U0 V0]、[Y1 U1 V1]、[Y2 U2 V2]、[Y3 U3 V3] 可以看出该采样方式和RGB编码大小一样的，并没有达到节省宽带的目的。\n  YUV4:2:2\n其中I422的码流及映射\n采样的码流：Y0 Y1 Y2 Y3 U0 U1 V0 V1 映射出的像素点 [Y0 U0 V0]、[Y1 U0 V0]、[Y2 U1 V1]、[Y3 U1 V1] 可以看出该采样方式相比RGB编码节省了三分之一宽带。\n  YUV4:2:0\n  其中NV21的码流及映射\n采样的码流：Y0 Y1 Y2 Y3 Y4 Y5 Y6 Y7 V0 U0 V1 U1 映射出的像素点 [Y0 U0 V0]、[Y1 U0 V0]、[Y2 U0 V0]、[Y3 U0 V0]、[Y4 U1 V1]、[Y5 U1 V1]、[Y6 U1 V1]、[Y7 U1 V1] 可以看出该采样方式相比RGB编码节省了二分之一宽带。\n  YUV存储方式  planar 平面模式 先存储Y分量，再分别存储U、V分量。 packed 打包模式 Y、U、V分量连续交替存储。     类型 格式 码流 存储     YUV444P YUV444P YYYYUUUUVVVV planar   YUV422P I422 YYYYUUVV planar   YUV422 YUYV YUYVYUYV packed   YUV422 UYVY UYVYUYVY packed   YUV420P YU12(I420) YYYYYYYYUUVV planar   YUV420P YV12 YYYYYYYYVVUU planar   YUV420SP NV12 YYYYYYYYUVUV packed   YUV420SP NV21 YYYYYYYYVUVU packed    其中NV12是IOS摄像头采集数据默认格式\nNV21是Android摄像头采集数据默认格式\n封装格式 封装格式也叫容器，将已经编码压缩好的音频轨和视频轨按一定的格式放到一个文件中，封装格式仅是一个外壳\n   文件格式 封装格式     .avi AVI(Audio Video Interleaved)   .wmv .asf WMV(Windows Media Video)   .mpg .mpeg .vob .dat .3gp.mp4 MPEG(Moving Picture Experts Group)   .mkv Matroska   .rm .rmvb Real Video   .mov QuickTime File Format   .flv Flash Video    视频编码 视频编码是将视频像素数据(RGB/YUV等)压缩成视频码流从而降低视频数据量\n   名称 推出机构 推出时间 目前使用领域     HEVC(H265) MPEG/ITU-T 2013 研发中   H264 MPEG/ITU-T 2003 各个领域   MPEG4 MPEG 2001 不温不火   MPEG2 MPEG 1994 数字电视   VP9 Google 2013 研发中   VP8 Google 2008 不普及   VC-1 Microsoft Inc. 2006 微软平台    其中研发中并不代表还没有使用，比如H265因其压缩比高，还原度高，在部分领域(电影行业)已经开始使用\n音频编码 音频编码是将音频采样数据(PCM等)压缩成音频码流从而降低音频的数据量\n   名称 推出机构 推出时间 目前使用领域     AAC MPEG 1997 各个领域(新)   MP3 MPEG 1993 各个领域(旧)   WMV Microsoft Inc. 1999 微软平台   VC-3 Dolby Inc. 1992 电影    AAC相比MP3有更高的压缩比，同样大小的音频文件AAC质量更高\n音视频常见名词  dts(decoding timestamp) 解码时间戳，即一帧数据解码的时间 pts(presentation timestamp) 显示时间戳，即一帧数据显示/播放的时间 tb(timebase) 时间基，即时间单位。在FFmpeg中，很多时间并不是以自然时间为单位的。 tbr(timebase of rate) 帧率时间基 tbn(timebase of stream) 流时间基 tbc(timebase of codec) 解码时间基 帧率(fps) 单位kb/s(kbps) 码率(bitrate) 采样率 I帧 P帧 B帧 MB(macroblock) 巨图块，H.264/AVC的视讯编码机制是以图块(block-based)为基础单元，H264在编码时会将图像分割成许多矩形的小区域，称之为巨图块(macroblock，MB) NAL(Network Abstract Layer) 网络抽象层 NALU(Network Abstract Layer Units) 网络抽象层单元，一个NALU存储了一帧画面压缩编码后的数据。 VCL(Video Codec Layer) 视频编码层 SPS 序列参数集，profile、level、宽高及颜色空间等信息，SPS只在关键帧时出现 PPS 图像参数集，通常情况下PPS类似于SPS，PPS在任何一帧的头部出现 GOP(group of pictures) IDR(instantaneous decoding refresh) 即时解码刷新，IDR一定是I帧，但I帧不一定是IDR SODB(String Of Data Bits) 数据比特串，最原始编码数据，长度不一定是8的倍数，所以需要加补齐，即加RBSP尾部(RBSP trailing bit) RBSP(Raw Byte Sequence Payload) 原始字节序列载荷 EBSP(Encapsulated Byte Sequence Payload) 扩展字节序列载荷。H264文档并没有EBSP这一名词，但官方的JM使用了EBSP。EBSP的出现主要是是防止竞争，RBSP经过防竞争变换后成为EBSP。所以理论上：NALU = NALU Header + RBSP，实际上：NALU = NALU Header + EBSP。EBSP相较于RBSP，多了防止竞争的一个字节：0x03 SEI(Supplemental Enhancement Information) 补充增强信息，SEI可以存放影片简介、版权宣告、用户自行定义的数据等  编码及传输 JM H.264 视频编解码标准是由 ITU-T 的VCEG(视频编码专家组)和ISO/IEC 的MPEG(活动图像编码专家组)的联合视频组JVT开发的。JM是JVT发布的用C语言编写而成的源代码公开的H.264编解码软件，通常作为算法研究和实际应用的平台。简单说就是官方发布的H.264编解码范本。JM8.6是JM 的一个版本，JM8.6(下文简称JM)没有引进最新的一些运动搜索以及快速模式选择算法。但研究它的工作方式和程序结构对H.264算法研究和在JM 基础上的代码剪裁仍然很有意义。\n视频编码及传输 SODB + RBSP trailing bits = RBSP NAL header(1 byte) + RBSP = NALU Start Code Prefix(3 bytes) + NALU + Start Code Prefix(3 bytes) + NALU + ... + = H.264BitsStream 视频压缩的原理是利用影像在时间与空间上存有相似性。\nH.264/AVC的视讯编码机制是以图块(block-based)为基础单元，也就是说先将整张影像分割成许多矩形的小区域，称之为宏块(macroblock，MB)，再将这些巨图块进行编码，先使用画面内预测(intra-prediction)与画面间预测(inter-prediction)技术，以去除影像之间的相似性来得到所谓的差余影像(residual)，再将差余影像施以空间转换(transform)与量化(quantize)来去除视觉冗余，最后视讯编码层会输出编码过的比特流(bitstream)，之后再包装成网络提取层的单元封包(NAL-unit)，经由网络传送到远程或储存在储存媒体中。\n当NALU的NAL header中NAL unit type是1，2，3，4，5时NALU主体RBSP即是Slice，见下面图表NAL unit type\nSlice = Slice header + Slice data\nSlice data = MB + MB + \u0026hellip; + MB\nMB= mb_type(红块类型) + mb_pred(宏块预测数据) + coded_residual(残差数据)\nH.264/AVC的阶层架构由小到大依序是sub-block、block、macroblock、slice、slicegroup、frame/field-picture、sequence。\n对一个采用4:2:0取样的MB而言，它是由16x16点的Luma与相对应的2个8x8点Chroma来组成，而在H.264/AVC的规范中，MB可再分割成多个16x8、8x16、8x8、8x4、4x8、4x4格式的sub-blocks。\nslice时多个macroblock的集合，slice为H.264/AVC格式中的最小可译码单位(self-decodable unit)，也就是说一个slice单靠本身的压缩数据就能译码，而不必依靠其他slice\n一张图像由多个slice组成，\n  起始码\n一系列的起始码+NALU组成一个H264码流。H264码流中的起始码是固定的0x000001或0x00000001。如果NALU对应的Slice为一帧的开始则用4字节(0x00000001)表示，否则用3字节(0x000001)表示。那如果NALU内部出现0x000001或0x00000001怎么办？为了防止这种情况H264提出了防止竞争(emulation prevention)机制。在编码NALU时如果检测到连续两个0x00则插入一个0x03。当解码器在NALU检测到0x000003的数据时就把0x03抛弃，恢复原始数据。\n  编码及传输\n我们平时的每帧数据就是一个NAL单元（SPS与PPS除外）\n一般来说编码器编出的首帧数据是PPS于SPS\n  H264的码流的打包方式有两种,一种为annex-b byte stream format 的格式，这个是绝大部分编码器的默认输出格式，就是每个帧的开头的3~4个字节是H264的起始码(0x000001或0x00000001)。\n另一种是原始的NAL打包格式，就是开始的若干字节（1，2，4字节）是NAL的长度，而不是起始码,此时必须借助某个全局的数据来获得编 码器的profile,level,PPS,SPS等信息才可以解码。\nH264的功能分为两层\n VCL 视频编码层，负责有效表示视频数据的内容 NAL 网络抽象层，负责格式化数据并提供头信息，以保证数据适合各种信道和存储介质上的传输\nVCL数据是数据编码压缩后的视频序列，在VCL数据传输和存储之前这些编码的VCL数据再映射封装到NAL单元(NALU)中。每个NALU由一个NALU头信息和一个RBSP组成。\nNALU头信息占一个字节，其中高位开始第：\n1bit是禁止位F(forbidden_zero_bit)，必须是0，如果是1表示语法出错。\n2～3bit是参考级别NRI(nal_ref_idc)，表示该NALU的重要性\n4～8bit是NALU类型Type(nal_unit_type)，1～12由H264使用，24～31由H264以外的应用使用。  图表NAL unit type\n   NAL unit type NAL类型     0 未定义   1 不分区，非IDR图像的片(非IDR Slice)   2 片分区A(Slice Partition A)   3 片分区B(Slice Partition B)   4 片分区C(Slice Partition C)   5 IDR图像中的片(IDR Slice)   6 SEI(补充增强信息单元)   7 SPS(序列参数集)   8 PPS(图像参数集)   9 分界符   10 序列结束   11 码流结束   12 填充   13~23 保留   24 STAP-A 单一时间的组合包   25 STAP-B 单一时间的组合包   26 MTAP16 多个时间的组合包   27 MTAP24 多个时间的组合包   28 FU-A 分片的单元   29 FU-B 分片的单元   30~31 未定义    Start Code Prefix为3个字节. 但是，为了寻址方便，要求数据流在长度上对齐，因此H264建议在Start Code Prefix前面加若干个0.\n音频编码及传输 H264在网络传输过程中会被编码成一系列的网络数据包\nNAL unit type都要与1F与运算转换，所以NAL unit type=7，在传输中实际传输的时67，67\u0026amp;1F=7\nHVS(人类视觉系统)由眼睛+神经+大脑构成，HVS特点：\n 对高(刷新)频信息不敏感，60Hz以下是低频，60Hz以上是高频。类似于声频，当刷新频率高于60Hz时人类并不能比60Hz感受到更多。 对高对比度更敏感 对亮度信息比色度信息更敏感 对运动的信息更敏感  针对HVS特点，数字视频系统设计考虑：\n 丢弃高频信息只编码低频信息 提高边缘信息的主观质量，即对比度 降低色度的解析度 对感兴趣区域(Region of Interesting,ROI)做特殊处理  分包 音频编码及传输 奈奎斯特采样定理：当采样频率fs.max大于信号中最高频率fmax的2倍时(fs.max\u0026gt;2fmax)，采样之后的数字信号就可以完整地保留原始信号中的信息，一般实际应用中保证采样频率为信号最高频率的2.56～4倍\n 采样频率： 每秒采集声音样本的次数。由于人耳所能听到的声音频率20Hz~20KHz，又由奈奎斯特采样定理可知当采样频率达到频率两倍时即可保留原始声波信号信息。因此采样率应该介于40~40K。一般的采样率有8K,11.025K,16K,22.05K,24K,44.1K,48K,96K，其中44.1K是CD音质，48K是DVD音质\n11.025K是AM调幅广播声音品质，而22.05K和24K是FM调频广播的声音品质 采样位数： 即所能表示声波的幅度。采样位数越大，所能表示的声波幅度越大，音质越好。一般又8bit，16bit，32bit。16bit已达CD音质 声道数：声道可以简单理解为采集/播放音频数据的麦克风/喇叭个数，但也有的处理会将两个喇叭输出同一声道的声音。有单声道/双声道/多声道，双声道是立体声，三声道是环绕立体声。 比特率：每秒传输的声音数据量。比特率=采样频率x采样位数x声道数 周期：音频设备一次处理所需的帧数，对于音频设备的访问和音频数据的存储都是以此为单位 交错模式：音频信号数据以连续帧的方式存储，即存储帧1的左、右声道样本，再存储帧2的左、右声道样本 非交错模式：先存储一个周期内所有帧的左声道样本再存储一个周期内所有帧的右声道样本。  AAC编码 ADTS Pkt + \u0026hellip; + ADTS Pkt = AACBitsStream\ndata[0], bytes, size); //Y for (j = 0; j data[2] + j) = *(bytes + size + j * 2); // V *(avFrame-data[1] + j) = *(bytes + size + j * 2 + 1); //U } FFMPEG 方法一： //1.根据格式获取缓存大小 int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align); //2.根据计算的缓存大小申请空间 int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4],const uint8_t *src,enum AVPixelFormat pix_fmt, int width, int height, int align); 方法二： //根据格式申请缓存空间 int av_image_alloc(uint8_t *pointers[4], int linesizes[4],int w, int h, enum AVPixelFormat pix_fmt, int align); 方法二相当于方法一的两步 av_init_packet 将已经存在的packet初始化为默认值 av_packet_alloc 为packet分配内存并初始化为默认值 av_new_packet 按制定大小为packet分配内存并初始化为默认值 max_b_frames 两个非B帧之间最大B帧数 frame-best_effort_timestamp ffmpeg获取可以从AVPacket和AVFrame中获取pts，一般两者一致，但有时候AVFrame没有pts或者是0/-1，这时候可以利用ffmpeg的方法 av_frame_get_best_effort_timestamp推断出一个合适的pts时间戳，在ffmpeg已经不需要调用这个方法可以直接frame-best_effort_timestamp 访问pts时间戳，即判断AVFrame pts异常时，可以用AVFrame-best_effort_timestamp代替 av_q2d转换成时间 PTS=PTS*av_q2d(video_stream-time_base) int avformat_alloc_output_context2(AVFormatContext **ctx, AVOutputFormat *oformat,const char *format_name, const char *filename); 作用在于当我们需要将编码后的数据写入文件的时候用该方法，并配合 int avio_open(AVIOContext **s, const char *url, int flags); AVStream *avformat_new_stream(AVFormatContext *s, const AVCodec *c); int avformat_write_header(AVFormatContext *s, AVDictionary **options); int av_write_trailer(AVFormatContext *s); 让FFmpeg帮我们写文件，这样不用我们自己处理文件头文件尾格式问题 openGL: Shader(着色器) 在GPU上运行的小程序 android.hardware.Camera private String cameraFormatForPixelFormat(int pixel_format) { switch(pixel_format) { case ImageFormat.NV16: return PIXEL_FORMAT_YUV422SP; case ImageFormat.NV21: return PIXEL_FORMAT_YUV420SP; case ImageFormat.YUY2: return PIXEL_FORMAT_YUV422I; case ImageFormat.YV12: return PIXEL_FORMAT_YUV420P; case ImageFormat.RGB_565: return PIXEL_FORMAT_RGB565; case ImageFormat.JPEG: return PIXEL_FORMAT_JPEG; default: return null; } } https://blog.csdn.net/gb702250823/article/details/81627503 MediaCodec的基本调用流程是： createEncoderByType/createDecoderByType configure start while(true) { dequeueInputBuffer //从输入流队列中取数据进行编码操作 getInputBuffers //获取需要编码数据的输入流队列，返回的是一个ByteBuffer数组 queueInputBuffer //输入流入队列 dequeueOutputBuffer //从输出队列中取出编码操作之后的数据 getOutPutBuffers // 获取编解码之后的数据输出流队列，返回的是一个ByteBuffer数组 releaseOutputBuffer //处理完成，释放ByteBuffer数据 } stop release 相机拍摄预览文字有明显的闪烁纹，发现是设置了不支持的预览尺寸 opengl 像素缓冲区的作用：任何从 PBO 的读取或写入 PBO 的操作或任何缓冲区对象都用管线进行处理，这意味着 GPU 不需要完成所有其他操作，提高效率 缓冲区对象在处理需要经常访问、修改或更新数据的场合中具有重大优势，比如异步调用 glReadPixels。 将像素数据读取到 CPU 内存中需要 GPU 先完成正在进行的其它所有工作， 如果 GPU 忙于渲染 3D 图形，这将影响图形渲染的效率。这时候可以使用 PBO，因为读取操作是通过管线进行的， 所有对 glReadPixels 的调用能够立即返回。甚至可以多次调用， 使用不同的缓冲区对象来读取不同的区域。 如果不使用PBO而直接使用glReadPixels将是同步的，可能需要等待很久时间 利用GPU管线的好处是：不需要等待GPU工作完成（比如：GPU正在渲染3D模型） camera.addCallbackBuffer(data);//复用分配的数组空间，提高效率，如果不设置的话每一帧会重新分配内存 如果glReadPixels效率有问题可以用PBO AVPicture 存放yuv数据 av_free\u0026av_freep 1.从概念上说，都是释放指针所指的那块内存， 但是av_freep还多个功能，就是把当前指针置为NULL。 2.从使用上说，也是有区别的，举例说明如下： uint8_t *buf = av_malloc(16); av_free(buf); uint8_t *buf = av_malloc(16); av_freep(\u0026buf); AVPacket：存储压缩数据（视频对应H.264等码流数据，音频对应AAC/MP3等码流数据） AVFrame：存储非压缩的数据（视频对应RGB/YUV像素数据，音频对应PCM采样数据） memset是以字节为单位，初始化内存块 视频或音频数据存储的2种格式packed和planar: 假设有一路音频流，有左右两声道的数据。左声道用L表示，右声道用R表示。 存储时，如果是左右声道数据交替存储成一维数组，这种格式称为packed。格式为LRLRLR....LRLR 如果是分开存储成二维数组，这种格式称为planar。格式为LLLLLLLLLLLLLL和RRRRRRRRRRRRR 视频也是如此，但是对于YUV格式的数据，比音频多一种存储方法叫semi-planar，也就是半planar。一共2路存储，Y一路，UV一路，其中UV交叉存储。 c++声明即分配空间 一些常用的Signal ： https://blog.csdn.net/yockie/article/details/51729774 注意：如果是多线程程序，signal(SIGINT, sig_handler) 需要写在想要终止的那个线程里，只写在 main 函数不行。 ALSA是Advanced Linux Sound Architecture，高级Linux声音架构的简称,它在Linux操作系统上提供了音频和MIDI（Musical Instrument Digital Interface，音乐设备数字化接口）的支持。在2.6系列内核中，ALSA已经成为默认的声音子系统，用来替换2.4系列内核中的OSS（Open Sound System，开放声音系统）。 [1] ALSA的主要特性包括：高效地支持从消费类入门级声卡到专业级音频设备所有类型的音频接口，完全模块化的设计， 支持对称多处理（SMP）和线程安全，对OSS的向后兼容，以及提供了用户空间的alsa-lib库来简化应用程序的开发。 -- 参考：\n 一文读懂 YUV 的采样与格式 音视频开发的一系列科普教程  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-activityfragment/",
	"title": "Android四大组件-Activity/Fragment",
	"tags": ["四大组件", "android"],
	"categories": [],
	"series": ["四大组件"],
	"description": "Android四大组件-Activity/Fragment使用",
	"content": "Activity 生命周期  当用户打开新的Activity的时候或者切换到桌面的时候回调onPause-onStop，但是如果此Activity是透明主题，那么Activity不会回调onStop 当系统内存不足时可能会跳过onStop()直接onDestory，即不会回调onStop() 当Activity因异常终止时会回调onSaveInstanceState，被再次重建时会回调onRestoreInstanceState。但正常终止则不会调用这两个方法  当一个Activity进入/返回另一个Activity时总是先执行自己的onPause，再执行另一个Activity的相关生命周期，所以onPause中不能做耗时操作否则会影响另一个Activity的尽快显示。相应的当一个Activity进入/返回另一个Activity时若当前Activity执行到onStop时表示另一个Activity页面肯定是已展示的，所以onStop是可以做一些耗时操作的。Android为什么这么设计？从用户角度想肯定是想尽量先让新的页面展示自己再关闭当前页面。以上，通常在Splash页面可以在onStop中调用finish结束自己。\n生命周期实践(Android8.0)   当一个Activity(App Launcher Activity)启动另一个嵌套Fragment的Activity时生命周期调用过程：\nonCreate(Activity A)-\u0026gt;onStart(Activity A)-\u0026gt;onResume(Activity A)-\u0026gt;onPause(Activity A)-\u0026gt;onAttach(Activity B Fragment)-\u0026gt;onCreate(Activity B Fragment)-\u0026gt;onCreate(Activity B)-\u0026gt;onCreateView(Activity B Fragment)-\u0026gt;onActivityCreated(Activity B Fragment)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)-\u0026gt;onAttachedToWindow(Activity B)-\u0026gt;onSaveInstanceState(Activity A)-\u0026gt;onStop(Activity A)\n  (2.1)此时旋转屏幕，若Activity B Fragment retainInstance=false且Activity未配置android:configChanges=\u0026quot;orientation|screenSize\u0026rdquo;\nonPause(Activity B Fragment)-\u0026gt;onPause(Activity B)-\u0026gt;onSaveInstanceState(Activity B)-\u0026gt;onStop(Activity B)-\u0026gt;onDestroyView(Activity B Fragment)-\u0026gt;onDestroy(Activity B Fragment)-\u0026gt;onDetach(Activity B Fragment)-\u0026gt;onDestroy(Activity B)-\u0026gt;onDetachedFromWindow(Activity B)\nonAttach(Activity B Fragment)-\u0026gt;onCreate(Activity B Fragment)-\u0026gt;onCreate(Activity B)-\u0026gt;onCreateView(Activity B Fragment)-\u0026gt;onActivityCreated(Activity B Fragment)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onRestoreInstanceState(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)-\u0026gt;onAttachedToWindow(Activity B)\n(2.2)此时旋转屏幕，若Activity B Fragment retainInstance=true且Activity未配置android:configChanges=\u0026quot;orientation|screenSize\u0026rdquo;\nonPause(Activity B Fragment)-\u0026gt;onPause(Activity B)-\u0026gt;onSaveInstanceState(Activity B)-\u0026gt;onStop(Activity B)-\u0026gt;onDestroyView(Activity B Fragment)-\u0026gt;onDetach(Activity B Fragment)-\u0026gt;onDestroy(Activity B)-\u0026gt;onDetachedFromWindow(Activity B)\nonAttach(Activity B Fragment)-\u0026gt;onCreate(Activity B)-\u0026gt;onCreateView(Activity B Fragment)-\u0026gt;onActivityCreated(Activity B Fragment)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onRestoreInstanceState(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)-\u0026gt;onAttachedToWindow(Activity B)\n(2.3)此时旋转屏幕，若Activity配置android:configChanges=\u0026quot;orientation|screenSize\u0026rdquo;，无论Activity B Fragment retainInstance=true/false\nonConfigurationChanged(Activity B Fragment)-\u0026gt;onConfigurationChanged(Activity B)\n(2.4)此时息屏或Home键回到后台后：\nonPause(Activity B Fragment)-\u0026gt;onPause(Activity B)-\u0026gt;onSaveInstanceState(Activity B)-\u0026gt;onStop(Activity B)\n  (1)在息屏的情况下重新点亮屏幕或者：\n(2)在在后台的情况下点击任务键再点击相应App回到前台：\nonRestart(Activity B)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)\n(3)在后台的情况下点击图标回到前台：\nonDestroyView(Activity B Fragment)-\u0026gt;onDestroy(Activity B Fragment)-\u0026gt;onDetach(Activity B Fragment)-\u0026gt;onDestroy(Activity B)-\u0026gt;onDetachedFromWindow(Activity B)-\u0026gt;onNewIntent(Activity A)-\u0026gt;onRestart(Activity A)-\u0026gt;onStart(Activity A)-\u0026gt;onResume(Activity A)\n(4)如果在1这一步Activity A(App Launcher Activity)跳转到Activity B后finish掉Activity A，那么此时在后台的情况下点击图标回到前台：\nonCreate(Activity A)-\u0026gt;onStart(Activity A)-\u0026gt;onResume(Activity A)-\u0026gt;onPause(Activity A)-\u0026gt;onAttach(Activity B Fragment)-\u0026gt;onCreate(Activity B Fragment)-\u0026gt;onCreate(Activity B)-\u0026gt;onCreateView(Activity B Fragment)-\u0026gt;onActivityCreated(Activity B Fragment)-\u0026gt;onStart(Activity B Fragment)-\u0026gt;onStart(Activity B)-\u0026gt;onResume(Activity B)-\u0026gt;onResume(Activity B Fragment)-\u0026gt;onResumeFragments(Activity B)-\u0026gt;onAttachedToWindow(Activity B)-\u0026gt;onSaveInstanceState(Activity A)-\u0026gt;onStop(Activity A)-\u0026gt;onDestroy(Activity A)\n  总结：\n 未配置android:configChanges=\u0026quot;orientation|screenSize\u0026quot;\n旋转屏幕会重走生命周期但不会走onConfigurationChanged，另外无论竖屏转横屏或者横屏转竖屏并未出现走两次生命周期的情况(8.0)，如果Activity中有Fragment，如果Fragment的retainInstance=false也会因重建而走整个生命周期，但如果设置了retainInstance=true，则Fragment不会销毁但会销毁所包含视图，因此其不会走Fragment的onDestroy和onCreate生命周期，但其他各个声明周期还都会重走。 配置android:configChanges=\u0026quot;orientation|screenSize\u0026quot;\n此时Activity不会销毁重新创建，Activity内的Fragment也不会销毁重新创建，因此此时只会回调onConfigurationChanged。 android:configChanges的配置\n需要注意的是单独配置android:configChanges=\u0026quot;orientation\u0026quot;或android:configChanges=\u0026quot;screenSize\u0026quot;都是不生效的，需要同时配置android:configChanges=\u0026quot;orientation|screenSize\u0026quot; 后台回到前台的问题\n由3(3)可知Activity B在回到前台时被回收并弹出Activity栈，只保留了App Launcher Activity。由3(4)可知如果跳转到Activity B时结束了Launcher Activity，点击图标回到前台时Activity B的onDestroy甚至没有回调而是直接重启了App。 以上部分在各个手机可能有不同表现，仅供参考。  onNewIntent回调的时机 当startActivity启动的是同一Activity实例intent发生变化都会走onNewIntent，当Activity的启动模式是stand时调用startActivity启动每次都会重新创建，所以该模式下不会走onNewIntent，其他启动模式都有可能。\n非stand模式下：\nstartActivity A-\u0026gt;startActivity B-\u0026gt;startActivity A\nActivity A的生命周期：onNewIntent-\u0026gt;onRestart-\u0026gt;onStart-\u0026gt;onResume\nstartActivity A-\u0026gt;startActivity A\nActivity A的生命周期：onPause-\u0026gt;onNewIntent-\u0026gt;onResume\ngetLastNonConfigurationInstance onRetainNonConfigurationInstance\nonRetainCustomNonConfigurationInstance\n可以在onRetainCustomNonConfigurationInstance中存储非配置信息(和Activity生命周期状态无关的信息)，然后使用getLastNonConfigurationInstance获取存储的信息。已经废弃，官方推荐使用ViewModel存储非配置信息\n这个方法最大的好处是：\n 当activity曾经通过某个网络资源得到一些图片或者视频信息，那么当再次恢复后，无需重新通过原始资源地址获取，可以快速的加载整个activity状态信息。 当activity包含有许多线程时，在变化后依然可以持有原有线程，无需通过重新创建进程恢复原有状态。 当activity包含某些connection instance时，同样可以在整个变化过程中保持连接状态。  横竖屏切换 见生命周期实践的第二部分。\n显式Intent和隐式Intent 隐式跳转有两种方式：\n 设置action 设置data  Activity窗口构成 Activity、PhoneWindow、DecorView、ViewRootImpl、WindowManagerImpl、WindowManagerGlobal、ActivityThread和Surface\n见参考Android Render(一)Activity窗口构成和绘制解析\nAPI解析   overridePendingTransition(int enterAnim, int exitAnim)\n在startActivity或finish时调用执行的转换动画\n   getCallingActivity()\n获取使用startActivityForResult启动当前Activity的Activity，即setResult()中的数据将发送到的Activity。\n  getCallingPackage()\n参见getCallingActivity()\n  onConfigurationChanged(Configuration)\nActivity配置configChanges时，当旋转屏幕等状态信息变化时回调\n  getChangingConfigurations()\n当onConfigurationChanged(Configuration)不能回调时可以使用此方法发现一些配置的更改，但不能保证准确性，因为获取的是一个成员变量值，这个值下一秒随时可能被更改。\n  isChangingConfigurations()\n检查是否正在销毁此Activity，以便用新配置重新创建。通常在onStop中使用，以确定状态是需要清理还是将通过onRetainNonConfigurationInstance()传递给Activity的重新创建的实例。\n  onPostCreate(@Nullable Bundle savedInstanceState)\nonStart()和onRestoreInstanceState()之后，onResume()之前调用。应用程序通常不会实现这个方法；它是为了让系统类在应用程序代码运行后进行最终初始化。\n  onCreateNavigateUpTaskStack(TaskStackBuilder builder)\n使用Navigation导航时回调\n  onPrepareNavigateUpTaskStack(TaskStackBuilder builder)\n  onNavigateUp()\n  onNavigateUpFromChild(Activity child)\n  startLocalVoiceInteraction(Bundle privateOptions)\n  onLocalVoiceInteractionStarted()\n  onLocalVoiceInteractionStopped()\n  getVoiceInteractor()\n  onPerformDirectAction(String actionId,Bundle arguments, CancellationSignal cancellationSignal,Consumer resultListener)\n  onGetDirectActions(CancellationSignal cancellationSignal,Consumer\u0026lt;List\u0026gt; callback)\n  onMultiWindowModeChanged(boolean isInMultiWindowMode, Configuration newConfig)\nAndroid7.0支持了多窗口模式。当活动从全屏模式更改为多窗口模式或多窗口模式更改为全屏模式时由系统调用\n  onTopResumedActivityChanged(boolean isTopResumedActivity)\n在多窗口和多显示模式下，可以同时恢复多个活动。应该使用此回调而不是onResume()来指示活动可以尝试打开诸如camera之类的独占访问设备。\n  isInPictureInPictureMode()\n是否画中画模式\n  onPictureInPictureModeChanged(boolean isInPictureInPictureMode,Configuration newConfig)\n当前Activity变化到画中画模式或从画中画模式退出时回调\n  onUserInteraction()/onUserLeaveHint()\n用户与界面交互时回调onUserInteraction()，比如每次触摸Activity界面都会回调onUserInteraction()，当用户下拉通知并点击某个通知离开App界面跳转到其他如设置界面时回调onUserLeaveHint()。onUserInteraction回调旨在帮助activities智能地管理状态栏通知；特别是帮助activities确定取消通知的正确时间。详细请见Android-事件分发机制\n  onRetainNonConfigurationInstance/onRetainCustomNonConfigurationInstance\n可以在onRetainCustomNonConfigurationInstance中存储非配置信息(和Activity生命周期状态无关的信息)，然后使用getLastNonConfigurationInstance获取存储的信息。已经废弃，官方推荐使用ViewModel存储非配置信息\n  onEnterAnimationComplete()\n在窗口设置动画期间，活动无法绘制。为了知道何时开始绘制是安全的，他们可以重写此方法，当输入动画完成时将调用此方法。\n  onActivityReenter(int resultCode, Intent data)\nTransition转场动画时重进入的回调，只有当设置Window#FEATURE_ACTIVITY_TRANSITIONS且resultCode不是RESULT_CANCELED才会回调。目的是提前让Activity做一些准备\n  isActivityTransitionRunning()\n当前Activity是否还有Transition动画运行。\n  getContentScene()\n需要设置Window#FEATURE_CONTENT_TRANSITIONS\n  isChild()\n当前Activity是否嵌套在其他Activity中。\n  getCurrentFocus()\n返回当前Activity窗口上的焦点视图\n  isImmersive()/setImmersive(boolean i)\n是否是沉浸式，沉浸式尽快能不被通知打断。\n  startIntentSenderForResult\n和startActivityForResult类似，只是换成了IntentSender描述要启动的Activity\n  startLockTask()/stopLockTask()\n  isTaskRoot()\n是否是栈中的根Activity\n  moveTaskToBack(boolean nonRoot)\n  setShowWhenLocked(boolean showWhenLocked)\nAPI-27提供\n  setVrModeEnabled(boolean enabled, @NonNull ComponentName requestedComponent)\nAPI-24提供\n  onTrimMemory(int level)\n运行时的回调：\nTRIM_MEMORY_RUNNING_MODERATE  表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了\nTRIM_MEMORY_RUNNING_LOW 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能。\nTRIM_MEMORY_RUNNING_CRITICAL 表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了。\n缓存的回调：\nTRIM_MEMORY_UI_HIDDEN\nUI组件全部不可见的时候才会触发，一旦触发了之后就说明用户已经离开了我们的程序\nTRIM_MEMORY_BACKGROUND 表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置，是不太可能被清理掉的。\nTRIM_MEMORY_MODERATE 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置。\nTRIM_MEMORY_COMPLETE 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置。\n  ActivityOptions   makeSceneTransitionAnimation(Activity activity,View sharedElement, String sharedElementName)\n  makeSceneTransitionAnimation(Activity activity,Pair\u0026lt;View, String\u0026gt;... sharedElements)\n  makeCustomAnimation(Context context,int enterResId, int exitResId)\n设置进入退出的转场动画\n  makeScaleUpAnimation(View source,int startX, int startY, int width, int height)\n创建ActivityOptions指定一个动画，在该动画中，新activity从屏幕的一个小的原始区域缩放到其最终完整状态。\n  makeClipRevealAnimation(View source,int startX, int startY, int width, int height)\n创建ActivityOptions指定一个揭露动画，在该动画中，新activity从屏幕的一个小的原始区域缩放到其最终完整状态。\n  makeThumbnailScaleUpAnimation(View source,Bitmap thumbnail, int startX, int startY)\n创建ActivityOptions指定一个动画，动画从指定位置的一个缩略图缩放到新窗口\n  makeTaskLaunchBehind()\n和Intent.FLAG_ACTIVITY_NEW_DOCUMENT一起使用，正在启动的任务将不会显示给用户，而是只能通过“最近者”任务列表使用。此外，新任务将与启动Activity的任务关联。关联的任务在“最近者”任务列表中分组在一起。不支持启动模式是singleInstance和singleTask的Activity。\n  makeBasic()\n创建一个ActivityOptions不包含任何动画。\n  Fragment Fragment的使用  静态使用\nxml中使用fragment标签关联绑定 1 2 3 4  \u0026lt;fragment android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:name=\u0026#34;com.osshare.dsh.ui.HomeFragment\u0026#34; /\u0026gt;   静态使用时fragment不能嵌套，一旦加载不能移除。\n 动态使用\n使用FragmentManager和FragmentTransaction。可以动态添加移除。  Fragment需要空构造方法 FragmentPagerAdapter和FragmentStatePagerAdapter   FragmentPagerAdapter\nFragmentPagerAdapter是一个不带状态的，一般用于少量界面的ViewPager，划过的Fragment会一直保存在内存中不会销毁。\n  FragmentStatePagerAdapter\nFragmentStatePagerAdapter是一个带状态的适用于界面较多的ViewPager，它会保存当前的界面及上一个界面、下一个界面，最多保存三个，其他的会在destroyItem()方法中被销毁，节省内存占用。  ViewPager和Fragment及懒加载 ViewPager和Fragment结合使用时默认会加载前两个Fragment，这样很容易造成网络丢包、阻塞等问题。\nFragment中有一个setUserVisibleHint(boolean isVisibleToUser)方法，可以通过参数isVisibleToUser判断Fragment是否可见，当Fragment可见时再进行懒加载。setUserVisibleHint的调用早于onCreateView，所以setUserVisibleHint中的操作要避险View变量的空指针。\nsetUserVisibleHint的调用时机：\n Fragment创建时调用，参数isVisibleToUser = false Fragment可见时调用，参数isVisibleToUser = true Fragment由可见变为不可见时调用，参数isVisibleToUser = false  最新的Android版本中setUserVisibleHint已被废弃，官方建议使用Lifecycle\n1 2 3 4 5  * @deprecated If you are manually calling this method, use * {@link FragmentTransaction#setMaxLifecycle(Fragment, Lifecycle.State)} instead. If * overriding this method, behavior implemented when passing in \u0026lt;code\u0026gt;true\u0026lt;/code\u0026gt; should be * moved to {@link Fragment#onResume()}, and behavior implemented when passing in * \u0026lt;code\u0026gt;false\u0026lt;/code\u0026gt; should be moved to {@link Fragment#onPause()}.   Fragment中getActivity为null的问题 原因是因为Fragment还未attach到Activity或者又一个耗时的延迟异步任务或Handler消息，当执行完时需要使用Activity，但此时界面已经跳转到其他页面不在这个Activity。\n 尽量不使用Activity而是使用Context 可以在onAttach保存调用Activity activity=getActivity;并保存。但要注意内存泄漏问题。  Fragment重叠 bug场景：\n Activity的onCreate中add fragment，当旋转屏幕时出现重叠。 内存重启导致的重叠（比如：接了个电话，系统内存不足，杀掉了你的activity ）。打开手机上的“开发者选项”中的“不保留活动”选项，模拟内存重启  这是因为fragment有自己的一套恢复，而旋转重走生命周期会再次add fragment 导致重叠。\n解决方案：\n Activity onSaveInstanceState中不自动保存Fragment状态 onCreate中判断 if(savedInstanceState == null){add fragment }  其他问题   transaction.commit()必须在onSaveInstanceState之前调用，否则会报错：Can not perform this action after onSaveInstanceState，因为onSaveInstanceState会在Activity销毁时保存状态数据，如果在onSaveInstanceState之后调用transaction.commit()，Fragment的commit状态数据可能丢失。在Android中当Activity被系统回收(界面已经不存在了)为了下次打开的时候恢复原来的样子，系统为我们保存界面的所有状态，这个时候再去修改界面理论上是肯定不允许的。解决方案：\n 使用transaction.commitAllowingStateLoss()允许丢失状态数据。 在onPostResume、onResumeFragments这两个方法中commit  另外注意不要在子线程调用transaction.commit()，因为在子线程很容易忽视Activity的生命周期而出现bug\n  低版本support库的bug support-v4版本小于24时有很多bug，比如重叠及嵌套时收不到回调等问题，但先26以后，尤其时28版本的support-v4库已经都解决了，所以使用时尽量使用28及以后的版本，最好是切换Jetpack(AndroidX)库。\nFragment API解析   Fragment\n setRetainInstance() 设置setRetainInstance(true)时若Activity重新创建Fragment的实例将不会销毁。因此onCreate(Bundle)/onDestroy()不会回调，但onDetach()(因为这时Fragment会从Activity detached)/onAttach(Activity)/onActivityCreated(Bundle)会回调。setRetainInstance()的意义是某些场景如：当我们加载图片/网络请求后旋转屏幕导致Activity重建不会导致Fragment重建，我们将图片/网络请求数据保存在Fragment不用再次请求 startPostponedEnterTransition()/postponeEnterTransition()\n见Android-转场动画Transition类比Activity setSharedElementEnterTransition(@Nullable Object transition)\n见Android-转场动画Transition类比Activity setAllowEnterTransitionOverlap(boolean allow)\n见Android-转场动画Transition类比Activity    FragmentManager\n executePendingTransactions()    FragmentTransaction\n  addToBackStack()\u0026amp;popBackStack() 当返回时想一步一步回退就需要在添加时调用addToBackStack，添加到回退栈中。如果是嵌套Fragment的回退addToBackStack无法做到先回退嵌套的子Fragment，这时可以重写Activity的onBackPressed自己管理。也可以使用Jetpack的Navigation来管理。\n  replace() 相当于remove()和add()两步操作合并  add()\u0026amp;remove() 添加/移除fragment，remove()需要先判断是否添加，否则可能会报错。\n  hide()\u0026amp;show() 隐藏/显示\n  commit()/commitNow()\n  commitAllowingStateLoss()/commitNowAllowingStateLoss()\n  runOnCommit()\n  setTransition(@Transit int transition)\n指定系统自带的转场动画\n  setCustomAnimations(@AnimatorRes @AnimRes int enter,@AnimatorRes @AnimRes int exit, @AnimatorRes @AnimRes int popEnter, @AnimatorRes @AnimRes int popExit)\n指定自定义的转场动画\n    Fragment-Fragment/Activity-Activity/Fragment-Activity之间的通信  接口 广播 第三方通信框架，如：EventBus RxBus、LiveDataBus  LiveDataBus是官方推荐的方式\n参考：\nAndroid Render(一)Activity窗口构成和绘制解析\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-service/",
	"title": "Android四大组件-Service",
	"tags": ["四大组件", "android"],
	"categories": [],
	"series": ["四大组件"],
	"description": "Android四大组件-Service",
	"content": "前言 Service Service默认运行在主线程，并不运行在单独线程，因此在Service执行耗时操作容易引起ANR。\n只有在内存过低且必须回收系统资源以供拥有用户焦点的 Activity 使用时，Android 系统才会停止服务。如果将服务绑定到拥有用户焦点的 Activity，则它其不太可能会终止；如果将服务声明为在前台运行，则其几乎永远不会终止。如果服务已启动并长时间运行，则系统逐渐降低其在后台任务列表中的位置，而服务被终止的概率也会大幅提升—如果服务是启动服务，则您必须将其设计为能够妥善处理系统执行的重启。如果系统终止服务，则其会在资源可用时立即重启服务，但这还取决于您从 onStartCommand() 返回的值。\n如果服务同时处理多个对 onStartCommand() 的请求，则您不应在处理完一个启动请求之后停止服务，因为您可能已收到新的启动请求（在第一个请求结束时停止服务会终止第二个请求）。为避免此问题，您可以使用 stopSelf(int) 确保服务停止请求始终基于最近的启动请求。换言之，在调用 stopSelf(int) 时，您需传递与停止请求 ID 相对应的启动请求 ID（传递给 onStartCommand() 的 startId）。此外，如果服务在您能够调用 stopSelf(int) 之前收到新启动请求，则 ID 不匹配，服务也不会停止。\nonLowMemory - 当整个系统的内存不足时调用此函数，并且主动运行的进程应该减少它们的内存使用量。虽然调用此函数的确切点没有定义，但通常在所有后台进程都被终止时回调。\nonTrimMemory(level)\nlevel：\n TRIM_MEMORY_COMPLETE 进程接近后台LRU列表的末尾，如果不能很快找到更多内存，当前进程将被终止。 TRIM_MEMORY_MODERATE 进程位于后台LRU列表的中间，当内存进一步不足时当前进程可能会被清理掉。释放内存可以帮助系统保持列表中稍后运行的其他进程，以获得更好的总体性能。 TRIM_MEMORY_BACKGROUND 当前进程已进入LRU列表，当内存进一步不足时当前进程可能会被清理掉。此时应该释放资源保证内存的充足以便当前进程不被杀死继续保留在内存中，这样当用户重新返回当前进程的应用程序，应用程序的资源可以高效、快速地重新构建。而不是等待内存不足导致应用程序进程被杀死清理掉，当用户重新返回当前进程的应用程序需要重新启动。 TRIM_MEMORY_UI_HIDDEN 当前进程的UI已经隐藏不再显示了(比如用户点击了Home/Back键)，此时当前进程应该释放一些资源。 TRIM_MEMORY_RUNNING_CRITICAL 当前进程不是可被回收后台进程，但系统内存已经严重不足，将无法保持任何后台进程的运行，当前进程应该尽可能释放非关键资源以供其他地方使用。接下来会调用onLowMemory来报告后台不能保留任何内容。 TRIM_MEMORY_RUNNING_LOW 当前进程不是可被回收后台进程，但系统内存已经不足，当前进程应该释放不需要的资源以供其他地方使用。 TRIM_MEMORY_RUNNING_MODERATE 当前进程不是可被回收后台进程，但系统内存有些紧张，当前进程可能需要释放一些不需要的资源以供其他地方使用。  Service启动的两种方式startService和bindService startService \u0026ndash; 服务会在后台无限期运行。因此需要自己调用 stopSelf() 或 stopService() 来停止服务。\n 生命周期：onCreate-\u0026gt;onStartCommand-\u0026gt;onDestroy\nonCreate只会首次创建时调用一次，onStartCommand则可能调用多次(每次调用startService都会调用) onStartCommand的返回值 默认START_STICKY 1 2 3 4  public @StartResult int onStartCommand(Intent intent, @StartArgFlags int flags, int startId) { onStart(intent, startId); return mStartCompatibility ? START_STICKY_COMPATIBILITY : START_STICKY; }   START_STICKY \u0026ndash; 如果系统在 onStartCommand() 返回后终止服务，则其会重建服务并调用 onStartCommand()，但不会重新传递最后一个 Intent。相反，除非有挂起 Intent 要启动服务，否则系统会调用包含空 Intent 的 onStartCommand()。在此情况下，系统会传递这些 Intent。此常量适用于不执行命令、但无限期运行并等待作业的媒体播放器（或类似服务）。\nSTART_NOT_STICKY \u0026ndash; 如果系统在 onStartCommand() 返回后终止服务，则除非有待传递的挂起 Intent，否则系统不会重建服务。这是最安全的选项，可以避免在不必要时以及应用能够轻松重启所有未完成的作业时运行服务。\nSTART_REDELIVER_INTENT \u0026ndash; 如果系统在 onStartCommand() 返回后终止服务，则其会重建服务，并通过传递给服务的最后一个 Intent 调用 onStartCommand()。所有挂起 Intent 均依次传递。此常量适用于主动执行应立即恢复的作业（例如下载文件）的服务。\n  bindService \u0026ndash; 如果只是调用bindService启动Service，则Service只在调用bindService的组件的生命周期内运行。组件销毁时Service也会回调onUnbind-\u0026gt;onDestroy销毁。\n 生命周期：onCreate-\u0026gt;onBind/onRebind-\u0026gt;onUnbind-\u0026gt;onDestroy\nonCreate只会首次创建时调用一次，onBind首次调用bindService启动时回调一次，后续的bindService只能回调onRebind bindService(Intent service, ServiceConnection conn,int flags) flag参数：\nBIND_AUTO_CREATE \u0026ndash;\nBIND_DEBUG_UNBIND \u0026ndash;\nBIND_NOT_FOREGROUND \u0026ndash;\nBIND_ABOVE_CLIENT \u0026ndash;\nBIND_ALLOW_OOM_MANAGEMENT \u0026ndash;\nBIND_WAIVE_PRIORITY \u0026ndash;\nBIND_IMPORTANT \u0026ndash;\nBIND_ADJUST_WITH_ACTIVITY \u0026ndash;  如果给Service指定了新的进程，通过bindService启动服务时onServiceConnected(ComponentName name, IBinder service)中的service是BinderProxy，强转成自己定义的Binder会报错：​​​​​​​java.lang.ClassCastException: android.os.BinderProxy cannot be cast ...，此时应该直接使用service.transact传递信息。这种情况最好改用AIDL。\nIntentService  可用于执行后台耗时的任务，任务执行后会自动停止 具有高优先级，适合高优先级的后台任务，且不容易被系统杀死 可以多次启动，每个耗时操作都会以工作队列的方式在IntentService的onHandleIntent回调方法中执行  参考：\nAndroid Render(一)Activity窗口构成和绘制解析\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3/",
	"title": "Android属性动画",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android属性动画",
	"content": "帧动画 xml文件存放在res/drawable下面\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;animation-list xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34; android:oneshot=\u0026#34;true\u0026#34; android:variablePadding=\u0026#34;false\u0026#34; android:visible=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/drawable0\u0026#34; android:duration=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/drawable1\u0026#34; android:duration=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;item android:drawable=\u0026#34;@drawable/drawable2\u0026#34; android:duration=\u0026#34;200\u0026#34; /\u0026gt; \u0026lt;/animation-list\u0026gt;   item是其每一帧的图片及播放时间\n实现类AnimationDrawable，在包android.graphics.drawable下面。其主要的方法void addFrame(@NonNull Drawable frame, int duration)，添加一帧。\nview动画（补间动画） xml文件存放在res/anim下面\n首先我们介绍view动画实现原理。说到其原理不能不提一个辅助类Transformation，正是Transformation保存了变换的状态。然后在view的draw方法中根据动画状态绘制\n  Transformation\n1 2 3 4 5 6 7  public class Transformation { ... protected Matrix mMatrix; protected float mAlpha; protected int mTransformationType; ... }   Transformation中最重要的是这三个变量。AlphaAnimation动画的状态保存在mAlpha变量中，TranslateAnimation\u0026amp;RotateAnimation\u0026amp;ScaleAnimation三个的动画状态则保存在mMatrix中。mTransformationType则是表示当前动画是通过变换mAlpha还是mMatrix实现的，或者两者同时都有变化。因为是利用Matrix变换来实现的缩放/平移/旋转，并没有真正改变view的位置大小，所以响应view点击事件的位置还在原处。\n具体看看View#draw(Canvas canvas, ViewGroup parent, long drawingTime)的源码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122  boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) { ... boolean more = false; ... Transformation transformToApply = null; boolean concatMatrix = false; final boolean scalingRequired = mAttachInfo != null \u0026amp;\u0026amp; mAttachInfo.mScalingRequired; final Animation a = getAnimation(); if (a != null) { more = applyLegacyAnimation(parent, drawingTime, a, scalingRequired); concatMatrix = a.willChangeTransformationMatrix(); if (concatMatrix) { mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; } transformToApply = parent.getChildTransformation(); } else { if ((mPrivateFlags3 \u0026amp; PFLAG3_VIEW_IS_ANIMATING_TRANSFORM) != 0) { // No longer animating: clear out old animation matrix  mRenderNode.setAnimationMatrix(null); mPrivateFlags3 \u0026amp;= ~PFLAG3_VIEW_IS_ANIMATING_TRANSFORM; } if (!drawingWithRenderNode \u0026amp;\u0026amp; (parentFlags \u0026amp; ViewGroup.FLAG_SUPPORT_STATIC_TRANSFORMATIONS) != 0) { final Transformation t = parent.getChildTransformation(); final boolean hasTransform = parent.getChildStaticTransformation(this, t); if (hasTransform) { final int transformType = t.getTransformationType(); transformToApply = transformType != Transformation.TYPE_IDENTITY ? t : null; concatMatrix = (transformType \u0026amp; Transformation.TYPE_MATRIX) != 0; } } } ... float alpha = drawingWithRenderNode ? 1 : (getAlpha() * getTransitionAlpha()); if (transformToApply != null || alpha \u0026lt; 1 || !hasIdentityMatrix() || (mPrivateFlags3 \u0026amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) { if (transformToApply != null || !childHasIdentityMatrix) { int transX = 0; int transY = 0; if (offsetForScroll) { transX = -sx; transY = -sy; } if (transformToApply != null) { if (concatMatrix) { if (drawingWithRenderNode) { renderNode.setAnimationMatrix(transformToApply.getMatrix()); } else { // Undo the scroll translation, apply the transformation matrix,  // then redo the scroll translate to get the correct result.  canvas.translate(-transX, -transY); //从Animation的辅助类Transformation获取matrix执行concat  canvas.concat(transformToApply.getMatrix()); canvas.translate(transX, transY); } parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; } float transformAlpha = transformToApply.getAlpha(); if (transformAlpha \u0026lt; 1) { alpha *= transformAlpha; parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; } } if (!childHasIdentityMatrix \u0026amp;\u0026amp; !drawingWithRenderNode) { canvas.translate(-transX, -transY); canvas.concat(getMatrix()); canvas.translate(transX, transY); } } // Deal with alpha if it is or used to be \u0026lt;1  if (alpha \u0026lt; 1 || (mPrivateFlags3 \u0026amp; PFLAG3_VIEW_IS_ANIMATING_ALPHA) != 0) { if (alpha \u0026lt; 1) { mPrivateFlags3 |= PFLAG3_VIEW_IS_ANIMATING_ALPHA; } else { mPrivateFlags3 \u0026amp;= ~PFLAG3_VIEW_IS_ANIMATING_ALPHA; } parent.mGroupFlags |= ViewGroup.FLAG_CLEAR_TRANSFORMATION; if (!drawingWithDrawingCache) { final int multipliedAlpha = (int) (255 * alpha); if (!onSetAlpha(multipliedAlpha)) { if (drawingWithRenderNode) { renderNode.setAlpha(alpha * getAlpha() * getTransitionAlpha()); } else if (layerType == LAYER_TYPE_NONE) { canvas.saveLayerAlpha(sx, sy, sx + getWidth(), sy + getHeight(), multipliedAlpha); } } else { // Alpha is handled by the child directly, clobber the layer\u0026#39;s alpha  mPrivateFlags |= PFLAG_ALPHA_SET; } } } } else if ((mPrivateFlags \u0026amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) { onSetAlpha(255); mPrivateFlags \u0026amp;= ~PFLAG_ALPHA_SET; } ... if (a != null \u0026amp;\u0026amp; !more) { if (!hardwareAcceleratedCanvas \u0026amp;\u0026amp; !a.getFillAfter()) { onSetAlpha(255); } parent.finishAnimatingView(this, a); } if (more \u0026amp;\u0026amp; hardwareAcceleratedCanvas) { if (a.hasAlpha() \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_ALPHA_SET) == PFLAG_ALPHA_SET) { // alpha animations should cause the child to recreate its display list  invalidate(true); } } ... return more; }     Animation\n AlphaAnimation TranslateAnimation RotateAnimation ScaleAnimation AnimationSet    API解析  fillBefore 动画结束后是否还原结束位置 fillAfter 动画结束后是否停留在结束位置 isFillEnabled true则会应用fillBefore设置，否则忽略fillBefore设置并始终应用动画转换，直到动画结束 backgroundColor 设置view动画背景色 repeatMode [RESTART|REVERSE] 重复模式。 repeatCount 重复次数。默认值0:不重复 \u0026gt;0:重复次数 \u0026lt;0：无限循环 startTime 设置动画开始时间 startNow startOffset 相对startTime的偏移时间。当使用AnimationSet执行多个动画，多个动画执行时间不一致时可以用该方法设置 zAdjustment [ZORDER_NORMAL|ZORDER_TOP|ZORDER_BOTTOM] 设置运行动画时Z轴位置 restrictDuration(long durationMillis) 根据参数做调整。动画时长不能超多durationMillis。超过限制时长durationMillis动画不会再执行，包括重复动画。 scaleCurrentDuration 按比例缩放动画时长 willChangeBounds 动画是否会改变view边界，上面说过除了AlphaAnimation其他三个Animation利用Matrix变换实现的动画，所以都会改变边界。故除了AlphaAnimation返回false，其他三个返回true。 willChangeTransformationMatrix 动画是否会改变Transformation matrix。上面说过Transformation是view动画的辅助类。Transformation中matrix的状态基本上可以等同后面view matrix要变换的状态。类似willChangeBounds，除了AlphaAnimation其他三个Animation利用Matrix变换实现的动画，所以都会改变边界。故除了AlphaAnimation返回false，其他三个返回true。 getTransformation(long currentTime, Transformation outTransformation) 获取动画辅助类Transformation  AnimationUtils  loadAnimation() 加载set/alpha/scale/rotate/translate/cliprect动画 loadLayoutAnimation() 加载layoutAnimation/gridLayoutAnimation动画。layoutAnimation并不是严格意义的动画，而是对animation实现控制的辅助类。是用在ViewGroup上控制子控件的动画控制器。可以通过layout文件android:layoutAnimation或者ViewGroup的setLayoutAnimation(LayoutAnimationController controller)设置。 makeInAnimation() 加载Android提供的com.android.internal.R.anim.slide_in_left/com.android.internal.R.anim.slide_in_right动画 makeInChildBottomAnimation() 加载Android提供的com.android.internal.R.anim.slide_in_child_bottom动画 makeOutAnimation() 加载Android提供的com.android.internal.R.anim.slide_out_left/com.android.internal.R.anim.slide_out_right动画  view动画部分xml属性设置：\npivotX取值\t含义\n10\t距离动画所在view自身左边缘10像素\n10%\t距离动画所在view自身左边缘 的距离是整个view宽度的10%\n10%p\t距离动画所在view父控件左边缘的距离是整个view宽度的10%\n属性动画 Android3.0后添加的新的动画。看名字就知道属性动画的原理就是修改对象的属性值来实现的。\nxml文件存放在res/animator。实现类在android.animation包下。\nAnimator\n ValueAnimator  TimeAnimator 继承自ValueAnimator，提供一个TimeListener监听器用来监听当前距动画开始的时间，以及当前距上一动画帧的时间 ObjectAnimator 通过反射改变对象的属性值控制动画，网上的用例太多这里就不举例了。需要注意的是这里所谓的属性是需要设置set方法的，属性本身不一定真的要存在。属性名字是以set方法名为准的。   AnimatorSet 类比AnimationSet  TimeInterpolator\u0026amp;TypeEvaluator  TimeInterpolator 插值器\ngetInterpolation(float input)的参数input[0,1]\n控制动画时间内某个时间点的fraction。不同插值器的在时间轴变化率不同。比如按正弦变化/指数变化\n例如加速插值器AccelerateInterpolator： 1 2 3 4 5 6 7 8 9 10 11  public class AccelerateInterpolator extends BaseInterpolator implements NativeInterpolatorFactory{ ... public float getInterpolation(float input) { if (mFactor == 1.0f) { return input * input; } else { return (float)Math.pow(input, mDoubleFactor); } } ... }    TypeEvaluator 估值器\n通过fraction控制startValue变换到endValue。如控制argb/int/matrix/rect变换。不同类型的计算方式不同。  总的来说TimeInterpolator是和TypeEvaluator是配合使用的，插值器负责提供改变因子fraction，估值器负责根据改变因子fraction和不同的数据类型提供不同的计算方式得到直接影响或者使用在动画上的数据。\nViewAnimationUtils实现揭露动画 揭露动画是一种慢慢显示vie全貌的动画\n1 2 3 4 5 6 7 8 9 10  public final class ViewAnimationUtils { private ViewAnimationUtils() {} //startRadius 揭露动画结束时的半径  //endRadius 揭露动画结束时的半径  public static Animator createCircularReveal(View view, int centerX, int centerY, float startRadius, float endRadius) { return new RevealAnimator(view, centerX, centerY, startRadius, endRadius); } }   矢量动画 VectorDrawable\n约束布局的关键帧动画 转场动画Transition 移步Android-转场动画Transition\nlottie动画 使用简单，官方用例也详细，这里不再详述。主要将下原理。\n1 2 3 4 5 6 7 8  \u0026lt;com.airbnb.lottie.LottieAnimationView android:id=\u0026#34;@+id/animView\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34; app:lottie_fileName=\u0026#34;lottie/222-trail-loading.json\u0026#34; app:lottie_autoPlay=\u0026#34;true\u0026#34; app:lottie_repeatMode=\u0026#34;restart\u0026#34; app:lottie_repeatCount=\u0026#34;-1\u0026#34;/\u0026gt;   lottie有几个重要的类：LottieAnimationView/LottieComposition/LottieCompositionMoshiParser/LottieDrawable/LottieValueAnimator。\nLottieAnimationView继承自AppcompatImageView加载LottieDrawable；LottieDrawable继承自Drawable。LottieDrawable利用LottieCompositionMoshiParser解析资源(json/stream等)得到LottieComposition并配合LottieValueAnimator绘制自己\n  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-app%E6%89%93%E5%8C%85%E6%B5%81%E7%A8%8B/",
	"title": "Android打包流程",
	"tags": ["android"],
	"categories": [],
	"series": [],
	"description": "Android打包流程",
	"content": "前言 说打包流程前我们先了解几个名词和概念\nAAPT(Android Asset Packing Tool) AAPT是一种编译工具，用于Android Studio和Android Gradle Plugin 编译打包应用资源Android资源打包工具。build_toos下有两个版本AAPT工具:aapt和aapt2，Android Gradle Plugin 3.0.0以上版本默认使用aapt2。aapt2是在aapt之上做了优化，aapt2会解析资源，为资源编索引并将资源编译成针对Android平台进行过优化的二进制格式。\naapt2还支持通过启用增量编译实现更快的资源编译，将资源处理拆分为编译和链接两个步骤：\n  编译：将资源文件编译成后缀名为.flat(简单理解为相当于Java中的class文件)的中间二进制格式。\n编译资源示例：aapt2 compile project/module/src/main/res/values/strings.xml -o resoutputdir\nAS中编译出的.flat资源文件可以在build/intermediates/res/merged/debug中找到。\n  链接：合并所有已编译的文件并打包到一个软件包(.ap_文件)中。\n在链接阶段aapt2会合并在编译阶段生成的所有中间文件(例如ARSC_资源表、二进制XML文件和处理过的PNG文件)，并将它们打包成一个.ap_文件，此外还会生成其他辅助文件如：R.java和ProGuard规则文件。.ap_文件的结构和APK一致，只是缺少了dex文件，.ap_文件可以看作一个不包含dex文件且未签名的APK文件，它是.apk的前置文件，看后缀名就知道了。\n.ap_文件位于build/intermediates/processed_res/debug/out/resources-debug.ap_，低版本的AS可能位于build/intermediates/res/debug/resources-debug.ap_，我们解压resources-debug.ap_可以看到里面有AndroidManifest.xml、resources.arsc和res文件夹。\n链接示例：aapt2 link -o output.ap_ -I sdkdir/platforms/android-xx/android.jar resoutputdir/res/values_xxx.arsc.flat resoutputdir/res/drawable_xxx.flat resoutputdir/res/... --manifest path/to/AndroidManifest.xml -v\n另外aapt2 dump [subcommand] [options] xxx.ap_输出有关link命令生成的.ap_的资源和清单信息，具体命令可以使用aapt2 dump -h查看，上面说了.ap_就是个缺少dex的.apk，这里.ap_文件换成build/output/apk/debug/app_debug.apk是一样的\n  这种拆分有助于提高增量编译的性能，当一个文件发生改变只需要重新编译这个文件即可。\n打包流程 打包所需的工具基本都在\nsdk/build_tools/xx.x.x路径下，xx.x.x是版本号\n我们完全可以自己使用该路径下的工具一步一步打包。\n在Android Studio中开发Gradle构建工具帮我们做了这些事情，但Gradle不会自主选择哪个版本号下的打包工具打包，所以需要我们配置，即Module下的build.gradle中配置buildToolsVersion\n另外还需要使用到sdk/tools/lib下的sdklib.jar。\n 使用aapt/aapt2打包资源文件 生成R.java和resources.arsc文件 使用aidl读取.aidl文件生成对应Java文件 使用环境中的Java编译器将Java文件编译成.class文件 使用dx/d8将多个.class文件转换打包成.dex文件 使用sdklib.jar将.dex和其他资源文件打包成.apk 使用zipalign对.apk中未压缩文件对齐优化，减少运行应用时消耗的RAM容量\nZipalign是一个android平台上整理APK文件的工具，它对apk中未压缩的数据进行4字节对齐，对齐后就可以使用mmap函数读取文件，可以像读取内存一样对普通文件进行操作。如果没有4字节对齐，就必须显式的读取，这样比较缓慢并且会耗费额外的内存。 使用apksigner对apk签名  老版本是先使用jarsigner对apk签名后再执行zipalign，现在需要先执行zipalign再使用jarsigner对apk签名，因为V2签名会校验归档中所有字节。否则签名会失效\n老版本使用apkbuilder打包apk，apkbuilder也是调用sdklib.jar完成打包，现在直接使用sdklib.jar打包apk，apkbuilder已被废弃。如果下载过AOSP，你可以在sdk目录中看到一个apkbuilder目录，里面存在apkbuilder，但阅读apkbuilder目录中的readme.txt你可以看到\nThe apkbuilder command line tool is deprecated, and is not maintained anymore. It is lacking recent build improvements such as support for Library Projects. Its source code has been moved into sdklib. It is recommended to directly use the com.android.sdklib.build.ApkBuilder class instead. 平时我们的AS运行，如果没有配置签名，会使用 当前用户目录下/.android/下的签名的。\nAndroid签名V1/V2/V3 见Android 签名机制 v1、v2、v3\n参考：\n 命令行工具 Android 签名机制 v1、v2、v3  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "Android插件化",
	"tags": ["android", "插件化"],
	"categories": [],
	"series": ["插件化"],
	"description": "Android插件化",
	"content": "开源插件化框架 VirtualAPK、DroidPlugin、RePlugin\nHook 实现Hook的技术：1.反射 2.动态代理\n查找Hook点的原则  尽量静态变量或单例对象 尽量Hook public的对象和方法  插件化原理 启动插件Activity Android中Activity启动流程 应用程序进程想SystemServer进程的ASM请求创建Activity。\n  Activity.startActivity -\u0026gt; Activity.startActivityForResult -\u0026gt; Activity.startActivityFromChild\n-\u0026gt; AMS(ActivityManager).startActivity\n-\u0026gt; Instrumentation.execStartActivityFromAppTask\nThread.currentThread().contextClassLoader?\n  插件化实现启动插件中Activity思考 方式一 使用代理Activity 方式二 Hook AMS/Instrumentation 这种方式仍然需要一个注册的Activity帮我们欺骗AMS以通过验证。\n插件换肤 "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-chromium%E7%BC%96%E8%AF%91/",
	"title": "Android浏览器-编译Chromium",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "Android浏览器-编译Chromium",
	"content": "安装depot_tools git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git 报错：\nfatal: unable to access 'https://chromium.googlesource.com/chromium/tools/depot_tools.git/': Failed to connect to chromium.googlesource.com port 443: Operation timed out 这是由于terminal没有走代理，需要配置代理http监听端口号port。我这里使用的Trojan，查看Trojan的偏好设置。可以看到高级及http选项。\n我们可以如下配置：\ngit config --global http.proxy \u0026quot;localhost:1081\u0026quot; 或者：\ngit config --global http.proxy socks5://127.0.0.1:1080 git config --global https.proxy socks5://127.0.0.1:1080 https://chromium.googlesource.com/chromium/src/+/master/docs/android_build_instructions.md\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android%E7%94%BB%E4%B8%AD%E7%94%BB-pictureinpicture/",
	"title": "Android画中画-PictureInPicture",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android画中画-PictureInPicture详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%9B%B4%E6%92%AD-%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95/",
	"title": "Android直播-录制屏幕",
	"tags": ["android", "直播", "音视频"],
	"categories": [],
	"series": ["直播"],
	"description": "Syntax highlighting test",
	"content": "录屏的根本是怎么获取屏幕的显示数据\n屏幕录制的几种实现方式：  Linux+framebuffer+root权限 利用View.getDrawingCache() Android shell命令screencap/screenrecord+root权限 SurfaceFlinger+framebuffer VirtualDisplay+MediaProjection  一、Linux+framebuffer+root权限 Android 基于 Linux，所以可以通过读取 /dev/graphics/fb0 设备节点，即 framebuffer 中的帧数据来实现屏幕的录制。但是读取这个设备节点需要 root 权限\n二、View.getDrawingCache() 通过 View 的 cache 内容获取到 Bitmap 对象来达到录屏的效果。但是很多手机上面该方式会存在性能问题，另外该方式并不是一个真正意义上的录屏方式，另外部分 View 组件的内容并不能获取到，比如webview\n三、Android shell命令screencap/screenrecord+root权限 screencap/screenrecord 是 Android shell 的命令，需要root 权限\n creencap -p xxx.png/screenshot xxx.png adb shell screenrecord \u0026ndash;size 1280*720 \u0026ndash;bit-rate 6000000 \u0026ndash;time-limit 30 /sdcard/demo.mp4\n\u0026ndash;size 指定视频分辨率；\n\u0026ndash;bit-rate 指定视频比特率，默认为4M，该值越小，保存的视频文件越小；\n\u0026ndash;time-limit 指定录制时长，若设定大于180，命令不会被执行；  四、SurfaceFlinger + framebuffer 见参考 从surfaceflinger历史变更谈截屏\n五、VirtualDisplay + MediaProjection 在我的华为荣耀8 android8.0 手机上下载虎牙直播测试发现他们使用的是该方案\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  class ScreenCaptureActivity : AbsActivity() { lateinit var surface: Surface private lateinit var surfaceView: SurfaceView lateinit var projectionManager: MediaProjectionManager private var display: VirtualDisplay? = null private var projection: MediaProjection? = null // private var _resultCode: Int? = null  private var _resultData: Intent? = null private lateinit var capture: TextView companion object { const val REQUEST_PROJECTION = 2 const val STATE_RESULT_CODE = \u0026#34;result_code\u0026#34; const val STATE_RESULT_DATA = \u0026#34;result_data\u0026#34; } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_screen_capture) // _resultCode = savedInstanceState?.getInt(STATE_RESULT_CODE)  _resultData = savedInstanceState?.getParcelable(STATE_RESULT_DATA) surfaceView = findViewById(R.id.surface) surface = surfaceView.holder.surface projectionManager = getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager capture = findViewById(R.id.capture) capture.setOnClickListener { if (display == null) { startCapture() capture.text = \u0026#34;停止\u0026#34; } else { stopCapture() capture.text = \u0026#34;开始\u0026#34; } } } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) // if (_resultCode != null) { // outState.putInt(STATE_RESULT_CODE, _resultCode!!) // }  if (_resultData != null) { outState.putParcelable(STATE_RESULT_DATA, _resultData) } } override fun onPause() { super.onPause() stopCapture() } override fun onDestroy() { super.onDestroy() projection?.stop() projection = null } private fun startCapture() { if (/*_resultCode == null \u0026amp;\u0026amp;*/ _resultData == null) { startActivityForResult( projectionManager.createScreenCaptureIntent(), REQUEST_PROJECTION ) } else { setup() } } private fun stopCapture() { display?.release() display = null } private fun setup() { if (projection == null) { projection = projectionManager.getMediaProjection( /*_resultCode!!*/Activity.RESULT_OK, _resultData!! ) } if (projection != null) { display = projection!!.createVirtualDisplay( \u0026#34;ScreenCapture\u0026#34;, surfaceView.width, surfaceView.height, Getter.metrics().densityDpi, DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, surface, null, null ) } } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { REQUEST_PROJECTION -\u0026gt; { if (resultCode != Activity.RESULT_OK) { Toast.makeText(this, \u0026#34;User denied screen sharing permission\u0026#34;, Toast.LENGTH_LONG) .show() return } // _resultCode = resultCode  _resultData = data setup() } } } }   单纯在当前activity或app中实现录屏使用场景有限，实际使用中需要配合Service实现app退到后台继续录屏\n参考：\n 手机游戏直播中的录屏怎么实现 从surfaceflinger历史变更谈截屏  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%9B%B4%E6%92%AD-%E9%87%87%E5%BD%95%E6%91%84%E5%83%8F%E5%A4%B4/",
	"title": "Android直播-采录摄像头",
	"tags": ["android", "直播", "音视频"],
	"categories": [],
	"series": ["直播"],
	"description": "Android直播-采录摄像头",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E7%BB%84%E4%BB%B6%E5%8C%96/",
	"title": "Android组件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android组件化",
	"content": "将配置抽出来，在config.gradle中配置，在工程build.gradle中添加apply from: \u0026ldquo;config.gradle\u0026quot;应用config.gradle中的配置。\n在Module中的build.gradle中添加\nif (isRelease) { apply plugin: 'com.android.library' } else { apply plugin: 'com.android.application' } 并在sourceSets中配置Module作为独立工程时的AndroidManifest\nsourceSets { main { if (isRelease) { manifest.srcFile 'src/main/AndroidManifest.xml' java { exclude \u0026quot;**/debug/**\u0026quot; } } else { manifest.srcFile 'src/main/debug/AndroidManifest.xml' } } } "
},
{
	"uri": "https://dshcao.github.io/zh/tags/anr/",
	"title": "anr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/anr%E5%88%86%E6%9E%90/",
	"title": "ANR分析",
	"tags": ["anr"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/appbundle/",
	"title": "AppBundle",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/apt/",
	"title": "apt",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ar/",
	"title": "ar",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/arouter/",
	"title": "arouter",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/cc++%E5%9F%BA%E7%A1%80/",
	"title": "C&amp;C++基础",
	"tags": ["c/c++"],
	"categories": [],
	"series": ["c/c++"],
	"description": "C&amp;C++基础",
	"content": "C/C++编译过程 编译过程分四个阶段：\n  预处理\n处理#include和#define等。将#include包含的.h文件插入到#include所在的位置。把源程序中#define定义的宏使用实际的字符串代替。\nhello.c源文件经过预处理后输出hello.i\n  编译\n编译器检查代码的规范性和语法错误等，检查无误后编译器将代码翻译成汇编语言。\nhello.i经过编译后输出hello.s\n  汇编\n将.s文件翻译成二进制机器指令文件.o\nhello.s经过汇编输出hello.o\n  链接\n链接使用到的其他函数库\n  C/C++占位符  %a,%A 读入一个浮点值(仅C99有效)  %c 读入一个字符  %d 读入十进制整数  %i 读入十进制，八进制，十六进制整数  %o 读入八进制整数  %x,%X 读入十六进制整数  %s 读入一个字符串，遇空格、制表符或换行符结束。  %f,%F,%e,%E,%g,%G 用来输入实数，可以用小数形式或指数形式输入。  %p 读入一个指针  %u 读入一个无符号十进制整数  %n 至此已读入值的等价字符数   C/C++基本数据类型 C基本数据类型  基本类型\n整数类型和浮点类型 枚举类型 void类型 派生类型\n指针类型、数组类型、结构类型、共用体类型和函数类型  C++基本数据类型 指针 指针是指向一个变量地址的变量，但一个变量占据一个内存段的，那指针怎么表示呢？\n实际上指针的值是变量内存段的首地址或者说是地址的开始，那指针读取变量值的时候到底要多少字节？指针类型就派上了用场\n空指针 二级指针 指针内存存放的是另一个指针的内存地址\n多级指针 类推二级指针，一个指针还可以指向二级指针的内存地址\u0026hellip;\n指针运算 指针p++运算即是从当前指针位置向前移动sizeof(指针类型)个字节\n指针p\u0026ndash;运算即是从当前指针位置向后移动sizeof(指针类型)个字节\n函数指针 返回值 (*函数指针名)(参数类型 参数变量,参数类型 参数变量,\u0026hellip;)\n如：int (*funAdd)(int a,int b)\n指针常量与常量指针  指针常量\n指针所指向的地址不能改变，但可以改变指针所指向地址的内容。 1 2 3 4  int a = 2,b = 3; int *const p = \u0026amp;a; p = \u0026amp;b;//错误 *p = 4;//可以    常量指针\n指向常量的指针，指针指向的地址的内容不能修改 1 2 3 4  int a = 2,b = 3; const int *p = \u0026amp;a; *p = 4;//错误，不能修改指针所指向的地址中的内容 p = \u0026amp;b;//可以，可以修改指针地址     常量函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  class Person { static char c; char *name; int age; public: void abc() const { } void aa() const { c = \u0026#39;a\u0026#39;;//可以  // age = 10;//错误  } void bb() { aa(); } void cc() { } }; int main() { Person *person = new Person(); person.abc();//可以  person-\u0026gt;aa();//错误  person-\u0026gt;bb();//错误  person-\u0026gt;cc();//可以  const Person person1 = Person();//常量对象只能调用常量函数  person1.abc();//可以  person1.aa();//错误  person1.bb();//错误  person1.cc();//错误  return 0; }   常量函数的const修饰的是this指针。常函数的作用防止数据成员被非法访问。\n常量对象只能调用常量函数\n非常量对象既可以调用常量函数也可以调用非常量函数\n数组 数组名就是一个常量指针\n1 2 3 4  int array[] = {1, 2, 3}; printf(\u0026#34;array *%p\\n\u0026#34;, array);//0x7ffeecace604 printf(\u0026#34;array+1 *%p\\n\u0026#34;, array + 1);//0x7ffeecace604+4 printf(\u0026#34;\u0026amp;array+1 *%p\\n\u0026#34;, \u0026amp;array + 1);//0x7ffeecace604+4*3   友元函数和友元类 操作符重载 虚继承和虚函数 虚函数 可以被子类重写覆盖的方法。\n纯虚函数 纯虚函数相当于Java中的抽象方法，此时其所在的类就相当于Java中的抽象类。子类必须重写纯虚函数。\n1 2  virtual void sayHello();//虚函数 virtual void sayHello() = 0;//纯虚函数   函数模版(泛型) \u0026amp;符 1 2 3  int a = 10; int *b = \u0026amp;a;//c/c++通用写法，表示取地址符 int \u0026amp;c = a;//c++中的写法，c中没有引用概念。写在变量声明时表示引用   \u0026amp;与左值使用表示引用，与右值表示取地址符。当表示引用时，如：int \u0026amp;c = a;那么c和a都是指向内存中的同一块内存，因此当改变a/c时，c/a也会随着改变。\n常引用 1 2 3 4 5 6 7  int a = 2,b = 3; const int \u0026amp;c = a; c = b;//错误  const int \u0026amp;d = 10;//字面量 d = 10;//错误 d = a;//错误   拷贝构造函数 默认拷贝构造函数是值传递，即浅拷贝。当然可以重写修改其行为，使用深拷贝。\n浅拷贝容易出现多次释放同一内存空间导致出错。\n拷贝构造函数的调用场景：\n 声明时复制 作为参数传入，实参给形参赋值 作为函数返回值返回，给变量初始化赋值时\n不难看出2、3本质上也是1。  1 2 3  Person p1; Person p2; p1 = p2;//不会调用拷贝构造函数。   构造函数的属性初始化列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Person{ private: char *name; public: Person(char *name){ this-\u0026gt;name = name; } } class Man{ int age; Person p; Person p2; public: Man(int age,char *name,char *name2):p(name),p2(name2){ this-\u0026gt;age = age; } }   构造函数的属性初始化列表执行顺序：先调用属性的构造函数，再调用该对象的构造函数，释放时先释放该对象(调用该对象的析构函数)，再释放属性对象(调用属性对象的析构函数)\nC结构体 结构体大小(字节对齐)：结构体变量的大小必须是最宽基本数据类型的整数倍。结构体内变量顺序也会影响结构体大小，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  struct Test { char a;//1字节  int b;//4字节  double c;//8字节 } test; struct Test2 { int b;//4字节  double c;//8字节  char a;//1字节 } test2; printf(\u0026#34;Test:%d\u0026#34;, sizeof(Test));//Test:16 printf(\u0026#34;Test2:%d\u0026#34;, sizeof(Test2));//Test2:24   联合体(共用体) 联合体不同类型的变量共用一段内存(相互覆盖)，联合变量任何时刻只有一个成员存在。联合体变量的大小等于最大的成员所占的字节数。联合体的目的是为了节省内存。\n宏定义 宏定义的本质是文本替换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  #define MIN 100//宏变量定义  #define math(LOGIC) my_test_math_##LOGIC() #define mathmin(LOGIC,A) my_test_math_##LOGIC(A) #define mmin(A) my_test_math_min(A) #define MAX(a,b) (a\u0026gt;b?a:b) #define swap(x, y)\\x = x + y;\\y = x - y;\\x = x - y; void my_test_math_add(int a) { printf(\u0026#34;my_test_math_add\u0026#34;); } void my_test_math_min() { printf(\u0026#34;my_test_math_min\u0026#34;); } int main() { math(add);//调用my_test_math_add()  return 0; }   C/C++内存 C/C++内存主要分为：\n 栈区(stack)\n操作系统分配一个程序的栈区大小是固定的，一般window下是2M，静态内存分配超过栈区大小会报stack overflow错误。栈区内存是编译器自动分配，自动释放回收。\n比如在一个函数中声明一个局部变量：int a=10;C/C++的栈也可以存放对象。 堆区(heap)\n堆区由程序员分配和释放，如果程序员没有释放也可能会 由操作系统释放。比如C中使用malloc：p1 = (char *)malloc(10);，C++中使用的new运算符。 静态区或全局区 字符常量区 程序代码区  1 2 3 4 5 6 7 8 9 10 11 12 13  int a = 0; //全局初始化区 char *p1; //全局未初始化区 main() { int b; //栈  char s[] = \u0026#34;abc\u0026#34;; //栈  char *p2; //栈  char *p3 = \u0026#34;123456\u0026#34;; //123456\\0在常量区，p3在栈上。  static int c =0； //全局（静态）初始化区  p1 = (char *)malloc(10); p2 = (char *)malloc(20); //分配得来得10和20字节的区域就在堆区  strcpy(p1, \u0026#34;123456\u0026#34;); //123456\\0放在常量区，编译器可能会将它与p3所指向的\u0026#34;123456\u0026#34;优化成一个地方。 }   系统内存区域 系统内存区域是不可写的内存，当我们手动改变指针指向系统内存区域时赋值是会报错的。一般系统内存的地址是在一段小值区域(比如0~100000表示的内存地址区域)。\n一个常见的错误：\n1 2 3  int *cp = NULL; printf(\u0026#34;NULL指针cp地址: %p\u0026#34;, cp); *cp = 101;   Mac下打印指针cp的地址是0x0，当我们直接操作这个指针地址赋值为101会报错\nProcess finished with exit code 11，因为我们不能操作内存地址是0x0的这一块内存，这是系统内存，不允许读写。如果我们换成下面：\n1 2 3 4  int pv = 100; int *cp = \u0026amp;pv; printf(\u0026#34;NULL指针cp地址: %p\u0026#34;, cp); *cp = 101;   运行不会报错，因为cp此时指针的内存是pv所在的内存，是系统分配给我们的可读写的用户内存。\n取值符 * 和取地址符 \u0026amp; *在声明变量时表示该变量是一个指针，在和变量运算时表示取值符。\n\u0026amp;不在声明变量时使用，在和变量运算时表示取地址符。\n静态内存分配和动态内存分配 静态内存分配是编译器即可确定分配的内存大小，如：int a[10];，写成int len=10;int a[len];是会报错的，动态分配内存需要使用malloc。malloc分配的内存可能有脏数据，需要memset初始化\n动态内存分配是运行时确定分配的内存大小，如：int *p = malloc(len * sizeof(int));，如果运行时发现动态分配的内存不够，可以使用realloc重新分配内存，int *p2=realloc(p,(len + addLen ) * sizeof(int))，realloc的第一个参数是需要重新分配内存的原指针，第二个参数是重新分配的内存大小。重新分配的内存地址可能是新的内存地址(此时原分配内存会被释放)，也可能不会变(如果可以在原分配的内存上能够连续增加新增长的内存)，当然也可能失败，失败时int *p2是NULL，可以通过int *p2是否是NULL判断申请内存分配是否成功。如果重新申请内存p2失败那么原分配的内存p仍然有效。\n动态内存分配的另一个写法，使用calloc：int * cp = calloc(len, sizeof(int));。calloc和malloc两个区别：calloc写法更方便清晰，而且会自动将申请内存清零防止脏数据。相当于自动调用了memset。\nfree free释放指针内存(free不能多次释放同一指针)。\n1 2 3 4  if(p!=NULL){ free(p); p = NULL;//free(p)释放的是p指向的内存，p本身仍然有值，需要将p设置为NULL }   C中内存泄漏问题 当一个指针被连续多次申请内存是，使用free释放内存会发生内存泄漏，如：\n1 2 3 4 5 6 7  int *p = malloc(len * sizeof(int)); p = malloc(len * 2 * sizeof(int)); if(p! = NULL) { free(p); p = NULL; }   此时很可能会发生内存泄漏问题。\nC中字符串 1 2 3 4 5 6 7 8 9 10  char str[] = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;}; char str1[] = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;,\u0026#39;\\0\u0026#39;}; char str2[4] = {\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;}; char str3[] = \u0026#34;abc\u0026#34;; str3[0]=\u0026#39;k\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;,str);// printf(\u0026#34;%s\\n\u0026#34;,str1);//abc printf(\u0026#34;%s\\n\u0026#34;,str2);//abc printf(\u0026#34;%s\\n\u0026#34;,str3);//kbc   其中str1、str2、str3是一致的，但str的输出除了abc还会有一堆乱码，因为C中的字符串是以\\0结束的，所以没有指定长度时需要加上\u0026rsquo;\\0'表示字符串结束，否则程序并不知道读到哪里结束就会出现乱码等问题。\n另外还有一种指针的写法：char * str=\u0026quot;abc\u0026quot;;，C支持这种写法，但C++11规范不推荐这么写，会有警告。另外这种指针写法和char str[]写法的区别是char str[]这种写法可以修改某个位置的字符串，char * str则不行，无论是str[0]='k';还是str+1，*str='k';都会报错。\nC中的文件操作 见C 标准库 - \u0026lt;stdio.h\u0026gt;\n动态申请内存和释放内存 通常malloc和free是一起出现，new和delete一起出现，new和delete是C++中新的写法，C++中保留malloc/free主要是为了兼容C。new时会调用构造函数，delete时会调用析构函数，而malloc和free则不会调用相关函数。另外malloc/free的操作对象都是必须明确大小的。new/delete则自动进行类型和大小检查。从理论上说使用malloc申请的内存是可以通过delete释放的，一般也不这样写的。而且也不能保证每个C++的运行时都能预期的正常运行。\n*/[]/()结合优先级问题 ()\u0026gt;[]\u0026gt;*\n参考：\nC 标准库 - \u0026lt;stdio.h\u0026gt;\n"
},
{
	"uri": "https://dshcao.github.io/zh/series/c/c++/",
	"title": "c/c++",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/c/c++/",
	"title": "c/c++",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/c/c++/",
	"title": "c/c++",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/camera/",
	"title": "camera",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ffmpeg/",
	"title": "ffmpeg",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/ffmpeg/",
	"title": "ffmpeg",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/git/",
	"title": "git",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/git-%E8%AF%A6%E8%A7%A3/",
	"title": "git 详解",
	"tags": ["git"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": "[http]\nproxy = 127.0.0.1:1081\n[https]\nproxy = 127.0.0.1:1081\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/glide/",
	"title": "glide",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/gradle/",
	"title": "gradle",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-hashmap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/",
	"title": "HashMap源码分析",
	"tags": ["java"],
	"categories": [],
	"series": ["源码解析"],
	"description": "HashMap源码分析",
	"content": "以JDK8源码分析\n前言 HashMap是结合数组和链表，以Key-Value形式存储的集合。HashMap中有三个个概念：负载因子(loadFactor)、容量和阀值。默认阀值是0.75，阀值=当前容量*负载因子，如果元素个数超过这个阀值则HashMap容量翻倍。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  public class HashMap\u0026lt;K,V\u0026gt; extends AbstractMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt;, Cloneable, Serializable { ... static class Node\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final int hash; final K key; V value; Node\u0026lt;K,V\u0026gt; next; Node(int hash, K key, V value, Node\u0026lt;K,V\u0026gt; next) { this.hash = hash; this.key = key; this.value = value; this.next = next; } public final K getKey() { return key; } public final V getValue() { return value; } public final String toString() { return key + \u0026#34;=\u0026#34; + value; } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (o == this) return true; if (o instanceof Map.Entry) { Map.Entry\u0026lt;?,?\u0026gt; e = (Map.Entry\u0026lt;?,?\u0026gt;)o; if (Objects.equals(key, e.getKey()) \u0026amp;\u0026amp; Objects.equals(value, e.getValue())) return true; } return false; } } static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); } transient Node\u0026lt;K,V\u0026gt;[] table; ... }   可以看出HashMap的基本结构：\n数组table存储一组Node元素，而Node本身又是单向链表，因此table实际上存储的是一组链表的头节点。那么table的容量是多少？存储规则又是什么呢？\n源码分析 put逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果数组tab[i]的位置还没有节点则新建节点存入  //注意这里计算下标i的算法：(n - 1) \u0026amp; hash相当于hash%(n-1)，\u0026amp;运算效率高于取余运算  if ((p = tab[i = (n - 1) \u0026amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else {//如果数组tab[i]的位置已有节点p  Node\u0026lt;K,V\u0026gt; e; K k; //要存入的节点和节点p的key相同  if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) e = p; //如果节点p是红黑树，则使用红黑树存储  else if (p instanceof TreeNode) e = ((TreeNode\u0026lt;K,V\u0026gt;)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { //如果节点的下个点解是null，将要存入的键值对做为新的Node存入节点之后  if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); //如果某个链表长度大于7个节点尝试将节点转换成红黑树  if (binCount \u0026gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  treeifyBin(tab, hash); break; } //如果已经存在相同key的节点，后面会修改这个节点的值  if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key  V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u0026gt; threshold) resize(); afterNodeInsertion(evict); return null; } final void treeifyBin(Node\u0026lt;K,V\u0026gt;[] tab, int hash) { int n, index; Node\u0026lt;K,V\u0026gt; e; //如果table.length个数小于MIN_TREEIFY_CAPACITY(64)，先增大容量不转换成红黑树  if (tab == null || (n = tab.length) \u0026lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) \u0026amp; hash]) != null) { TreeNode\u0026lt;K,V\u0026gt; hd = null, tl = null; do { TreeNode\u0026lt;K,V\u0026gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else { p.prev = tl; tl.next = p; } tl = p; } while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); } }   remove逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  final Node\u0026lt;K,V\u0026gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; p; int n, index; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (p = tab[index = (n - 1) \u0026amp; hash]) != null) { Node\u0026lt;K,V\u0026gt; node = null, e; K k; V v; if (p.hash == hash \u0026amp;\u0026amp; ((k = p.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode\u0026lt;K,V\u0026gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } if (node != null \u0026amp;\u0026amp; (!matchValue || (v = node.value) == value || (value != null \u0026amp;\u0026amp; value.equals(v)))) { if (node instanceof TreeNode) ((TreeNode\u0026lt;K,V\u0026gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; }   get逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  final Node\u0026lt;K,V\u0026gt; getNode(int hash, Object key) { Node\u0026lt;K,V\u0026gt;[] tab; Node\u0026lt;K,V\u0026gt; first, e; int n; K k; if ((tab = table) != null \u0026amp;\u0026amp; (n = tab.length) \u0026gt; 0 \u0026amp;\u0026amp; (first = tab[(n - 1) \u0026amp; hash]) != null) { if (first.hash == hash \u0026amp;\u0026amp; // always check first node  ((k = first.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u0026lt;K,V\u0026gt;)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || (key != null \u0026amp;\u0026amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; }   hash的计算 首先看hash的计算\n1 2 3 4  static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16); }   为什么不是直接返回hashCode?为什么是^（异或），为什么是16？\n我们先看计算下标的逻辑：tab[i = (n - 1) \u0026amp; hash]，即下标是(n - 1) \u0026amp; hash，n是n = tab.length，tab = table，即tab实际上是那个Node数组table。\nHashMap的size是一个int值，即4字节32位。所以上面的n，即table.length的值理论上是至少小于HashMap size的一半的，即2字节16位。所以下标的计算i = (n - 1) \u0026amp; hash实际上只会用到hash的低16位。这大大加大了hash冲突，如何让高16位也参与\u0026amp;运算增加散列度呢？于是就有了(h = key.hashCode()) ^ (h \u0026gt;\u0026gt;\u0026gt; 16)的设计，让hashCode的高16位与hashCode的低16位异或运算。\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-threadlocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "Java ThreadLocal源码解析",
	"tags": ["java"],
	"categories": [],
	"series": ["源码解析"],
	"description": "ThreadLocal源码解析",
	"content": "ThreadLocal应用场景 ThreadLocal适合需要在不同线程存储不同且唯一的上下文信息的场景\n魔数0x61c88647 0x61c88647是一个魔数，它等于2的32次方*黄金比例，用于提高散列度。\n1 2 3 4 5 6 7 8 9 10 11  public class ThreadLocal\u0026lt;T\u0026gt; { private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() { return nextHashCode.getAndAdd(HASH_INCREMENT); } ... }   Thread类的threadLocals和inheritableThreadLocals变量 在解析前我们先看Thread类的两个成员变量：threadLocals、inheritableThreadLocals，两个都是ThreadLocal.ThreadLocalMap类型。\nthreadLocals 由ThreadLocal维护其数据的存放和获取。\ninheritableThreadLocals 由InheritableThreadLocal维护其数据的存放和获取。\n每个Thread都有自己的threadLocals、inheritableThreadLocals。ThreadLocal实现线程隔离的原因也在这，即ThreadLocal维护线程的threadLocals中的数据，其get/set也是先借助Thread.currentThread()获取当前线程对象然后对threadLocals操作。\nThreadLocal 1 2 3 4 5 6 7 8 9 10 11 12 13 14  public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); } ThreadLocalMap getMap(Thread t) { return t.threadLocals; } void createMap(Thread t, T firstValue) { t.threadLocals = new ThreadLocalMap(this, firstValue); }   ThreadLocal#get方法解析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T result = (T)e.value; return result; } } return setInitialValue(); } private T setInitialValue() { T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value; } protected T initialValue() { return null; }   ThreadLocalMap的实现 ThreadLocalMap\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  static class ThreadLocalMap { static class Entry extends WeakReference\u0026lt;ThreadLocal\u0026lt;?\u0026gt;\u0026gt; { Object value; Entry(ThreadLocal\u0026lt;?\u0026gt; k, Object v) { super(k); value = v; } } /** * 初始大小 */ private static final int INITIAL_CAPACITY = 16; /** * 大小必须是2的幂 */ private Entry[] table; private void set(ThreadLocal\u0026lt;?\u0026gt; key, Object value) { Entry[] tab = table; int len = tab.length; //这里是最重要的部分 下标的计算，由于threadLocalHashCode是按HASH_INCREMENT递增的，  //所以实际上下标i的值可能出现回头的问题，且前后两次可能会出现空隙，即前一次下标计算是7，后一次计算是14，再下次计算可能就是5了。  //当两次计算的下标一样(比如都是5)怎么办呢？使用nextIndex从当前向后移动一位(即6)，若下标6处没有值则存入这里，若有值则继续下一位，以此循环。  //注意nextIndex的值，当index=len-1时，即达到数组最后以后，nextIndex值返回0，回到从第一位开始找起。  int i = key.threadLocalHashCode \u0026amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) { ThreadLocal\u0026lt;?\u0026gt; k = e.get(); if (k == key) { e.value = value; return; } if (k == null) { replaceStaleEntry(key, value, i); return; } } tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) \u0026amp;\u0026amp; sz \u0026gt;= threshold) rehash(); } private static int nextIndex(int i, int len) { return ((i + 1 \u0026lt; len) ? i + 1 : 0); } }   "
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-jvm/",
	"title": "Java-JVM",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "Java-JVM",
	"content": "JVM 内存分区 JVM在执行Java程序的过程中会把它管理的内存分为：方法区（运行时常量池）、堆、程序计数器、虚拟机栈、本地方法栈、直接内存。\n其中类中声明的成员变量(无论基本类型还是引用类型，无论是引用本身还是值)都存储在堆中，类中声明的静态变量(static修饰)和常量(final修饰)储存在方法区。\n在方法中声明的基本变量(无论是引用本身还是值)都存储在(虚拟机)栈中，声明的引用类型的引用存储在(虚拟机)栈中，值则存储在堆中。\n其中方法区和堆是所有线程共享的内存，程序计数器、虚拟机栈、本地方法栈则是线程私有的内存，即每个线程都有自己的程序计数器、虚拟机栈、本地方法栈。\n直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。直接内存由操作系统管理。\n使用Unsafe和NIO中的ByteBuffer.allocateDirect()创建直接内存。\n在Java堆中可以是directBtyeBuffer对象直接引用。\n直接内存不受Java堆大小限制，但受本机总内存大小限制，可以使用MaxDirectMemorySize设置，默认和堆内存大小一样，所以也会出现OOM。\nJava使用直接内存：\n 减少垃圾回收 直接内存由操作系统关系，无须JVM GC。 提高I/O效率 从堆中向磁盘写数据时，数据会先复制到对外内存，即内核缓冲区，再由OS写入磁盘。使用直接内存避免这个操作。  方法区  类信息 常量 静态变量 即时编译器编译后的代码(运行时编译的)  JDK7及以前方法区使用的是永久代(PermGen)的实现，JDK8及以后使用的是元空(Metaspace)的实现。元空间可以使用机器内存，默认不受限制。而永久代则是受限的，可能会产生OOM。\n常量池 常量池位于方法区，常量池分两种：\n 静态常量池  字面量\n如：String s=\u0026quot;aaa\u0026quot;;，\u0026ldquo;aaa\u0026quot;即是字面量 符号引用\n类、方法的信息，比如类的全限定名：java.lang.String   运行时常量池  在JDK8中运行时的常量池的字符串部分是放在堆中的。\n方法区类卸载的时机\n当满足以下三个条件时类变成可回收状态。\n 类所有的实例都被回收 加载该类的ClassLoader被回收 该类没有被其他任何地方引用。  堆 JVM堆的大小可以使用-Xmx(堆最大上限) -Xms(堆初始内存大小)设置\nJVM堆中存放：\n 对象实例（几乎所有）\n为什么是几乎所有不是全部？见逃逸分析部分。 数组  Java堆是一块连续的内存空间，堆被JVM进一步划分为新生代和老年代，一般设置为1:2。\n 新生代(PSYoungGen)\n可以使用-Xmn设置新生代大小，如：-Xmn20m 设置新生代为20M。\n新生代内又分为Eden/From Survivor/To Survivor，在Hotspot中比例一般是8:1:1。可以使用-XX:SurvivorRatio设置，缺省为8。  Eden空间 From Survivor空间 To Survivor空间   老年代(ParOldGen)  程序计数器 指向当前线程正在执行的字节码指令的地址。程序计数器是JVM中唯一不会OOM的区域。\n虚拟机栈 虚拟机栈中存放的是一个一个的栈帧。栈帧包含：局部变量表、操作数栈、动态链接、完成出口。虚拟机栈的大小是受限的，默认值取决于平台，一般是1M，可以通过-Xss来设置。\n栈帧 JVM中一个栈帧对应一个方法的调用信息。栈帧包含以下四部分：\n局部变量表 \u0026ndash; 用于存放八大基本数据类型和对象的引用\n操作数栈 \u0026ndash; 存放方法的执行、操作的一块临时空间。比如a+b的操作，操作数栈会先读取a，压入局部变量表，再读取b，压入局部变量表，然后执行+操作时从局部变量表中变量a、b读取到操作数栈，然后将ab出栈并执行+操作得到结果c，然后将c压入局部变量表。\n我们常说的JVM是基于栈的指的即是Java的解释执行是在操作数栈完成的。\n动态链接 \u0026ndash; 存放编译时不能确定方法入口的方法的地址，需要在运行时来保证方法调用的正确性。如：多态方法、native方法。当线程中调用到native方法时JVM不会在为其在虚拟机栈中创建栈帧，而是存储动态链接并直接调用native方法。\n完成出口 \u0026ndash; 也叫方法出口/返回地址。\n本地方法栈 本地方法栈保存native方法信息，当一个JVM创建的线程调用native方法后，JVM不再为其虚拟机中创建栈帧，JVM只是简单的动态链接并直接调用native方法。程序计数器也不会去记录。\n虚拟机规范中并没有强制规定本地方法栈的实现，各版本虚拟机也是自由实现，HotSpot则是将本地方法栈和虚拟机栈合二为一了。\nJMM(Java Memory model) JMM，Java内存模型。CPU计算a+b，CPU执行指令(这里是+指令)是很快的，大部分时间耗费在将内存中的a和b读取到CPU上，所以现代计算机出现了高级缓存这一概念来解决这一问题。一般计算机有三级高级缓存，以及缓存速度更高，接近CPU，容量也最小，三级缓存速度相对最低，容量也最大。为了充分利用高速缓存，Java提出了JMM概念。JMM模型将内存分为主内存和工作内存，主内存主要包括通常意义的内存(RAM)，工作内存主要包括CPU寄存器和三级高速缓存。但这不是绝对的，主内存也可能包含\nCPU寄存器和三级高速缓存部分，只是大部分的主内存是在RAM，同样的工作内存也可能包含RAM部分，但大部分是在CPU寄存器和三级高速缓存。\n每个线程都有自己的工作内存，是独享的，线程间的工作内存是相互隔离的，线程不允许直接访问主内存。\nJVM中的对象 JVM对象内存布局  对象头(Header) 对象自身的运行时数据(如锁状态标识、哈希码、GC分代年龄、线程持有的锁、偏向线程ID、偏向时间戳等)、类型指针及对象为数组时记录数组长度的数据 实例数据(Instance Data) 程序代码中定义的各种类型的字段内容 对齐填充 JVM中为了内存划分的便捷性所有对象必须是8字节的整数倍  JVM创建一个对象的过程  类加载 检查加载\n当new对象时，会先检查是否已加载了类信息，如果未加载，则先去执行类加载步骤。 分配内存\n内存分配方式有两种：指针碰撞和空闲链表。JVM中内存的分配也是多线程的。JVM应对多线程分配内存的并发问题使用了：CAS失败重试及本地线程分配缓冲(TLAB)两种方式。本地线程分配缓冲是给分配线程各自分配一块堆空间(一般在Eden区，占Eden空间的1%)，这样相互之间不会产生竞争。 内存空间初始化\n比如将没有赋值的int变量初始化为零值 设置\n对象头的设置。 对象初始化\n调用构造方法执行初始化逻辑。  JVM对象内存分配原则：  优先在新生代Eden空间中分配 大对象直接进入老年代 长期存活的对象进入老年代\n当存活(对象头信息中记录)达到一定年龄（一般为15）会将对象转移到老年代 动态年龄判断\n当复制过程中内存不足(如To Survivor空间不足以存放所有对象)时，不管对象年龄是否达到要求(15)年龄都会转移到老年代。 老年代做分配担保\n当将对象从新生代移动到老年代时乐观认为老年代空间足够，先不要触发GC，当老年代确实空间不足时触发Full GC。  JVM对象分配策略  逃逸分析是否可以栈上分配对象 根据JVM对象内存分配原则分配  JVM对象的访问定位 JVM规范中访问对象有两种方式：\n 句柄\n句柄方式中，JVM堆中有一个句柄池，引用通过指向句柄池中的某个句柄(句柄中包含一个对象实例指针和一个对象类型指针)间接指向对象实例数据和方法区中的对象类型数据。句柄的好处是对象地址改变不用修改引用指向的地址，坏处也显而易见。 直接指针\n主流JVM，如Hotspot使用的方式。对象引用直接指向对象实例数据，对象实例头中有指向对象类型的指针。  JVM对象的生命周期  创建阶段(Created) 应用阶段(In Use) 不可见阶段(Invisible) 不可达阶段(Unreachable) 收集阶段(Collected) 终结阶段(Finalized) 对象空间重分配阶段(De-allocated)  Java类的生命周期  加载\n加载阶段JVM主要完成三件事：1.通过类的全限定名获取类的二进制字节流 2.将字节流所代表的静态存储结构转化为方法区的运行时数据结构 3.在Java堆中生成一个代表这个类的Class对象作为方法区类数据的访问入口 验证 准备 解析 初始化 使用 卸载  逃逸分析 逃逸分析是目前JVM中比较前沿的优化技术，它不是直接的优化手段而是为其他优化手段提供依据的分析技术。逃逸分析的基本行为就是分析对象动态作用域。\n-XX:+DoEscapeAnalysis：启用逃逸分析(默认打开)\n-XX:+EliminateAllocations：标量替换(默认打开)\n-XX:+UseTLAB 本地线程分配缓冲(默认打开)\n当开启逃逸分析时，如果一个方法中声明的对象并没有在方法作用域外使用，逃逸分析检测到后会优化，将该对象分配到栈上。例如：\n1 2 3 4 5 6 7 8 9  public void xx(){ Person p = new Person(); p.name=\u0026#34;张三\u0026#34; } public void yy(){ for(int i = 0;i \u0026lt; 100000000;i++){ xx(); } }   如果开启逃逸分析p对象可能会被分配到栈上，逃逸分析优化认为p对象不会被其他线程或外部变量使用，没必须要分配在共享区堆上。栈内存不需要垃圾回收，执行完毕自动出栈释放内存。\nGC GC的对象主要是共享的对象，如：堆、方法区、元空间，主要是堆。一般是内存不足时触发GC，发生在新生代的GC称为Minor GC，发生在老年代的GC称为Full GC\nGC判断对象是否存活有两种方式：\n 引用计数\nJVM早期使用的算法。即每次对象被引用，该对象的引用计数+1，这种设计相对简单，但引用计数很难判断相互引用(A引用B，B引用A)的的情况对象是否应该回收。\nPHP/Python还在使用这种方式。 可达性分析\n主流JVM中使用的方式。\n是否可以到达GC Roots。Java中可作为GC Roots的对象包括：  方法区中静态变量和常量的对象 虚拟机栈(本地变量表)中的对象 1 2 3 4 5 6  public void xx(){ List\u0026lt;Object\u0026gt; gcr = new ArrayList\u0026lt;\u0026gt;; while(true){ gcr.add(new Object()) } }   gcr存在与虚拟机栈的本地变量表中，在xx方法执行的过程中gcr是GC Roots对象。\n 本地方法栈JNI(Native方法)中的对象。    GC回收算法  复制算法(Coping)\n实现简单，运行高效，没有内存碎片，但空间利用率只有一半。\n新生代使用的GC算法\n研究表明98%的内存对象是朝生夕死的(这也是为什么一般新生代的Eden：From Survivor：To Survivor=8:1:1)，所以并不需要按1:1划分内存，而是将内存划分为一块较大的内存Eden空间和两块Survivor空间。当内存回收时将Eden和其中一块Survivor(此时称做From Survivor)空间存活的对象复制到另一块Survivor(此时称做To Survivor)空间，最后清理掉Eden和From Survivor空间。每次对象被复制到From或To区，对象年龄+1。当From或To区空间不足时将对象直接移动到老年代。 标记-清除算法(Mark-Sweep)\n执行效率不稳定，内存碎片导致提前GC。 标记-整理算法(Mark-Compact)\n针对标记-清除算法碎片的问题，提出了标记-整理算法。标记-整理算法的会有对象的移动、引用更新、用户线程暂停，但没有内存碎片。  一般虚拟机的回收并不使用某个单一算法，而是多种算法一起使用。一般新生代回收器使用复制算法，老年代回收器使用标记-清除或标记整理算法。\nGC收集器  单线程垃圾收集器 多线程并行垃圾收集器 多线程并发垃圾回收器  CMS和G1垃圾收集器 CMS的缺点：\nCPU敏感、浮动垃圾、内存碎片。\n引用类型 Java引用分为四种类型：\n 强引用\n即平时使用的引用方式 软引用(SoftReference)\n内存不足时若发现一个对象只有软引用则回收该对象。 弱引用(WeakReference)\nGC时如果发现一个对象只有弱引用指向该对象则回收该对象。弱引用的使用场景：  偶尔使用又想随时使用的对象。 不想介入该对象的声明周期。   虚引用(PhantomReference)\n随时可能被回收，回收时会通知。虚引用配合引用队列(ReferenceQueue)，当垃圾回收器回收对象时或者通知。虚引用的get永远返回的是null。当一个对象准备回收时如果它还有虚引用，那么它的虚引用会被放到与之关联的引用队列。所以可以判断引用队列如果有这个对象的虚引用则表示该对象要被回收了。 1 2 3 4 5 6 7 8 9  Object obj = new Object(); ReferenceQueue\u0026lt;Object\u0026gt; rq = new ReferenceQueue\u0026lt;\u0026gt;(); PhantomReference\u0026lt;Object\u0026gt; pf = new PhantomReference\u0026lt;\u0026gt;(obj, rq); obj = null; System.out.println(\u0026#34;obj:\u0026#34; + obj);//null System.out.println(\u0026#34;pfObject:\u0026#34; + rq.poll());//null System.gc(); Thread.sleep(2000); System.out.println(\u0026#34;pfObject:\u0026#34; + rq.poll());//not null     内存分配中的指针碰撞和空闲链表及并发下的CAS 失败重试\nhttps://blog.csdn.net/zhaohong_bo/article/details/89419480\n软引用、弱引用、虚引用-他们的特点及应用场景\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-string/",
	"title": "Java-String",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "Java-String",
	"content": "占坑，敬请期待\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12  //先去字符串常量池中查看是否有\u0026#34;ab\u0026#34;，如果有，返回\u0026#34;ab\u0026#34;对象的引用，如果没有创建\u0026#34;ab\u0026#34;对象放入字符串常量池，然后返回\u0026#34;ab\u0026#34;对象的引用。 String str = \u0026#34;ab\u0026#34;;//创建0或1个对象 //先创建了\u0026#34;ab\u0026#34;对象放入字符串常量池，然后创建String对象，String对象的char数组引用指向字符串常量池中的\u0026#34;ab\u0026#34;对象。 String str1 = new String(\u0026#34;ab\u0026#34;);//创建1或2个对象 //先创建了\u0026#34;ab\u0026#34;对象，然后创建了\u0026#34;abcd\u0026#34;对象，最后创建\u0026#34;abcdef\u0026#34;对象。 String str2 = \u0026#34;ab\u0026#34; + \u0026#34;cd\u0026#34; + \u0026#34;ef\u0026#34;;//创建3个对象。  //intern表示如果已经有指向\u0026#34;abc\u0026#34;的String对象，则不创建新的String对象直接返回这个String对象 //这里str3==str4，两者指向同一String对象。 String str3 = new String(\u0026#34;abc\u0026#34;).intern(); String str4 = new String(\u0026#34;abc\u0026#34;).intern();   "
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bjuc%E4%B8%80/",
	"title": "Java-多线程之JUC(一)",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "Java-多线程之JUC(一)",
	"content": "JUC JUC是Java中的一个规范，实现主要位于java.util.concurrent包下。AtomicXXX、Lock、BlockingQueue、BlockingDeque、ConcurrentXXX、ThreadFactory、ThreadPoolExecutor等相关类都在这个包下，都是和多线程相关的。\nCAS(Compare And Swap) CAS，名字上看是比较和交换，实际上就是原子操作。是指在内存分配时会将记录旧值并和内存中的值比较，只有相同时才会给内存赋值，这样保证线程安全性。比如分配内存是会检查分配的内存是不是null，运行过程中检查内存值是不是和旧值相同。\n原子操作是不可再分的操作，比如被synchronized标识的代码块即是一个原子操作。\n原理 \u0026ndash; 利用现代处理器都支持的CAS指令，循环这个指令直到成功。\nCAS没有阻塞，不涉及上下文切换，因此一般效率比synchronized更高。但当有很多线程同时竞争特别激烈时CAS(由于自旋问题)效率可能会比synchronized低。\nCAS问题  循环时间长开销大。\n自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。 只能保证一个共享变量的原子操作  ABA问题 CAS操作中，thread1、thread2、thread3同时修改内存变量x，其中thread1、thread2将内存变量x从A修改成B，再修改成A，thread3无法感知内存变量x的变化。ABA问题一般不影响程序运行的正确性。Java给我们提供了解决ABA问题的方法(给变量加版本)：AtomicMarkableReference-记录是否被修改过\nAtomicStampedReference-记录是否被修改过，修改过几次\nAQS(AbstractQueuedSynchronizer) AbstractQueuedSynchronizer使用了模版方法设计模式。底层大量使用了CAS和LockSupport实现多线程问题。AQS有一个重要变量state，使用它来设置当前同步(锁)的状态，state和setExclusiveOwnerThread配合实现获取锁和释放锁的逻辑。\nsetExclusiveOwnerThread 设置当前拥有独占访问权限的线程。\nCLH队列锁 AQS的基本思想是基于CLH队列锁的。每个等待拿锁的线程包装成一个Node(Node中包括线程本身和前一个节点指针)加入到队列中，每个Node节点的线程回去检测前一个节点的线程是否释放了锁，如果释放了锁，当前节点的线程就可以拿到这个锁。\nJMM(Java Memory model) JMM，Java内存模型。CPU计算a+b，CPU执行指令(这里是+指令)是很快的，大部分时间耗费在将内存中的a和b读取到CPU上，所以现代计算机出现了高级缓存这一概念来解决这一问题。一般计算机有三级高级缓存，以及缓存速度更高，接近CPU，容量也最小，三级缓存速度相对最低，容量也最大。为了充分利用高速缓存，Java提出了JMM概念。JMM模型将内存分为主内存和工作内存，主内存主要包括通常意义的内存(RAM)，工作内存主要包括CPU寄存器和三级高速缓存。但这不是绝对的，主内存也可能包含\nCPU寄存器和三级高速缓存部分，只是大部分的主内存是在RAM，同样的工作内存也可能包含RAM部分，但大部分是在CPU寄存器和三级高速缓存。\n每个线程都有自己的工作内存，是独享的，线程间的工作内存是相互隔离的，线程不允许直接访问主内存。\nCPU核心数和最大支持同时运行线程数的关系 CPU分为物理CPU和逻辑CPU，如果物理CPU不支持超线程技术，那么一个物理CPU核就等于一个逻辑CPU核，如果物理CPU支持超线程技术，那么一个物理CPU核等于两个逻辑CPU核。一个逻辑CPU核同时只能运行一个线程。因此支持超线程技术时CPU可以同时运行两倍于物理CPU核心数的线程。\n超线程技术(Hyper—Threading Technology，HTT) 超线程技术就是利用特殊的硬件指令，把两个逻辑内核模拟成两个物理芯片，让单个处理器都能使用线程级并行计算．具体讲，就是通过CPU的寄存器构成了两个逻辑处理器，来共享处理器的物理执行单元，并同步进行加、乘、负载等操作．操作系统或者应用软件的多线程可以同时运行于一个HTT处理器上，两个逻辑处理器共享一组处理器执行单元，并行完成加、乘、负载等操作，这样就可以使得运行性能提高。\n在处理多个线程的过程中，多线程处理器内部的每个逻辑处理器均可以单独对中断做出响应，当第一个逻辑处理器跟踪一个软件线程时，第二个逻辑处理器也开始对另外一个软件线程进行跟踪和处理了．另外，为了避免CPU处理资源冲突，负责处理第二个线程的那个逻辑处理器，其使用的是仅是运行第一个线程时被暂时闲置的处理单元．例如：当一个逻辑处理器在执行浮点运算(使用处理器的浮点运算单元)时，另一个逻辑处理器可以执行加法运算(使用处理器的整数运算单元)．这样做，无疑大大提高了处理器内部处理单元的利用率和相应的数据、指令的吞吐能力。\nCPU时间片轮转机制(RR调度) RR(Round-Robin)调度主要用于分时系统中的进程调度。为了实现轮转调度，系统把所有就绪进程按先入先出的原则排成一个队列。新来的进程加到就绪队列末尾。每当执行进程调度时，进程调度程序总是选出就绪队列的队首进程，让它在 CPU 上运行一个时间片的时间。时间片是一个小的时间单位，通常为 10~100ms 数量级。当进程用完分给它的时间片后，系统的计时器发出时钟中断，调度程序便停止该进程的运行，把它放入就绪队列的末尾；然后，把 CPU 分给就绪队列的队首进程，同样也让它运行一个时间片，如此往复。RR调度算法的性能很大程度取决于时间片的大小。\n在 RR 调度算法中，没有进程可以被连续分配超过一个时间片的 CPU（除非它是唯一可运行的进程）。如果进程的 CPU 执行超过一个时间片，那么该进程会被抢占，被放回到就绪队列队尾。因此，RR调度算法是抢占的。\nRunnable Callable Future Runnable \u0026ndash; 线程调度任务接口，没有返回值，无法抛异常\nCallable \u0026ndash; 有返回结果，可以抛异常。不能直接被线程调用，所以一般使用继承了Runnable接口的FutureTask将Callable包装起来给Thread使用。ExecutorService.submit(Callable task)就是这样操作的。\nFuture \u0026ndash; 保存异步计算的结果,可以在我们执行任务时去做其他工作。一般是用来和Callable配合使用的，用于获取Callable的结果。\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/",
	"title": "Java注解详解",
	"tags": ["java"],
	"categories": [],
	"series": [],
	"description": "Java注解详解",
	"content": "前言 Java注解是JDK5提供的，用于为代码提供元数据。注解不直接影响代码执行。\n注解也是接口类型。即反射时：annotationClass.isInterface = true\nJava注解包含一种特殊的注解：元注解\n元注解 元注解是注解到注解上的注解，是定义注解时必需的。\nJDK中的元注解有5个：@Retention、@Documented、@Target、@Inherited、@Repeatable\n  @Retention\n自定义注解的存活期，取值：\n RetentionPolicy.SOURCE 只存在源码阶段，编译器将java源码编译成class文件时将被忽略丢弃。你可能会问只在源码阶段存在的注解有什么用？用来注释提醒？编译器在将java源码编译成class时会去掉这类注解，但这个过程中注解还是存在的，而APT的处理也发生在这一时期，即APT可以处理生存期为RetentionPolicy.SOURCE的注解。 RetentionPolicy.CLASS 自定义注解Retention的默认值，这类注解会被编译到class文件，但不会被JVM加载。你可能又会问不被JVM加载只存在与class文件中有什么用？我们又不能操作class文件？事实上开发人员并不是完全不能操作class文件，比如ASM。RetentionPolicy.CLASS通常用于定制开发编译过程的人使用，比如在Android中class会被再次编译成dex文件。查看Android中RetentionPolicy.CLASS的注解有很多：@UnsupportedAppUsage、@DoNotCall、@ColorInt、@ColorRes、@NonNull等。 RetentionPolicy.RUNTIME 注解保留到运行期，会被JVM加载，运行期可以使用反射获取。    @Target\n注解使用的地方，可以多选。\n ElementType.TYPE 用于类、接口、枚举 ElementType.FIELD 用于字段 ElementType.METHOD 用于方法 ElementType.PARAMETER 用于方法参数 ElementType.CONSTRUCTOR 用于构造方法 ElementType.LOCAL_VARIABLE 用于局部变量 ElementType.ANNOTATION_TYPE 用于注解 ElementType.PACKAGE 用于包 ElementType.TYPE_PARAMETER 用于范型参数，JDK8提供 ElementType.TYPE_USE 用于类型(范型类型前、类、参数类型前、接口等)，JDK8提供    @Documented\n被@Documented声明的注解所注解的元素会被javadoc工具提取成文档。\n  @Inherited\n被@Inherited声明的注解所注解的超类可以被子类继承这个注解。\n  @Repeatable\nJDK8提供，可重复的注解，即该注解可以在同一个地方多次使用。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @interface Values { Value[] value(); } @Repeatable(Values.class) @interface Value { String value() default \u0026#34;\u0026#34;; } @Value(\u0026#34;11\u0026#34;) @Value(\u0026#34;22\u0026#34;) class RepeatableTest{ }     反射注解相关API  clazz.isAnnotation();\nclazz是否时注解类型 clazz.isAnnotationPresent(Class\u0026lt;? extends Annotation \u0026gt; annotationClass);\nclazz类上是否有annotationClass类型的注解 clazz.getAnnotation(Class\u0026lt;A\u0026gt; annotationClass);\n获取clazz类上annotationClass类型的注解 clazz.getAnnotationsByType(Class\u0026lt;A\u0026gt; annotationClass);\nJDK8提供，和clazz.getAnnotation(Class\u0026lt;A\u0026gt; annotationClass)的区别是该方法检测注解是否是Repeatable类型的注解，如果是一个或多个该类型的注解。 clazz.getAnnotations();\n返回clazz类的所有注解  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/",
	"title": "Java线程池详解",
	"tags": ["java"],
	"categories": [],
	"series": ["java"],
	"description": "Java线程池详解",
	"content": "简介 Java自带线程池 newCachedThreadPool 不固定线程数量(最大支持Integer.MAX_VALUE)的可缓存线程池\n 线程数无限制(Integer.MAX_VALUE)。 有空闲线程则复用空闲线程，若无空闲线程则新建线程。 一定程序减少频繁创建/销毁线程，减少系统开销。  newFixedThreadPool 一个固定线程数量的线程池。\n 可控制线程最大并发数(同时执行的线程数)。 超出的线程会在队列中 等待  newSingleThreadExecutor 单线程的线程池\n 有且仅有一个工作线程执行任务。 所有任务按照指定顺序执行，即遵循 队列的入队出队规则。  newScheduledThreadPool 支持定时以指定周期循环执行任务。不同于newCachedThreadPool、newFixedThreadPool、newSingleThreadExecutor是对ThreadPoolExecutor的不同配置，newScheduledThreadPool则是对ScheduledThreadPoolExecutor的配置。\n线程池原理 从数据结构的角度来看，线程池主要使用了阻塞队列(BlockingQueue)和HashSet 集合构成。 从任务提交的流程角度来看，对于使用线程池的外部来说， 线程池的机制是这样的:\n1、如果正在运行的线程数 \u0026lt; coreSize，马上创建核心线程执行该 task，不排队等待;\n2、如果正在运行的线程数 \u0026gt;= coreSize，把该 task 放入阻塞队列;\n3、如果队列已满 \u0026amp;\u0026amp; 正在运行的线程数 \u0026lt; maximumPoolSize，创建新的非核心线程执行该 task;\n4、如果队列已满 \u0026amp;\u0026amp; 正在运行的线程数 \u0026gt;=maximumPoolSize，线程池调用RejectedExecutionHandler的reject方法拒绝本次提交。\nThreadPoolExecutor shutdown()\nshutdownNow()\nCPU密集型 corePoolSize可以设置为0，maximumPoolSize一般设置为cpu核心数，或者cpu核心数+1。操作系统中磁盘可能作为虚拟内存使用，当线程使用的数据在虚拟内存中，操作系统需要将虚拟内存中的数据读取到内存中，这个过程会进入页缺失状态，当数据从磁盘读取到内存后线程会被再次唤醒执行，为了可能的这种情况仍然充分利用cpu，所以可以+1。\nI/O密集型 maximumPoolSize一般设置为cpu核心数*2，或者cpu核心数*2+1。\nRejectedExecutionHandler RejectedExecutionHandler是一个接口，Java中有四种实现：\nAbortPolicy 抛出异常，Java线程池默认策略\nCallerRunsPolicy 由提交线程任务的线程执行\nDiscardOldestPolicy 丢弃队首的线程任务\nDiscardPolicy 丢弃新提交的任务\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-%E8%8C%83%E5%9E%8B%E4%B8%8E%E5%8F%8D%E5%B0%84/",
	"title": "Java范型与反射",
	"tags": ["java"],
	"categories": [],
	"series": [],
	"description": "Java范型与反射",
	"content": "前言 泛型 ？ extends X 表示类型的上界，类型参数是X的子类\n？ super X 表示类型的下界，类型参数是X的超类\n示例一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  class Generic\u0026lt;T\u0026gt; { T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } class SubGeneric extends Generic\u0026lt;CharSequence\u0026gt; { } Generic\u0026lt;?\u0026gt; generic = new Generic\u0026lt;\u0026gt;(); Generic\u0026lt;?\u0026gt; generic1 = new SubGeneric\u0026lt;\u0026gt;(); SubGeneric generic2 = new SubGeneric(); generic.setData(\u0026#34;\u0026#34;);//报错 generic1.setData(\u0026#34;\u0026#34;);//报错 generic2.setData(\u0026#34;\u0026#34;);//OK   以上都可以调用get方法，但使用非具体泛型父类的实例却不能使用set方法，因为setData可能有重载而此时我们不能确定具体执行的是那个。\n虚拟机泛型的实现 泛型思想早在C++语言的模板（Template）中就开始生根发芽，在Java语言处于还没有出现泛型的版本时，只能通过Object是所有类型的父类和类型强制转换两个特点的配合来实现类型泛化。，由于Java语言里面所有的类型都继承于java.lang.Object，所以Object转型成任何对象都是有可能的。但是也因为有无限的可能性，就只有程序员和运行期的虚拟机才知道这个Object到底是个什么类型的对象。在编译期间，编译器无法检查这个Object的强制转型是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多ClassCastException的风险就会转嫁到程序运行期之中。\n泛型技术在C#和Java之中的使用方式看似相同，但实现上却有着根本性的分歧。\nC#里面泛型无论在程序源码中、编译后的IL中（Intermediate Language，中间语言，这时候泛型是一个占位符），或是运行期的CLR中，都是切实存在的，List＜int＞与List＜String＞就是两个不同的类型，它们在系统运行期生成，有自己的虚方法表和类型数据，这种实现称为类型膨胀，基于这种方法实现的泛型称为真实泛型。\nJava语言中的泛型则不一样，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（Raw Type，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList＜int＞与ArrayList＜String＞就是同一个类，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。\n什么是原始类型？什么是类型擦除？看下面示例\n示例一 无限定的泛型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //Java定义 class Generic\u0026lt;T\u0026gt; { T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } //Generic\u0026lt;T\u0026gt;的原始类型 class Generic { Object data; public Object getData() { return data; } public void setData(Object data) { this.data = data; } }   示例二 有限定的泛型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //Java定义 class Generic\u0026lt;T extends CharSequence\u0026gt; { T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } //Generic\u0026lt;T extends CharSequence\u0026gt;的原始类型 class Generic { CharSequence data; public CharSequence getData() { return data; } public void setData(CharSequence data) { this.data = data; } }   示例二 多重限定的泛型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  //Java定义 class Generic\u0026lt;T extends CharSequence\u0026amp;Comparable\u0026gt; { T data; public T getData() { return data; } public void setData(T data) { this.data = data; } } //Generic\u0026lt;T extends CharSequence\u0026gt;的原始类型 class Generic { CharSequence data; public CharSequence getData() { return data; } public void setData(CharSequence data) { this.data = data; } }   对于多重限定的泛型其原始类型即是第一限定类型，编译器会在必要时向第一限定CharSequence插入强制转换(成Comparable)，所以为了提高效率应把标签接口(如Serializable、Cloneable等)放在多重限定的末尾。\n反射 反射API解析 "
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-camerax/",
	"title": "Jetpack-CameraX",
	"tags": ["android", "jetpack", "camera", "media"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack-CameraX",
	"content": "一、camera2 CameraX是Jetpack对camera2功能的封装，并可向后兼容至 Android 5.0（API 级别 21）\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/jvmdalvikart/",
	"title": "JVM/Dalvik/ART",
	"tags": ["android", "java"],
	"categories": [],
	"series": ["编程基础"],
	"description": "JVM/Dalvik/ART理解",
	"content": "前置知识 Android中每个应用都对应一个单独的虚拟机，独立运行\nJIT\u0026amp;AOT  JIT，Just-in-time，即时编译，运行时动态编译。在运行时将频繁运行的代码(热点代码)编译成机器码。 AOT，Ahead Of Time，提前编译，运行前(安装时)编译成机器码。应用在安装的时候会启动 dex2oat 把dex预编译成ELF文件，以后运行程序的时候不用重新编译，因此应用启动更快、运行更快、体验更流畅、触感反馈更及时  JIT缺点：\n由于JIT是运行时动态编译，虽然可以对执行次数频繁的dex代码进行一定优化，但运行时编译成机器码仍然更消耗cpu，更耗电\nAOT缺点：\n应用安装和系统升级之后的应用优化比较耗时（重新编译，把程序代码转换成机器语言）优化后的文件会占用额外的存储空间\nclass\u0026amp;dex class和dex都是8位字节的二进制流文件，但相比class，dex(Dalvik executable)去掉了class文件中很多冗余信息，数据排列也紧密，并将很多class文件整合到dex文件中，减少了IO操作，提高了类的查找速度，dex把所有class文件的header头(包含JDK)写成了一个,所有的常量放在一个池里, dex文件只维护了一个索引。总的来说dex更适合内存和处理器速度有限的系统。\n其他 dexopt 对dex文件进行验证和优化，经过验证和优化后的dex变为odex文件。\ndex2oat 在安装时对dex文件进行dexopt后再将odex进行AOT操作编译成oat可执行文件(机器码)\nodex(Optimized dex) 是Dalvik环境中使用dexopt对dex文件根据当前ROM特性优化后生成odex文件，优化后的odex文件存在手机的data/dalvik-cache目录下\noat(Optimized Android file Type) ART环境下dex经过dex2oat处理过后的文件，.oat中的文件是ELF文件。ELF ELF文件是UNIX系统实验室（USL）作为应用程序二进制接口（Application Binary Interface，ABI）而开发和发布的，也是Linux的主要可执行文件格式。\ndata/app 安装目录 安装时会把apk文件copy到这里\ndata/dalvik-cache 如上述描述中的存放.dex(.odex 无论davilk的dex 还是art的oat格式)\ndata/data/pkg/ 存放应用程序的数据\nJVM\u0026amp;Dalvik\u0026amp;ART JVM  基于栈的的虚拟机，即JVM的指令集是基于栈的。 将java源文件编译成class字节码文件，多class文件运行在虚拟机上  java-\u0026gt;class-\u0026gt;虚拟机运行\nJVM在运行的时候为每一个类装载字节码\nDalvik  基于寄存器(并非CPU寄存器，而是虚拟寄存器)的虚拟机,即Dalvik VM(的指令集)是基于寄存器(指令集)的。相对于堆栈模式加载速度更快 将java源文件编译成class字节码文件，再由dex.bat编译成一个dex文件(后来因为65535问题有了MultiDex方案，将原来的一个dex拆分为多个dex文件)运行在虚拟机上 Dalvik下应用需要解释执行，常用热点代码在运行时通过即时编译器(JIT)将字节码转换成机器码 相比JVM，Dalvik更适合低内存低cpu运行  ART Android4.4发布ART，此时Dalvik和ART共存，用户可以手动选择，Android5.0废弃DVM，只使用ART，ART和Dalvik的主要区别是ART采用了AOT技术，安装时将字节码编译成机器码，另外ART还对GC过程的也进行了改进，GC 保持暂停状态期间并行处理，在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短，Android7.0以前只使用AOT方式，但Android7.0及后AOT和JIT共存，安装时dex不会再被编译成机器码，App运行时dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息，手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译\nAndroid ClassLoader  BootClassLoader\n用于加载Android Framework层class文件。 PathClassLoader\n用于Android应用程序类加载器，PathClassLoader的parent是BootClassLoader。可以加载指定的dex，以及jar、zip、apk中的classes.dex。 DexClassLoader\n加载指定的dex，以及jar、zip、apk中的classes.dex InMemoryDexClassLoader\nAndroid 8.0提供，用于加载内存中的dex文件。  参考：\n Dalvik和Art,JIT ,AOT, oat, dex, odex Dalvik,ART与ODEX相爱相生  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/kotlin-%E5%8D%8F%E7%A8%8B/",
	"title": "Kotlin协程",
	"tags": ["kotlin", "协程"],
	"categories": [],
	"series": [],
	"description": "Kotlin协程",
	"content": "协程中又一个概念CPS(Continuation Passing Style)\n协程是用户态的行为类似线程的库\n用户态：不想线程在用户态和内核态切换\n类似线程：只是行为类似\n库：协程本质上是一个用线程次调度代码块的库\n可能你会问 没看到线程调度啊 这事编译器字节码操作\n解决线程问题由最开始的代码层面的锁如java中的lock,到一些以node.js为代表的单线程异步回调，异步回调的方式引起Callback hell,再到协程，协程使用状态机处理不同的挂起点，避免了Callback hell\n 线程 actor 协程 协程可以理解为一段代码片段，Kotlin中的协程是利用编译器操作字节码实现的，本质上在利用线程池来切换协程代码片段,协程遇到阻塞会yiel让出cpu并保存上下文,resume恢复的时候恢复上下文  java中的lock避免了锁消耗\nactor和协程的优势是没有锁消耗且切换不想线程那样需要在用户态和内核态切换\n先阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。他们的核心思想是一样的，遇到需要进行I/O操作的地方，就直接让出CPU资源，然后注册一个回调函数，其他逻辑则继续往下走，I/O结束后带着结果向事件队列里插入执行结果，然后由事件调度器调度回调函数，传入结果。这时候执行的地方可能就不是你原来的代码区块了，具体表现在代码层面上，你会发现你的局部变量全部丢失，毕竟相关的栈已经被覆盖了，所以为了保存之前的栈上数据，你要么选择带着一起放入回调函数里，要么就不停的嵌套，从而引起反人类的Callback hell。\n因此相关的Promise，CompletableFuture等技术都是为解决相关的问题而产生的。但是本质上还是不能解决业务逻辑的割裂\n相比于callback接口回调的异步框架，Coroutine这个暂停和恢复在没有JVM支持下，比较难以理解，是怎么做到的？有没有什么魔法？其实JVM中Coroutine的实现方式有很多(implementing-coroutines-in-java)，Quasar Fiber则是通过字节码修改技术在编译或载入时织入必要的上下文保存/恢复代码，通过抛异常来暂停，恢复的时候根据保存的上下文(Continuation),恢复jvm的方法调用栈和局部变量,Quasar Fiber提供相应的Java类库来实现,对应用有一定的侵入性(很小)\nQuasar Fiber 主要有 Instrument + Continuation + Scheduler几个部分组成\nInstrument 做一些代码的植入，如park前后上下文的保存/恢复等\nContinuation 保存方法调用的信息，如局部变量，引用等,用户态的stack,这个也是跟akka等基于固定callback接口的异步框架最大的区别\nScheduler 调度器，负责将fiber分配到具体的os thread执行\n参考：\n 次时代Java编程（一）：Java里的协程 Coroutine in Java - Quasar Fiber实现 深入理解JVM - Java内存模型与线程 - 第十二章 Java线程中wait状态和block状态的区别? 用户态和内核态的理解和区别 Java中的锁分类 协程  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/linux%E5%91%BD%E4%BB%A4%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E8%AF%A6%E8%A7%A3/",
	"title": "Linux命令详解",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "Linux命令详解",
	"content": "占坑，敬请期待\u0026hellip;\n权限 ls -l\ndrwxr-xr-x 5 dscao staff 160 12 27 07:00 blog -rw-r--r-- 1 dscao staff 26044 8 16 2019 package-lock.json ... drwxr-xr-x 5 dscao staff 160 12 27 07:00 blog的含义是：当前staff用户组的用户dscao对blog文件夹具有读、写、执行权限，用户组staff的其他用户对blog文件夹具有读、执行的权限，其他用户对blog文件夹具有读、执行的权限。\ndrwxr-xr-x可以拆分为三部分:d、rwx、r-x、r-x，第一位d表示是一个文件夹，如果第一位是-则表示是文件，后面的三位一组，分别表示当前用户对这个文件(夹)拥有的权限，当前用户所在用户组对这个文件(夹)拥有的权限，其他所有用户对这个文件(夹)拥有的权限。权限以读、写、执行的顺序排列，如rwx，r表示读权限，w表示写权限，x表示执行权限，如果没有这个权限则用-代替。\n   权限 二进制数字 八进制数字     --- 000 0   --x 001 1   -w- 010 2   -wx 011 3   r-- 100 4   r-x 101 5   rw- 110 6   rwx 111 7    chmod用于修改文件(夹)权限。\nchmod 777 表示当前用户、当前用户所在用户组其他的用户、当前用户所在用户组之外的其他的所有用户拥有权限都是7，即：最该权限，rwx权限。\nchmod u+x 表示给当前用户添加x(执行)权限。\nchmod +x或chmod a+x表示给所有用户添加x(执行)权限。\nchmod u-x 表用取消当前用户的x(执行)权限\n更多详细权限命令参见4.3. 权限\nB Shell和C Shell ps | grep system_server \ngrep是通过通配符进行匹配过滤的命令，“|”是Unix上的管道命令。即将前一个命令的输出给下一个命令作为输入。如果这里我们不加“ | grep xxx”，那么将看到前一个命令的完整输出。\n参考：\n 4.3. 权限  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/macos%E4%BD%BF%E7%94%A8charles%E6%8A%93%E5%8C%85app%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82/",
	"title": "macOs使用Charles抓包App网络请求",
	"tags": ["android", "其他"],
	"categories": [],
	"series": [],
	"description": "Charles抓包App https网络请求",
	"content": "安装 Charles4.5.6\u0026amp;macOS10.14.5，安装-\u0026gt;找注册账号或破解\n配置 Help -\u0026gt; SSL Proxying -\u0026gt; Install Charles Root Certificate然而并不成功，不能导进macOS钥匙串\n选择Save Charles Root Certificate保存证书再手动导入macOS钥匙串，双击选择信任\nHelp -\u0026gt; SSL Proxying -\u0026gt; Install Charles Root Certificate on a Mobile Device or Remote Browser按要求设置手机代理并打开浏览器下载证书\n安装下载的证书\nProxy -\u0026gt; SSL Proxying Setting 设置SSL Proxying包含的地址，可以通配符\n打开APP网络请求报错：java.security.cert.CertPathValidatorException: Trust anchor for certification path not found\n需要AndroidManifest配置android:networkSecurityConfig=\u0026rdquo;@xml/network_security_config\u0026rdquo;\nnetwork_security_config.xml\n1 2 3 4 5 6 7 8  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;network-security-config xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;debug-overrides\u0026gt; \u0026lt;trust-anchors\u0026gt; \u0026lt;certificates src=\u0026#34;user\u0026#34; /\u0026gt; \u0026lt;/trust-anchors\u0026gt; \u0026lt;/debug-overrides\u0026gt; \u0026lt;/network-security-config\u0026gt;    断点 Breakpoint Setting Map Local/Map remote本地/远程数据模拟Response Throttle Setting模拟弱网环境\nRound-trip latency 往返延迟\nMTU传输数据包的最大尺寸    "
},
{
	"uri": "https://dshcao.github.io/zh/tags/media/",
	"title": "media",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/mr/",
	"title": "mr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/pdf/",
	"title": "pdf",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/rxjava/",
	"title": "rxjava",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/rxjava/",
	"title": "rxjava",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/rxjava2%E6%BA%90%E7%A0%81%E5%8F%8A%E4%BD%BF%E7%94%A8/",
	"title": "RxJava2源码及使用",
	"tags": ["java", "rxjava", "android"],
	"categories": [],
	"series": ["源码解析", "rxjava"],
	"description": "RxJava2源码及使用",
	"content": "前言 RxJava是一个响应式的异步事件流编程库。\nRxJava的优势：\n函数式编程，代码逻辑清晰，优雅\n避险回调地狱\n方便的线程调度\nRxJava中主要使用了观察者(订阅者)模式和装饰模式。\n观察者模式vs发布订阅模式 观察者模式 完整的观察者模式有四个部分：\n  抽象被观察者\n可以增加/删除观察者\n当数据状态改变可以通知观察者\n1 2 3 4 5  interface Observable{ void add(Observer o); void remove(Observer o); void change(); }     抽象观察者\n定义一个一个接口当被观察这数据状态改变时可以通知自己\n1 2 3  interface Observer{ void onChange(); }     具体被观察者\n定义一个集合保存或有观察者引用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  class MyObservable{ boolean change = false; List\u0026lt;Observer\u0026gt; observers = new Arraylist\u0026lt;\u0026gt;; public void add(Observer o){ observers.add(o); } public void remove(Observer o){ observers.remove(0); } public void nofifyObservers(){ if(!hasChange()){ return; } for(Observer o:observers){ o.onChange(); } } public boolean hasChange(){ return change; } public void publish(String message){ ... change = true; nofifyObservers(); } }     具体观察者\n具体实现接收到通知的业务逻辑\n1 2 3 4 5  class MyObserver{ public void onChange(){ //业务逻辑  } }     发布订阅模式 RxJava使用的模式。\n发布订阅模式很像观察者模式，但和一般的观察者模式有一些区别。观察者模式中被观察者持有观察者的引用，当数据状态改变是通过观察者引用回调通知观察者。而发布订阅模式是发布者将数据流发布到管道，发布者不持有订阅着引用，订阅者在管道中即可获得数据流，实现两者的解耦。\nRxJava的结构 RxJava的五大观察者模式  Observable \u0026amp; Observer\n发送0~n个事件 Flowable \u0026amp; Subscriber\n发送0~n个事件，支持背压的被观察者和观察者 Single \u0026amp; SingleObserver\n只发送/接收一次事件或处理onError的被观察者和观察者 Completable \u0026amp; CompletableObserver\n不发送/接收事件，只处理 onComplete 和 onError事件。 Maybe \u0026amp; MaybeObserver\n发送0~1个事件  其他被观察者：\n ConnectableObservable 一般的被观察者和观察者是在订阅(subscribe)时触发事件(数据)发送，但ConnectableObservable则比较特殊，它是在使用操作符connect时才会触发事件(数据)发送。普通的Oservable调用pulish(observable.publish())操作符转成ConnectableObservable。ConnectableObservable调用refCount操作符可转成普通的Oservable。  RxJava被观察者(发布者)和观察者(订阅者)主要分为两类：\n 不支持背压的被观察者(Observable)和观察者(Observer) 支持背压的发布者(Publisher)和订阅者(Subscriber)  RxJava订阅关系涉及到的相关类：\n Emitter  支持背压部分的：FlowableEmitter 不支持背压部分的：ObservableEmitter、CompletableEmitter、SingleEmitter、MaybeEmitter等。   XxxCreate  支持背压部分的：FlowableCreate 不支持背压部分的：ObservableCreate、CompletableCreate、SingleCreate、MaybeCreate等。   XxxSource  支持背压部分的：Publisher(RxJava中没有FlowableSource，Publisher实际相当于FlowableSource) 不支持背压部分的：ObservableSource、CompletableSource、SingleSource、MaybeSource等。    Publisher/Subscriber和Observable/Observer Publisher和Observable对应，Subscriber和Observer对应。\nPublisher和Subscriber是支持背压部分的父类接口和抽象\nObservable和Observer是不支持背压部分的父类接口和抽象\nRxJava流程的结构 流程结构中有三个重要概念：事件源(Source)、被观察者(Observable)、观察者(Observer)。\n什么是事件源？ 在RxJava中XxxSource及Publisher即代表了事件源接口，比如：ObservaleSource、CompletableSource、MaybeSource、SingleSource、Publisher等，他们的共同的特点是有一个subscribe方法。你会发现这几个事件源接口正好对应RxJava的五大被观察者，分别被五大被观察这继承，即被观察者本身也是事件源，这也是为什么观察者可以在一个事件流中不断转换。你可能还会问这怎么是事件源了？只有一个subscribe方法，事件源来自哪？这里还有一个最初事件源的概念，XXXSource不可能凭空发出一个事件，就像Retrofit中的RxJava2CallAdapter中，最初的事件是由Call发出的。RxJava中也可以构建出最初事件源(未实现HasUpstreamXXXSource)，一般是五大被观察者的create方法。比如：Observable.create中事件由ObservableEmitter发出。当然也可能是直接在subscribe(订阅时)调用观察者的onNext方法发送事件。比如：Observable.just(1).subscribe(observer)。\n举个例子来说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  Observable.just(1) //Observable.just返回ObservableJust，这里相当于调用ObservableJust.map  .map(new Function\u0026lt;Integer, String\u0026gt;() { @Override public String apply(Integer integer) throws Exception { return String.valueOf(integer); } }) //ObservableJust.map返回ObservableMap，这里相当于ObservableMap.subscribe  .subscribe(new Observer\u0026lt;String\u0026gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { } @Override public void onError(Throwable e) { } @Override public void onComplete() { } });   在每一次经过操作符对Observable转换的过程中你会发现都是实例化一个新的Observable并将原有的Observable作为Source传给新的Observable，转换过程就是经过这样层层包裹封装，类似装饰模式。同样的调用subscribe后原始的Observer会分别被层层包裹封装。比如上面的例子：\n\u0026mdash;Observable.just \u0026mdash;\u0026gt;ObservableJust\u0026mdash;-map\u0026mdash;-\u0026gt;ObservableMap\u0026mdash;\u0026mdash;subscribe\u0026mdash;\u0026mdash;\u0026gt;\nObserver\u0026mdash;\u0026ndash;subscribe\u0026mdash;\u0026mdash;\u0026gt;MapObserver\u0026ndash;source(ObservableJust).subscribe \u0026ndash;\u0026gt;ScalarDisposable(MapObserver.onNext)\u0026mdash;\u0026gt;Observer.onNext\nCold Obseravle 和Hot Obserable 所谓的Cold Obseravle就是普通的Obserable，Hot Obserable就是ConnectableObservable。\n Cold Obseravle\n当Obseravle被订阅才开始执行发射数据流的代码，当Obseravle被多个订阅者订阅时他们之间的关系是独立的，即多次订阅发射数据流的代码会独立的多次执行。 Hot Obserable\n无论Obseravle是否被订阅者订阅，事件始终会发生，即发射数据流的代码不会因为未被订阅不执行。类似广播的行为。  Cold Obseravle 和Hot Obserable的转换：\n Cold Obseravle转Hot Obserable  调用publish()\n调用publish()转换成ConnectableObservable，继续调用connect()。Obserable和Flowable可以使用该方法，但部分Obseravle如Single、Completable、Maybe等没有publish()直接调用   Hot Obserable转Cold Obseravle  调用refCount()    观察者和被观察者合体的Subject/Processor Subject和Processor/FlowableProcessor既是被观察者又是观察者，他们可以做为观察者将订阅的数据变成自己的数据发送出去。Subject不支持背压，Processor支持背压。\n以Subject为例，它有多个子类：\n AsyncSubject\n只会接受到onComplete之前的最后一个数据 BehaviorSubject\n接收订阅之前的最后一个数据(若订阅之前未发射过数据，则发射一个默认值)，再继续接受之后发射过来的数据。 PublishSubject\n观察者只接受订阅之后的数据 ReplaySubject\n无论何时订阅，都将发射所有的原始数据给观察者 SerializedSubject\n线程安全，多线程情况下保证同时只有一个线程执行onNext、onComplete、onError方法。 UnicastSubject  Processor的子类：\n FlowableProcessor AsyncProcessor BehaviorProcessor MulticastProcessor PublishProcessor ReplayProcessor SerializedProcessor UnicastProcessor  背压 所谓背压即是当上流发送事件的速度快于下流测处理速度，这些事件将会消耗内存，长期积压容易OOM，RxJava中支持背压的观察者和被观察者则帮我们提供了一种处理这种场景的能力和手段，但这不是从根本上解决问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55  public enum BackpressureStrategy { /** * 不缓存也不丢弃，下游必须自己处理可能的溢出 */ MISSING, /** * 在下游无法跟上的情况下，发出MissingBackpressureException异常。 */ ERROR, /** * 缓存所有值直到下游消费它，可能会OOM */ BUFFER, /** * 发送request指定数量的item，其他将被丢弃 */ DROP, /** * 只保留最新的onNext值，如果下游无法跟上，则覆盖以前的任何值。 */ LATEST } Flowable.create(new FlowableOnSubscribe\u0026lt;Integer\u0026gt;() { @Override public void subscribe(FlowableEmitter\u0026lt;Integer\u0026gt; emitter) throws Exception { int i = 0; while (i \u0026lt; 10000) { emitter.onNext(i); i++; } emitter.onComplete(); } }, BackpressureStrategy.LATEST).subscribe(new Subscriber\u0026lt;Integer\u0026gt;() { @Override public void onSubscribe(Subscription s) { Log.i(\u0026#34;kkkkkkk\u0026#34;, \u0026#34;onSubscribe\u0026#34;); s.request(100);//下游需要处理的数据或item个数。  } @Override public void onNext(Integer integer) { Log.i(\u0026#34;kkkkkkk\u0026#34;, \u0026#34;onNext\u0026#34; + integer); } @Override public void onError(Throwable t) { Log.i(\u0026#34;kkkkkkk\u0026#34;, \u0026#34;onError\u0026#34; + t.getMessage()); } @Override public void onComplete() { Log.i(\u0026#34;kkkkkkk\u0026#34;, \u0026#34;onComplete\u0026#34;); } });   Scheduler/Schedulers/AndroidSchedulers  Scheduler 每个Scheduler包含一个线程池 Schedulers 负责对Scheduler管理的策略类。 AndroidSchedulers Android平台主要用来管理切换到主线程的类。  使用介绍  Observer和Consumer区别：\n当Observable subscribe Observer时出现异常会走onError\n当Observable subscribe Consumer时出现异常会抛出异常，若外层没有trycatch会崩溃  RxJava 操作符  create 创建Observable需要自己管理事件的发送 unsafeCreate 使用一个已有的Observable创建。 fromArray 依次发送数组数据，如果数据为null，则发送onError事件 just 多个item时走fromArray操作符逻辑。 amb 传递两个或多个Observable给amb时，它只发射其中首先发射数据或通知（onError或onCompleted）的那个Observable的所有数据，而其他所有的Observable的发射物将被丢弃\n ambArray 逻辑同amb。 concat 连接多个Observable，Observable串行运行，串行发送事件 concatEager 连接多个Observable，Observable并行运行，缓存事件，串行发送事件   merge 连接多个Observable，Observable并行运行，并行发送事件 mergeWith 连接多个Observable，Observable并行运行，并行发送事件 mergeArray 逻辑同merge combineLatest\n   timer 延迟指定时间发送一次0L interval 延迟指定时间指定间隔时间发送一次从0L开始递增的Long数字 range\n rangeLong 逻辑同rang，参数是long intervalRang 相当于interval+rang using 创建与Observable具有相同声明周期的一次性资源\n   defer 在订阅前不创建Observable对象，当订阅时为每个订阅者创建一个新的Observable对象。\n empty 创建一个不发出任何项但正常终止的可观察对象。只执行一次onComplete事件。\n never 创建一个不发出任何项且不终止的可观察对象\n throw 创建一个不发出任何项并以错误结束的可观察对象\n sequenceEqual 确定两个观测值是否发出相同的项目序列\n switchOnNext\n zip 按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据.\n zipArray zipIterable buffer 周期性地从一个可观察到的数据集中收集数据包，并发出这些数据包，而不是一次发出一个数据包\n window\n sample\n定期扫描源Observable产生的结果，在指定的间隔周期内进行采样\n throttleLast throttleFirst flatMap 将源Observable发射的item转换成新的Observable发射出去，不保证转换后Observable的发射顺序\n all 所有发射的item是否符合某个条件\n compose 变换源Observable为新的Observable作为源Observable，并将对整个流产生影响，注意和flatMap区别 concatMap 类似于flatMap，但保证顺序\n contains 判断Observable发射的所有数据中，是否包含一个特定的值。给Contains传一个特定的值，如果原始Observable发射了那个值， 它返回的Observable将发射true，否则发射false\n count 统计源Observable发射的items数并仅发射这个items数 debounce 指定时间跨度后发送最近一次的item\n materialize\n dematerialize\n doOnNext 在onNext前执行 doAfterNext 在onNext后执行 doOnError 在onError前执行 doOnComplete 在onComplete和doOnTerminate前执行 doOnTerminate 在doOnComplete后和doOnTerminate前执行 doOnDispose 在调用dispose()后执行 doOnEach 相当于doOnNext+doOnComplete doOnLifecycle 相当于doOnSubscribe+doOnDispose distinct\n join\n groupJoin\n ignoreElements 忽略所有源Observable产生的结果，只会执行onCpmpleted()或者onError()方法 isEmpty 判定原始Observable是否没有发射任何数据 lift 用参数Observer代理返回的源Observer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47  Observable.just(1, 2, 3).lift(new ObservableOperator\u0026lt;String, Integer\u0026gt;() { @Override public Observer\u0026lt;? super Integer\u0026gt; apply(Observer\u0026lt;? super String\u0026gt; observer) throws Exception { return new Observer\u0026lt;Integer\u0026gt;() { @Override public void onSubscribe(Disposable d) { observer.onSubscribe(d); } @Override public void onNext(Integer integer) { observer.onNext(String.valueOf(integer)); } @Override public void onError(Throwable e) { observer.onError(e); } @Override public void onComplete() { observer.onComplete(); } }; } }).subscribe(new Observer\u0026lt;String\u0026gt;() { @Override public void onSubscribe(Disposable d) { } @Override public void onNext(String s) { } @Override public void onError(Throwable e) { } @Override public void onComplete() { } });    map\n ofType 指定某个类型的class，过滤属于这个类型的的结果并cast，其它抛弃 publish 将普通Observable转成可连接的Observable(ConnectableObservable)。\n RefCount 将一个可连接的Observable转换为普通的Observable reduce 将一个函数应用于被观察者的每个item，最后发射\n repeat 重复发送item\n replay 确保所有的观察者收到同样的数据序列，即使他们在Observable开始发射数据之后才订阅\n retry 如果一个可观测到的源发出错误，请重新订阅它，希望它不会出错\n retryUtil retryWhen scan 类似reduce，但不是最后发送一次数据，而是每次函数操作后发送一次数据。\n serialize 强制Observable进行序列化调用并且不能有onError事件，否则终止。\n share 相当于publish()+refCount()\n skip take takeWhile\n sorted startWith\n timeInterval\n timeout 超过时间未发射item 就发射onError\n timestamp 为每个item附加一个时间戳。\n to 将Observable转换成另一种对象或数据结构。\n toFlowable 转为支持背压的Observable，即Flowable(实际是Flowable的子类FlowableFromObservable)  自定义操作符 重写subscribeActual方法。\n可以参考just等，这里不严谨的实现简单的RxView的click操作符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  public class RxView { public static Observable\u0026lt;View\u0026gt; click(View v) { return new ObservableClick(v); } } public class ObservableClick extends Observable\u0026lt;View\u0026gt; { private View view; public ObservableClick(View view) { this.view = view; } @Override protected void subscribeActual(Observer\u0026lt;? super View\u0026gt; observer) { ViewClickDisposable disposable = new ViewClickDisposable(observer, view); observer.onSubscribe(disposable); } static class ViewClickDisposable extends AtomicBoolean implements View.OnClickListener, Disposable { private Observer\u0026lt;? super View\u0026gt; observer; private View view; ViewClickDisposable(Observer\u0026lt;? super View\u0026gt; observer, View view) { this.observer = observer; this.view = view; view.setOnClickListener(this); } @Override public void onClick(View v) { if (isDisposed()) { return; } observer.onNext(v); observer.onComplete(); } @Override public void dispose() { set(true); AndroidSchedulers.mainThread().scheduleDirect(() -\u0026gt; { if (view != null) { view.setOnClickListener(null); } }); } @Override public boolean isDisposed() { return get(); } } }   参考：\n Backpressure Alphabetical List of Observable Operators ReactiveX Documentation Operators  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-sparsearray%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "SparseArray源码解析",
	"tags": ["android"],
	"categories": [],
	"series": ["源码解析"],
	"description": "SparseArray源码解析",
	"content": "前言 SparseArray是谷歌推荐使用的数据结构，可以取代部分HashMap功能。为什么是部分？因为SparseArray是以int为key的Key-Value集合。SparseArray内部是两个数组：int数组mKeys和范型数组mValues。\n源码分析 appent\u0026amp;put逻辑 appent针对键大于数组中所有现有键的情况进行优化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  public void append(int key, E value) { if (mSize != 0 \u0026amp;\u0026amp; key \u0026lt;= mKeys[mSize - 1]) { put(key, value); return; } if (mGarbage \u0026amp;\u0026amp; mSize \u0026gt;= mKeys.length) { gc(); } mKeys = GrowingArrayUtils.append(mKeys, mSize, key); mValues = GrowingArrayUtils.append(mValues, mSize, value); mSize++; } public void put(int key, E value) { int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i \u0026gt;= 0) { mValues[i] = value; } else { i = ~i; if (i \u0026lt; mSize \u0026amp;\u0026amp; mValues[i] == DELETED) { mKeys[i] = key; mValues[i] = value; return; } if (mGarbage \u0026amp;\u0026amp; mSize \u0026gt;= mKeys.length) { gc(); // Search again because indices may have changed.  i = ~ContainerHelpers.binarySearch(mKeys, mSize, key); } mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key); mValues = GrowingArrayUtils.insert(mValues, mSize, i, value); mSize++; } }   可以看出put元素\nremove\u0026amp;delete逻辑 1 2 3 4 5 6 7 8 9 10 11 12  public void remove(int key) { delete(key); } public void delete(int key) { int i = ContainerHelpers.binarySearch(mKeys, mSize, key); if (i \u0026gt;= 0) { if (mValues[i] != DELETED) { mValues[i] = DELETED; mGarbage = true; } } }   可以看出SparseArray并不是真的把元素删除，而是将值置为DELETED标志对象。并不会像ArrayList一样Arrays.copyOf\nvalueAt逻辑 1 2 3 4 5 6 7 8 9 10 11 12  public E valueAt(int index) { if (index \u0026gt;= mSize \u0026amp;\u0026amp; UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) { // The array might be slightly bigger than mSize, in which case, indexing won\u0026#39;t fail.  // Check if exception should be thrown outside of the critical path.  throw new ArrayIndexOutOfBoundsException(index); } if (mGarbage) { gc(); } return (E) mValues[index]; }   gc逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  private void gc() { // Log.e(\u0026#34;SparseArray\u0026#34;, \u0026#34;gc start with \u0026#34; + mSize);  int n = mSize; int o = 0; int[] keys = mKeys; Object[] values = mValues; for (int i = 0; i \u0026lt; n; i++) { Object val = values[i]; if (val != DELETED) { if (i != o) { keys[o] = keys[i]; values[o] = val; values[i] = null; } o++; } } mGarbage = false; mSize = o; // Log.e(\u0026#34;SparseArray\u0026#34;, \u0026#34;gc end with \u0026#34; + mSize); }   总结：当使用Key删除元素时并不会真正删除元素而是置为删除标志对象DELETE，并将需要整理标志mGarbage置为true。当使用index获取Key或Value时则会先根据mGarbage判断是否执行整理函数gc()。这样mValues数组mSize之前的元素就不会存在DELETED，可以用数组下标直接访问。\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/vr/",
	"title": "vr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%ACioc/",
	"title": "依赖注入和控制反转(IoC)",
	"tags": ["java"],
	"categories": [],
	"series": [],
	"description": "依赖注入和控制反转(IoC)",
	"content": "控制反转(IoC) Java设计六大原则中有一项是依赖倒置，简单说就是面向接口编程。\n比如Java中每个Service都有一个接口类和实现类，接口一般不会改变，但实现类可能会不断有微小的变化，这样我们都以接口返回给调用者。但接口实例化的对象却仍是写死的。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  interface Human{ void eat(); } class Man implements Human{ void eat(){ } } class Woman implements Human{ void eat(){ } } class Persion { Human human; Persion(){ human = Man(); } public void eat(){ human.eat(); } }   Persion中的human实例话对象仍然是固定的Man，有时我们希望human实例对象由外部控制，这就需要IoC。可以说IoC解决依赖倒置或者面向接口编程最后的一点瑕疵。\n实现\n而依赖注入是实现Ioc的一种手段。依赖注入分三种：\n 构造方法注入 即构造方法传入实例 setter注入 使用set方法设置实例 接口注入 使用接口方式设置\n依赖注入的本质即：当前对象需要使用另一个对象时并不是当前对象内实例化这个对象而是外部实例化这个对象。  Java依赖注入规范 JSR-330 是 Java 的依赖注入标准。定义了如下的术语描述依赖注入:\n A 类型依赖 B类型(或者说 B 被 A 依赖)，则 A类型 称为”依赖(物)dependency” 运行时查找依赖的过程，称为”解析 resolving“依赖 如果找不到依赖的实例，称该依赖是”不能满足的 unsatisfied” 在”依赖注入 dependency injection”机制中，提供依赖的工具称为”依 赖注入器 dependency injector，注射器”  javax.inject javax.inject 指定了获取对象的一种方法，该方法与构造器、工厂以及服务定位器(例如 JNDI)这些传统方法相比可以获得更好的可重用性、可测试性以 及可维护性。此方法的处理过程就是大家熟知的依赖注入，它对于大多数应用是 非常有价值的。\n@Inject 注解 @Inject 标识了可注入的构造器、方法或字段。可以用于静态或实例成 员。一个可注入的成员可以被任何访问修饰符(private、package- private、 protected、public)修饰。注入顺序为构造器，字段，最后是方法。超类的字 段、方法将优先于子类的字段、方法被注入。对于 同一个类的字段是不区分注 入顺序的，同一个类的方法亦同\nProvider 接口 Provider 用于提供类型 T 的实列。Provider 是一般情况是由注入器实现 的。对于任何可注入的 T 而言，您也可以注入 Provider。与直接注入 T 相比， 注入 Provider 使得:\n 可以返回多个实例。 实例的返回可以延迟化或可选 打破循环依赖 可以在一个已知作用域的实例内查询一个更小作用域内的实例。 1 2 3 4 5 6 7 8 9  class Car { @Inject Car(Provider\u0026lt;Seat\u0026gt; seatProvider) { Seat driver = seatProvider.get(); Seat passenger = seatProvider.get(); ... } ... }    get() 用于提供一个完全构造的类型 T 的实例。 异常抛出: RuntimeException—— 当注入器在提供实例时遇到错误将抛出此异 常。例如，对于一个可注入的成员 T 抛出了一个异常，注入器将包装 此异常并将它抛给 get() 的调用者。调用者不应该尝试处理此类异 常，因为不同注入器实现的行为不一样，即使是同一个注入器，也会 因为配置不同而表现的行为不同。  @Qualifier 用于标识限定器注解。任何人都可以定义新的限定器注解。一个限定器注解:\n 是被 @Qualifier、@Retention(RUNTIME) 标注的，通常也被 @Documented 标注 可以拥有属性。 可能是公共 API 的一部分，就像依赖类型一样，而不像类型实现那样 不作为公共 API 的一部分 如果标注了 @Target 可能会有一些用法限制。本规范只是指定了限定 器注解可以被使用在字段和参数上，但一些注入器配置可能使用限定 器注解在其他一些地方(例如方法或类)上。  @Named 基于 String 的限定器\n@Scope 用于标识作用域注解。一个作用域注解是被标识在包含一个可注入构造器的类上的，用于控制该类型的实例如何被注入器重用。缺省情况下，如果没有标识作用域注解，注入器将为每一次注入都创建(通过注入类型的构造器)新实例，并不重用已有实例。如果多个线程都能够访问一个作用域内的实例，该实例实现应该是线程安全的。作用域实现由注入器完成。\n@Singleton 标识了注入器只实例化一次的类型。该注解不能被继承\nDagger2 Dagger2是一个实现依赖注入的框架。\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%85%B6%E4%BB%96/",
	"title": "其他",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E5%85%B6%E4%BB%96/",
	"title": "其他",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/",
	"title": "动态代理",
	"tags": ["java", "设计模式"],
	"categories": [],
	"series": ["设计模式"],
	"description": "动态代理",
	"content": "前言 解说动态代理前我们需要先知道什么是代理模式。\n代理模式即是给目标对象提供一个代理对象，由代理对象控制对目标对象的引用。引入代理对象的目的：\n 通过代理对象间接访问目标对象，协调调用者与被调用者，防止直接访问目标对象带来的不必要的复杂性，降低耦合。 通过代理对象对原有的业务增强  比如目标对象是一个复杂重量的对象，我们只用到其中一部分，并不想了解其复杂性，这时候就可以使用动态代理。还比如访问目标对象前需要做一些转换、处理也可以使用代理模式。\n静态代理 静态代理一般需要一个抽象共同业务接口：抽象主题类(Subject)，这个抽象业务接口需要被真正的被代理对象(Real Subject)和代理对象(Proxy)继承实现，调用者(Client)使用代理类间接访问被代理对象。实际的编程中抽象主题类(Subject)有时会被省略。\n动态代理 有了静态代理为什么还需要静态代理？通常一个代理对象只实现一个抽象业务接口，对于同一类型的不同业务，虽然处理流程逻辑一致但因为是不同业务无法使用一个接口实现。你当然可以实现多个，但这违反代理模式的初衷：降低复杂行和耦合度。总的来说就是可扩展性差，可维护性差。\n动态代理则可以将同一类型有相同处理流程逻辑的业务合并，一个动态代理解决多个静态代理的问题，避免重复冗余代码，灵活度高。\nAndroid中动态代理的经典应用即是Retrofit。\nJava中动态代理的两种实现方式：\n  Java SDK Proxy\n只能对实现接口的类代理，因为Java的动态代理是生成一个继承Proxy类和被代理对象所实现接口的类(这句话不完全正确，因为代理类不必完全实现被代理对象所继承的所有接口)。代理对象是JVM运行时动态生成的，命名规则：$+Proxy+数字。结构大致如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  public final class $Proxy5 extent Proxy implements Interface1,Interface2{ private static Method m0; private static Method m1; private static Method m2; private static Method m3; private static Method m4; private static Method m5; public $Proxy5(InvocationHandler invocationHandler) { super(invocationHandler); } Object interface1Method1(String s){ return handler.invoke(this,m0,new Object[]{ s }; } Object interface1Method2(String s,String s1){ return handler.invoke(this,m1,new Object[]{ s, s1 }); } Object interface2Method1(){ return handler.invoke(this,m2,null); } public final boolean equals(Object object) { try { return (Boolean)this.h.invoke((Object)this, m3, new Object[]{object}); }catch (Error | RuntimeException v0) { throw v0; }catch (Throwable var) { throw new UndeclaredThrowableException(var); } } public final String toString() { try { return (String)this.h.invoke((Object)this, m4, null); }catch (Error | RuntimeException v0) { throw v0; }catch (Throwable var) { throw new UndeclaredThrowableException(var); } } public final int hashCode() { try { return (Integer)this.h.invoke((Object)this, m5, null); }catch (Error | RuntimeException v0) { throw v0; }catch (Throwable var) { throw new UndeclaredThrowableException(var); } } static { try { m0 = Class.forName(\u0026#34;com.xxx.xxx.Interface1\u0026#34;).getMethod(\u0026#34;interface1Method1\u0026#34;, Class.forName(\u0026#34;java.lang.String\u0026#34;)); m1 = Class.forName(\u0026#34;com.xxx.xxx.Interface1\u0026#34;).getMethod(\u0026#34;interface1Method2\u0026#34;, Class.forName(\u0026#34;java.lang.String\u0026#34;), Class.forName(\u0026#34;java.lang.String\u0026#34;)); m2 = Class.forName(\u0026#34;com.xxx.xxx.Interface2\u0026#34;).getMethod(\u0026#34;interface2Method1\u0026#34;, new Class[0]); m3 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;equals\u0026#34;, Class.forName(\u0026#34;java.lang.Object\u0026#34;)); m4 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;toString\u0026#34;, new Class[0]); m5 = Class.forName(\u0026#34;java.lang.Object\u0026#34;).getMethod(\u0026#34;hashCode\u0026#34;, new Class[0]); return; } catch (NoSuchMethodException var1) { throw new NoSuchMethodError(var1.getMessage()); } catch (ClassNotFoundException var1_1) { throw new NoClassDefFoundError(var1_1.getMessage()); } } }   Java动态代理需要了解两个类：Proxy、InvocationHandler。\n  InvocationHandler\n1 2 3  public interface InvocationHandler { public Object invoke(Object proxy, Method method, Object[] args) throws Throwable; }   可以看到InvocationHandler只有一个invoke方法声明，每个代理实例都需要关联一个InvocationHandler实例，当代理对象调用相关方法时会回调到invoke方法，invoke方法接管后面的调用流程。你可以在invoke中做一番处理后继续调用该方法也可以改变调用流程，这也是Java Hook的实现方式之一。\nproxy 继承了被代理对象所继承接口的代理实例\nmethod 被调用的方法\nargs 被调用方法的参数\n返回值Object 方法method的返回值\n  Proxy\nObject newProxyInstance(ClassLoader loader,Class\u0026lt;?\u0026gt;[] interfaces,InvocationHandler h)\nloader 代理类的加载器\ninterfaces 代理类要代理/实现的接口列表\nh 代理对象相应方法被调用时关联的InvocationHandler实例\n返回值Object 是继承了被代理对象所继承接口的代理实例，和InvocationHandler#invoke中的Object proxy是一个实例。\n  具体使用示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  interface Subject{ String doSomething(int a); } class RealSubject implements Subject{ public String doSomething(int a){ return \u0026#34;do something \u0026#34;+a } } class SubjectInvocationHandler implements InvocationHandler{ Subject subject; SubjectProxy(Subject subject){ this.subject = subject; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //前置工作  Object obj = method.invoke(subject, args); //后置工作  return obj; } } class Client{ void main(){ Subject realSubject = new RealSubject(); //这里返回的subject既是代理(如：$Proxy123)对象  Subject subject = (Subject)Proxt.newProxyInstance(subject.getClass().getClassLoader(),subject.getClass().getInterfaces(),new SubjectInvocationHandler(subject)) subject.doSomething(2); } }     第三方库 CGLib\n利用ASM操作字节码，生成被代理类的子类并覆盖其中的方法，因为是通过继承实现，所以不能代理final类。\n  参考：\n Java查看动态代理生成的代码  "
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E5%8D%8F%E7%A8%8B/",
	"title": "协程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%8D%8F%E7%A8%8B/",
	"title": "协程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%8E%8B%E7%BC%A9%E5%8E%9F%E7%90%86%E5%8F%8Agzip7zip/",
	"title": "压缩原理及Gzip、7zip",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "压缩原理及Gzip、7zip",
	"content": "占坑，敬请期待\u0026hellip;\n"
},
{
	"uri": "https://dshcao.github.io/zh/series/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/",
	"title": "四大组件",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/",
	"title": "四大组件",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
	"title": "多线程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
	"title": "多线程详解",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": "前置知识 线程是CPU调度的最小单位。\n进程是系统进行程序资源分配的最小单位，线程之间共享所在进程的资源。\n一个进程至少有一个线程，一个线程必须依附于一个进程。\n对于不同的操作系统，一个进程拥有的线程数量有一个上限：Linux 1000，Windows 2000。\n线程状态：\n 初始态（NEW） 运行态（RUNNABLE）  就绪态（READY） 运行态（RUNNNING）   阻塞态（BLOCKED） 等待态（WAITING） 超时等待态（TIMED_WAITING） 终止态（TERMINATED）\n  并行和并发 一个四车道，那么它的并行能力是4\n并发或者并发量则是一定时间段内通过的最大车辆数\ncpu指令分为特权指令和非特权指令  特权指令 对内存空间的访问范围不受限制，即：既可以访问用户存储空间也可以访问系统存储空间，一般只给操作系统使用，特权指令：时钟操作 I/O操作 内存清零 关机等 非特权指令 一般程序使用，只能访问用户存储空间完成一般性的操作和任务  用户态和内核态  用户态 只能运行非特权指令 内核态 可运行特权指令  用户态切换到内核态的三种方式：  系统调用,在CPU中的实现称之为陷阱指令(Trap Instruction) 如：文件操作和网络数据发送 未预知的异常(注意不等同于java中的异常),如：缺页异常 外围设备中断  Intel x86cpu 有Ring0~Ring3四个级别，Linux将Ring0作为内核态，Ring3作为用户态。Linux进程有4G地址空间 1~3G用户态地址空间 3~4G是内核态地址空间\njava线程和操作系统线程是一一对应的关系，每一个java/c++线程都映射到操作系统上的一个线程。Java中对线程的操作，如：创建/阻塞/切换等都要切换到内核态，这种切换消耗大量系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。Java中synchronized会导致未获得锁的线程进入阻塞状态，引起用户态与内核态的切换\n多线程的意义 首先明确一个cpu核心同时只能执行一个系统线程，这也是为什么一般线程池是和cpu核心关联,通常维护线程alive数量最小设置为CPU_COUNT+1，最大设置为CPU_COUNT*2+1\n多线程的出现是解决并发和性能问题，那么是不是多线程比单线程性能更好呢？那么要看你对性能的理解，对于整个计算机来说并不一定，这要分情况。影响线程性能的主要是线程的状态切换和线程间切换以及为了线程安全引入的线程锁带来的性能消耗\n 单核cpu   计算密集型操作 本身大量占用cpu，多线程的创建和上下文切换(一次上下文切换大概消耗20000个CPU时间周期)反而加重了cpu的负担，影响整个计算机的性能，但程序本身有更多机会竞争cpu时间片 I/O密集型操作 由于操作过程较少占用cpu，多线程有助于提高性能。我们平时大多是这种操作  多核cpu 由于是多核可以同时执行多个线程，此时多线程是有助于极高整个计算机的利用率，提升性能  每个线程维护一个自己的栈\njava内存模型直接保证的原子性包括：read load use assign store write这6个，另外synchronized之间的操作也具备原子性\nAndroid线程优先级 Process.setThreadPriority(int priority)\nThread.currentThread().setPriority(int newPriority)\n实际多线程开发中一般不考虑优先级的问题，优先级是不可靠的，依赖于具体的系统平台。比如Java线程有10个优先级，但具体的系统平台可能并没有这么多与之对应的优先级选项。\nJava线程的API  thread.start()当前线程进入RUNNABLE Thread.yield()不释放锁,当前运行态线程让出cpu时间片给同等优先级的线程执行并进入就绪态 thread.interrupt() 设置thread中断标志位为true,Java中的输入输出流并没有类似于Interrupt的机制，但是Java的InterruptableChanel接口提供了这样的机制，任何实现了InterruptableChanel接口的类的IO阻塞都是可中断的，中断时抛出ClosedByInterruptedException，也是由Thread对象调用Interrupt方法完成中断调用。IO中断后将关闭通道。实现InterruptableChanel接口的类包括FileChannel,ServerSocketChannel, SocketChannel, Pipe.SinkChannel andPipe.SourceChannel，也就是说，原则上可以实现文件、Socket、管道的可中断IO阻塞操作。虽然解除IO阻塞的方法还可以直接调用IO对象的Close方法，这也会抛出IO异常。但是InterruptableChanel机制能够使处于IO阻塞的线程能够有一个和处于中断等待的线程一致的线程停止方案 thread.isInterrupted() 返回thread中断标志位状态 Thread.interrupted() 返回当前thread中断标志位状态并清除中断标志位,另外抛出中断异常被捕获时也会清除中断标志位(比如sleep、wait等)，而且是catch之前，如： 1 2 3 4 5 6 7 8 9 10  while(!thread.isInterrupted()){ try{ Thread.sleep(2000); }catch(InterruptedException e){ e.printStackTrace(); //进入中断异常的catch代码块时会清除中断标志位  } } thread.interrupt()//因为可能在sleep，调用thread.interrupt()会抛出异常清除中断标志位，因此这里的while循环并不会终止    wait() 释放锁,以便其他等待此锁的线程执行，当前线程进入等待态，必须在synchronized同步代码块中调用 wait(1000) 释放锁,以便其他等待此锁的线程执行，当前线程进入超时等待态，必须在synchronized同步代码块中调 notify()/notifyAll() 当前线程进入RUNNABLE，此时调用当前monitor.wait()的线程重新竞争锁。必须在synchronized同步代码块中调\nnotify是依附于锁(监视器)monitor的，故必须是monitor.wait()/monitor.notifyAll()，如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  private final Object obj = new Object(); private String name = null; public void xxx() { synchronized (obj) { while (name == null) { try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } public void yyy() { synchronized (obj) { name = \u0026#34;name\u0026#34;; obj.notify(); } }    thread.join() 当前线程进入等待态,注意不是thread，但thread必须是alive状态否则join无效，join是通过wait实现的 thread.join(1000) 当前线程进入超时等待态，其他同join() thread.isAlive() 当前显示是否alive,A thread is alive if it has been started and has not yet died thread.setDaemon(true) 设置线程为守护线程，必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常，Java线程分为两种：用户线程和守护线程。当一个程序中所有用户进程结束，程序也就终止了，守护线程也会随即终止，且不保证守护线程执行完毕,即守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点，这也是利用守护线程的原因。守护线程是用来在后台做通用服务的，如垃圾回收线程即时一个守护线程。不要在守护线程中执行业务逻辑操作(比如对数据的读写等).\njava还有一类特殊线程：Hook (钩子) 线程\nRuntime.getRuntime().addShutdownHook(hook);\n在程序即将退出的时候，也就是 JVM 程序即将退出的时候，Hook 线程就会被启动执行,Hook (钩子) 线程的应用场景：  防止程序重复执行，具体实现可以在程序启动时，校验是否已经生成 lock 文件，如果已经生成，则退出程序，如果未生成，则生成 lock 文件，程序正常执行，最后再注入 Hook 线程，这样在 JVM 退出的时候，线程中再将 lock 文件删除掉 Hook 线程中也可以执行一些资源释放的操作，比如关闭数据库连接，Socket 连接等   Thread.sleep(1000) 不释放锁，当前线程进入超时等待态,Thread.sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”  thread.interrupt()和Thread.interrupted()会唤醒Thread.sleep和thread.wait()导致Thread.sleep和thread.wait()抛出中断异常\nthread.stop, thread.suspend and thread.resume为什么被deprecated，详见参考Java Thread Primitive Deprecation\nthread.stop deprecated原因总的说就是太暴力，会引发不可预期问题。因为thread.stop会抛出ThreadDeath异常，而The monitors are unlocked as the ThreadDeath exception propagates up the stack。一般通过代码控制，或者可以通过thread.interrupt()设置锚点配合代码控制\nthread.suspend and thread.resume deprecated原因是容易引起死锁，可以用obj.wait()/obj.notifyAll()替代\n锁分类  公平锁/非公平锁 公平锁非公平锁的区别是是否是按照申请锁的顺序获取锁。其中非公平锁可能会造成优先级反转和饥饿现象。非公平锁的优点是吞吐量比公平锁大，因为维持公平有一定消耗  优先级反转  T0 thread3(低优先级)获得锁SYNC1 T1 thread2(中优先级)与thread3竞争抢占了cpu时间片，thread3仍持有锁 T2 thread1(高优先级)与thread2竞争抢占了cpu时间片 T3 thread1需要获取锁，但锁被thread3持有，thread1挂起 T4 thread2和thread3都处于可运行态，但由于thread2的优先级高于thread3，thread2优先抢占cpu时间片 总结：这导致了一个现象：低优先级thread2比高优先级thread1先执行 解决：优先继承，即高优先级线程需要低优先级线程持有的锁时，临时提升低优先级线程的优先级，如上面将thread3优先级临时提升到thread1的优先级别，当锁被释放的时候thread3恢复到原来的优先级,这一过程一般有操作系统完成   饥饿 高优先级线程不断进入导致低优先级线程一直无法得到执行   独享锁/共享锁 独享锁：只能被一个线程同时持有，共享锁：可被多个线程同时持有 互斥锁/读写锁 自旋锁 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU 可重入锁 又名递归锁，是指已持有该锁再次调用需要该锁的其他代码块自动获取锁。可重入锁有效避险死锁现象 分段锁 分段锁其实是一种锁的设计，并不是具体的一种锁,目的是细化锁的粒度 java中ConcurrentHashMap就是分段锁，当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入，但在统计size的时候，需要获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计 向锁/轻量级锁/重量级锁 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。\n偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，\n重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低 乐观锁/悲观锁 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。\n悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。\n乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。\n悲观锁在Java中的使用，就是利用各种锁。\n乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新  Java中的锁实现 Synchronized 公平锁 独享锁 可重入锁 synchronized不包含在方法签名，不能继承。\nJVM为了提高synchronized的性能，JDK6开始引入了偏向锁和轻量级锁，轻量级锁(使用CAS)和偏向锁不会引起上下文切换，大大提高了synchronized的性能，所以没有特别需求的情况下，建议JDK6后还是继续使用synchronized。\nLock Java1.5 通过AQS的来实现线程调度，是代码层面实现的锁，比Synchronized轻量，lock的代码块程序抛出异常也不会释放锁，需要手动释放，故使用Lock必须在try{}catch{}块中进行，并且将释放锁的操s作放在finally代码块\nLock相关API lock() 获取锁，未获取则等待\ntryLock() 获取锁，未获取则等待，有返回值，表示获取锁是否成功\ntryLock(long time, TimeUnit unit)获取锁，未获取则等待，有返回值表示设定时间内获取锁是否成功\nlockInterruptibly() 如果线程正在等待获取锁，则这个线程能够响应中断，通过thread.interrupt()中断线程的等待状态\nnewCondition() 返回当前lock的Condition实例。\n注：thread.interrupt()只能中断阻塞的线程，故线程获取锁之后不能响应interrupt()中断\nCondition 配合lock使用，await()/signal()/signalAll()类比monitor.wait()/monitor.notify()/monitor.notifyAll()\nLock的具体实现 ReentrantLock 可重入锁，独享锁，默认非公平锁，可以通过构造函数指定是否是公平，\nReadWriteLock 读写锁 读锁是共享锁，写锁是独享锁，即可以共读读，不能共写读，读写，写写\nReentrantReadWriteLock 可重入读写锁，继承ReadWriteLock，并支持ReentrantLock可重入锁的特性\nLockSupport Java AQS框架使用的方式。LockSupport则是使用的是Unsafe.park/Unsafe.unpark，而Unsafe.park/Unsafe.unpark的阻塞唤醒底层是使用pthread的pthread_mutex_t和pthread_cond_t实现的。而AQS是Lock实现的基础。可以认为Lock是基于LockSupport实现的。\nLockSupport相关API park()\nparkNanos()\nparkUntil()\nunpark(thread) 唤醒线程thread\n参考：\n 深入理解java内存模型系列文章 synchronized原理和锁优化 Java 多线程之 Hook (钩子) 线程 Java Thread Primitive Deprecation Java线程中wait状态和block状态的区别? 用户态和内核态的理解和区别 Java中的锁分类 Java 并发性和多线程  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A1%A5%E5%85%85/",
	"title": "多线程详解补充",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "对多线程详解中提到的部分概念的补充",
	"content": "Java内存模型 Java内存模型主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与Java编程中的变量略有区别，它包括实例变量/静态字段和构成数组对象的元素，不包括局部变量和方法参数（线程私有）。为获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交换，也没有限制即时编译器调整代码执行顺序这类权利。\nJava内存模型规定所有变量都存储在主存（Main Memory）中（虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory），线程的工作内存保存了被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取/赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主存来完成。\n这里的主内存/工作内存与Java内存区域中的Java栈/堆/方法区并不是同一个层次的内存划分。如果两者一定要勉强对应起来，那从变量/主内存/工作内存的定义来看，主内存主要对应于Java堆中对象的实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低的层次来说，主存就是硬件的内存，而为获取更好的运算速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存。\n主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成:lock unlock read load use assign store write\n对long和double型变量的特殊规则 允许虚拟机将没有被volatile修饰的64位数据类型（long和double）的读取操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，就点就是long和double的非原子协定（Nonatomic Treatment of double and long Variables）。\n如果多个线程共享一个为声明为volatile的long或double类型变量，并同时对他们进行读取和修改操作，那么有些线程可能会读取到一个即非原值，也不是其他线程修改值得代表了“半个变量”的数值。\n不过这种读取带“半个变量”的情况非常罕见（在目前商用虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。\n原子性、可见性和有序性  原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问具备原子性（long和double例外）。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足需求，尽管虚拟机未把lock和unlock操作直接开放给用户，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反应到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。 可见性（Visibility）：指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 有序性（Ordering）：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-if-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入  多线程安全 多线程安全问题根本原因是内存copy和时间片分配导致的，要做到线程安全就是要做到“局部串行”或者原子性，比如两个线程同时访问一个临界资源（一个对象，对象中的属性，一个文件，一个数据库等）可能引发线程安全问题，这时就要做到两个线程访问临界资源这一局部顺序是串行执行\n高优先级线程并不一定比低优先级线程先抢占cpu资源，高级优先抢占资源的权重大，但有随机性\nvolatile/Semaphore/AtomicXXX 两者本质上不是同一类东西\n volatile Java关键字，volatile的关键语义：1.防止CPU指令重排序，2.被 volatile 修饰的变量对所有线程都是可见的。 volatile声明某个变量值的一致性(内存同步)，但不保证原子操作，对赋值操作可以保证原子性。如：a=10，不能保证a++操作的原子性，因为a++其实是a=a+1的语法糖，a=a+1在内存中其实是分两步的：temp=a+1 a=temp。对于复杂对象的赋值操作原子性，如：User user=user1;User user=new User;,但不能保证对user.name属性操作的原子性.即可以看作只能赋值操作原子性。volatile 声明某个变量值的一致性(内存同步)，但不保证原子操作。volatile适合一个线程写多个线程读的情况。 Semaphore 控制同时访问某个特定资源或者某个操作的操作数量 AtomicXXX Java库实现 可以保证a++操作的原子性  CountDownLatch与join 比如有三个线程 thread1,thread2,thread3\n当thread3需要thread1,thread2都执行完毕后执行，则两者皆可实现，但当thread3只需要thread1,thread2其中一个执行完毕就可执行的场景CountDownLatch很容易实现，使用join则并不容易实现\n详见参考：CountDownLatch理解一：与join的区别\nRunable Future Callable Java中可以简单认为Thread是是对线程的抽象，而Runable和Callable是对线程任务的抽象，Future线程任务结果的容器。\n Runable 1.没有返回值 2.无法抛异常 1 2 3  public interface Runnable { public abstract void run(); }    Callable 1.有返回结果，可以抛异常，但不像Runnable那样通过Thread的start方法就能启动实现类的run方法，通常利用ExecutorService的submit方法去启动call方法自执行任务，而ExecutorService的submit又返回一个Future类型的结果，因此Callable通常也与Future一起使用 1 2 3  public interface Callable\u0026lt;V\u0026gt; { V call() throws Exception; }     Thread构造方法中只能是Runnable，无法直接使用Callable，因此通常使用FutureTask，通过将Callable以参数方式传入。\n  Future 保存异步计算的结果,可以在我们执行任务时去做其他工作,Future有一下方法\n1. boolean cancel(boolean mayInterruptIfRunning);用来取消任务，成功返回true，失败则返回false\n2.boolean isCancelled();任务是否已经取消\n3.boolean isDone();任务是否已经完成\n4.V get() throws InterruptedException, ExecutionException;用来获取执行结果，这个方法会产生阻塞会一直等到任务执行完毕才返回\n5.V get(long timeout, TimeUnit unit)\nthrows InterruptedException, ExecutionException, TimeoutException;用来获取执行结果，如果在指定时间内，还没获取到结果，直接返回null\n使用Future的好处：\n1.获取任务的结果，判断任务是否完成，中断任务\n2.Future的get方法很好的替代的了Thread.join或Thread,join(long millis)\n3.Future的get方法可以判断程序代码(任务)的执行是否超时，如：\n1 2 3 4 5 6  try { future.get(60,TimeUtil.SECOND); } catch(TimeoutException timeout){ og4j.log(\u0026#34;异常，将被取消！！\u0026#34;); future.cancel(); }     FutureTask\n对Callable的封装，可以让使用Callable像Runnable一样使用且可以获取Callable的返回值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public interface RunnableFuture\u0026lt;V\u0026gt; extends Runnable, Future\u0026lt;V\u0026gt; { /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run(); } public class FutureTask\u0026lt;V\u0026gt; implements RunnableFuture\u0026lt;V\u0026gt; { ... public FutureTask(Callable\u0026lt;V\u0026gt; callable) { if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable  } public FutureTask(Runnable runnable, V result) { this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable  } ... }     CompletableFuture 提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法,帮助我们简化异步编程的复杂性,有点类似于rxjava的模式，当然没有提供这么丰富的功能\n    多线程间的通信  内存共享  共享volatile变量 synchronized+notify+wait lock+condition semaphere+flag   管道  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  public class CommunicateWhitPiping { public static void main(String[] args) { PipedOutputStream pos = new PipedOutputStream(); PipedInputStream pis = new PipedInputStream(); try { //将管道输入流与输出流连接 此过程也可通过重载的构造函数来实现  pos.connect(pis); } catch (IOException e) { e.printStackTrace(); } //创建生产者线程  Producer p = new Producer(pos); //创建消费者线程  Consumer c = new Consumer(pis); //启动线程  p.start(); c.start(); } } //生产者线程(与一个管道输入流相关联) class Producer extends Thread { private PipedOutputStream pos; public Producer(PipedOutputStream pos) { this.pos = pos; } public void run() { int i = 8; try { pos.write(i); } catch (IOException e) { e.printStackTrace(); } } } //消费者线程(与一个管道输入流相关联) class Consumer extends Thread { private PipedInputStream pis; public Consumer(PipedInputStream pis) { this.pis = pis; } public void run() { try { System.out.println(pis.read()); } catch (IOException e) { e.printStackTrace(); } } }    公共接口 消息通信 如：Actor模型  BlockingDeque   BlockingDeque\nadd/remove 添加元素/移除元素 当队列满/空时抛异常\noffer/poll 添加元素/取出元素\nput/take 添加元素/取出元素 当队列满/空时会阻塞put/take\n  ArrayBlockingQueue\n基于数组的有界阻塞队列，初始化需要指定固定大小，此队列按 FIFO(先进先出)原则对元素进行排序。\n  LinkedBlockingQueue\n基于链表实现的有界阻塞队列，初始化可以指定大小，也可以不指定。此队列按 FIFO (先进先出) 排序元素，吞吐量通常要高于ArrayBlockingQueue。\nExecutors.newFixedThreadPool()和 Executors.newSingleThreadExecutor使用了这个队列\n  LinkedBlockingDeque\n由链表组成的双向阻塞队列\n  DelayQueue\n由优先级队列实现的无界阻塞队列\n  SynchronousQueue\n无容量的队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue。\nExecutors.newCachedThreadPool使用了这个队列\n  PriorityBlockingQueue\n一个具有优先级的无限阻塞队列。\n  LinkedTransferQueue\n由链表结构组成的无界阻塞队列\n  ConcurrentHashMap\n  ConcurrentLinkedQueue\n  CopyOnWriteArrayList\n  ConcurrentHashMap\n  多线程的经典场景-生产者消费者模式实现  阻塞队列实现 synchronized关键字实现 lock实现  Java线程内存 Java线程内存有共享区和私有区\n 共享区\n堆 方法区(运行时常量池)[常量 静态变量 类信息] 私有区 有三部分：栈虚拟机、本地方法栈、程序计数器  虚拟机栈 虚拟机栈的每个栈帧对应一个调用方法的信息，可以使用-Xss设置虚拟机栈大小，一般是1M。由以下四部分组成  局部变量表 用于存放八大基本数据类型和对象的引用 操作数栈 存放操作数的一块临时空间 动态链接 存放编译时不能确定方法入口的方法的地址，需要在运行时来保证方法调用的正确性。如：多态方法、native方法。当线程中调用到native方法时JVM不会在为其在虚拟机栈中创建栈帧，而是存储动态链接并直接调用native方法， 方法出口 返回地址   本地方法栈 保存native方法信息，虚拟机规范中并没有强制规定本地方法栈的实现，各版本虚拟机也是自由实现，HotSpot则是将本地方法栈和虚拟机栈合二为一了。 程序计数器 记录程序执行到哪个位置，指向的是当前线程正在执行的字节码指令的地址(行号)。由于Java是多线程的，为了保证多线程切换后正确的执行所以需要程序计数器来记录执行位置。    LockSupport 参考：\n 深入理解JVM - Java内存模型与线程 - 第十二章 Java CompletableFuture 详解 CountDownLatch理解一：与join的区别  "
},
{
	"uri": "https://dshcao.github.io/zh/series/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
	"title": "数据结构",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
	"title": "数据结构",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/",
	"title": "数据结构",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/",
	"title": "数据结构与算法",
	"tags": ["数据结构", "算法"],
	"categories": [],
	"series": ["数据结构", "算法"],
	"description": "数据结构与算法",
	"content": "前言 程序 = 数据结构 + 算法\n似乎数据结构和算法是两码事，但实际有时候数据结构和算法联系非常亲密，可以说有了这种数据结构才有了这种算法或者说有了这种算法的诉求才设计出的这种数据结构。\n数据结构 数据项 一个数据元素可以有若干数据项组成\n数据对象 有相同性质的数据元素的集合，是数据的子集\n数据结构 相互之间存在一种或多种特定关系的数据元素的集合\nJava数据结构   ArrayList\n  LinkedList\n  HashMap\n优化capacity\n  SparseArray\n  二分查找\n  二叉树\n  红黑树\n  算法 查找算法 动态查找和静态查找 动态查找 查找表中有插入和删除操作\n静态查找 查找表中无插入和删除操作\n有序查找和无序查找 有序查找 被查找数列必须为有序数列\n无序查找 被查找数列有序无序均可\n顺序查找(线性查找)\n二分查找\n插值查找\n排序悬法 选择排序 时间复杂度O(n2)\n每次遍历剩余数据，依次查找最值\n比如：遍历数组，按从小到大排序\n1 2 3 4 5 6 7 8 9 10 11  template\u0026lt;typename T\u0026gt; void selection_sort(T arr[], int len) { for (int i = 0; i \u0026lt; len; i++) { int minIndex = i; for (int j = i + 1; j \u0026lt; len; j++) if (arr[j] \u0026lt; arr[minIndex]){ minIndex = j; } swap(arr[i], arr[minIndex]); } }   遍历过程中其实我们不但知道最小值，也知道最大值，所以这里其实可以做一些改进：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  template\u0026lt;typename T\u0026gt; void selection_sort(T arr[], int len) { int left = 0, right = len - 1; while (left \u0026lt; right) { int minIndex = left; int maxIndex = right; // 在每一轮查找时, 要保证arr[minIndex] \u0026lt;= arr[maxIndex]  if (arr[minIndex] \u0026gt; arr[maxIndex]) swap(arr[minIndex], arr[maxIndex]); for (int i = left + 1; i \u0026lt; right; i++) if (arr[i] \u0026lt; arr[minIndex]) minIndex = i; else if (arr[i] \u0026gt; arr[maxIndex]) maxIndex = i; swap(arr[left], arr[minIndex]); swap(arr[right], arr[maxIndex]); left++; right--; } }   插入排序 时间复杂度O(n2)~O(n)，当需要排序的集合是有序的集合时插入排序的时间复杂度将变成O(n)。\n插入排序是将当前位置元素依次和前面元素比较，比如对一个数组按从小到大排序，加入数组是[7,3,8,6,9,2]，那么从第二个位置和前面的数据比较，3比7小，3和7交换位置，数组变成[3,7,8,6,9,2]再从第三个位置和前面两个数字，8比7大，不交换位置，再从第四个位置开始和前面三个数字依次比较，6比8小，6和8交换位置变成[3,7,6,8,9,2]，6再和7比较，6比7小，6和7交换位置变成[3,6,7,8,9,2]，6再和3比较，6比3大，此轮比较完成，再从第四个位置和前面数字比较，依次类推。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  template\u0026lt;typename T\u0026gt; void insertion_sort(T arr[], int len) { for (int i = 1; i \u0026lt; len; i++) { // 写法1  for( int j = i ; j \u0026gt; 0 ; j -- ){ if(arr[j] \u0026lt; arr[j-1]){ swap( arr[j] , arr[j-1] );//swap（相当于三次赋值）  } else { break; } } // 写法2 一次赋值替换swap  T e = arr[i]; int j; // j保存元素e应该插入的位置  for (j = i; j \u0026gt; 0 \u0026amp;\u0026amp; ; j--) { if(arr[j - 1] \u0026gt; e){ arr[j] = arr[j - 1]; } } arr[j] = e; } }   插入排序排序相较于由于可以提前结束第二层循环效率有所提升，尤其是对于近乎有序的集合排序效果更明显。\n希尔排序 希尔排序是插入排序的延伸\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  template\u0026lt;typename T\u0026gt; void shell_sort(T arr[], int len) { int h = 1; while (h \u0026lt; len / 3) h = 3 * h + 1; // 计算 increment sequence: 1, 4, 13, 40, 121, 364, 1093...  while (h \u0026gt;= 1) { // h-sort the array  for (int i = h; i \u0026lt; len; i++) { // 对 arr[i], arr[i-h], arr[i-2*h], arr[i-3*h]... 使用插入排序  T e = arr[i]; int j; for (j = i; j \u0026gt;= h \u0026amp;\u0026amp; e \u0026lt; arr[j - h]; j -= h) arr[j] = arr[j - h]; arr[j] = e; } h /= 3; } }   冒泡排序 冒泡排序整体没有插入排序效率高\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  template\u0026lt;typename T\u0026gt; void bubble_sort(T arr[], int len) { // // 写法一  // bool swapped;  // do{  // swapped = false;  // for( int i = 1 ; i \u0026lt; len ; i ++ )  // if( arr[i-1] \u0026gt; arr[i] ){  // swap( arr[i-1] , arr[i] );  // swapped = true;  // }  // // 优化, 每一趟Bubble Sort都将最大的元素放在了最后的位置  // // 所以下一次排序, 最后的元素可以不再考虑  // len --;  // }while(swapped);  //写法二  int newn; // 使用newn进行优化  do { newn = 0; for (int i = 1; i \u0026lt; len; i++) if (arr[i - 1] \u0026gt; arr[i]) { swap(arr[i - 1], arr[i]); // 记录最后一次的交换位置,在此之后的元素在下一轮扫描中均不考虑  newn = i; } len = newn; } while (newn \u0026gt; 0); }   归并排序 时间复杂度O(nlogn))\n归并排序会现将数据集合不断分拆成小的数据集合然后给小的数据集合排序，然后再将小的数据集合不断合并后排序。归并排序是空间换时间的排序算法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92  template\u0026lt;typename T\u0026gt; void merge_sort(T *arr, int len) { // int l = 0; // int r = len - 1; // if (l \u0026gt;= r) // return; // // int mid = (l + r) / 2; // merge1(arr, l, mid); // merge1(arr, mid + 1, r); // merge1(arr, l, mid, r);  // 对于小数组, 使用插入排序优化  for (int i = 0; i \u0026lt; len; i += 16) insertionSort(arr, i, std::min(i + 15, len - 1)); //为了避免层数过多，以至少16个元素为一组  for (int sz = 16; sz \u0026lt; len; sz += sz) for (int i = 0; i \u0026lt; len - sz; i += sz + sz) // 对于arr[mid] \u0026lt;= arr[mid+1]的情况,不进行merge  if (arr[i + sz - 1] \u0026gt; arr[i + sz]) __mergeBUO(arr, i, i + sz - 1, std::min(i + sz + sz - 1, len - 1)); } template\u0026lt;typename T\u0026gt; void merge1(T *arr, int l, int mid, int r) { //* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间  //* 使用VS的同学, 请使用new的方式申请aux空间  //* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)  T aux[r - l + 1]; //T *aux = new T[r-l+1];  for (int i = l; i \u0026lt;= r; i++) aux[i - l] = arr[i]; // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1  int i = l, j = mid + 1; for (int k = l; k \u0026lt;= r; k++) { if (i \u0026gt; mid) { // 如果左半部分元素已经全部处理完毕  arr[k] = aux[j - l]; j++; } else if (j \u0026gt; r) { // 如果右半部分元素已经全部处理完毕  arr[k] = aux[i - l]; i++; } else if (aux[i - l] \u0026lt; aux[j - l]) { // 左半部分所指元素 \u0026lt; 右半部分所指元素  arr[k] = aux[i - l]; i++; } else { // 左半部分所指元素 \u0026gt;= 右半部分所指元素  arr[k] = aux[j - l]; j++; } } } // 优化的自底向上的归并排序中, merge函数并没有改变 // 将arr[l...mid]和arr[mid+1...r]两部分进行归并 //归并优化 自底向上 好处是不管见index 可用于非数组排序 template\u0026lt;typename T\u0026gt; void mergeBUO(T arr[], int l, int mid, int r) { //* VS不支持动态长度数组, 即不能使用 T aux[r-l+1]的方式申请aux的空间  //* 使用VS的同学, 请使用new的方式申请aux空间  //* 使用new申请空间, 不要忘了在__merge函数的最后, delete掉申请的空间:)  T aux[r - l + 1]; //T *aux = new T[r-l+1];  for (int i = l; i \u0026lt;= r; i++) aux[i - l] = arr[i]; // 初始化，i指向左半部分的起始索引位置l；j指向右半部分起始索引位置mid+1  int i = l, j = mid + 1; for (int k = l; k \u0026lt;= r; k++) { if (i \u0026gt; mid) { // 如果左半部分元素已经全部处理完毕  arr[k] = aux[j - l]; j++; } else if (j \u0026gt; r) { // 如果右半部分元素已经全部处理完毕  arr[k] = aux[i - l]; i++; } else if (aux[i - l] \u0026lt; aux[j - l]) { // 左半部分所指元素 \u0026lt; 右半部分所指元素  arr[k] = aux[i - l]; i++; } else { // 左半部分所指元素 \u0026gt;= 右半部分所指元素  arr[k] = aux[j - l]; j++; } } //delete[] aux; }   面试题：\n合并两个有序数组并排序\n快速排序 选一个中间数P，以这个中间数为分界将数据集合分成两部分：小于P的部分，大于P的部分\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-recyclerview/",
	"title": "模版",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": "简介 ListView的局限性：\n 只有纵向列表一种布局 没有支持动画的API 没有强制实现ViewHolder 性能不如RecyclerView\nRecyclerView的优势： 默认支持Linear、Grid、Staggered Grid三种布局，且支持纵横方向布局。 友好的ItemAnimator动画API 强制实现ViewHolder保证性能 解耦的架构设计 性能比ListView更好  缓存复用 RecyclerView缓存复用机制是又RecyclerView#Recycler类负责管理的。缓存复用机制是RecyclerView的onTouchEvent Move事件中触发的。\nonTouchEvent#Move -\u0026gt; scrollByInternal -\u0026gt; mLayout.scrollVerticallyBy(y, mRecycler, mState) -\u0026gt; LinearLayoutManager.scrollBy() -\u0026gt; fill(recycler, mLayoutState, state, false); 一级缓存Scrap mChangedScrap\nmAttachedScrap\n一级缓存需要通过Position查找缓存，数据不需要重新绑定\n二级缓存Cache mCachedViews mCachedViews默认大小为2(DEFAULT_CACHE_SIZE)，使用先进先出策略，mCachedViews缓存的是滚动时刚出屏幕的两个Item，当mCachedViews未满时直接添加到mCachedViews，满时则现将mCachedViews中的0位置的缓存移出，在向mCachedViews添加\n三级缓存ViewCacheExtension mViewCacheExtension 一个提供给开发者的可以自定义缓存的策略，一般没有特殊需求用不到。\n四级缓存RecycledViewPool mRecyclerPool 采用的是先进后出的策略，默认大小是5(DEFAULT_MAX_SCRAP)，当获取缓存走到这一步会根据viewType获取对应的ViewHolder并将该ViewHolder从缓存池移除。由于RecycledViewPool是通过viewType查找的缓存，所以需要重新绑定数据\nLayoutManager LinearLayoutManager GridLayoutManager StaggeredGridLayoutManager FlexboxLayoutManager SmoothCalendarLayoutManager ItemDecoration ItemAnimator ViewHolder Adapter ViewFlinger\u0026amp;SmoothScroller RecyclerView优化  不要在onBinderHolder中设置监听器 当嵌套时可以在内部的RecyclerView使用LinearLayoutManager.setInitialPrefetchItemCount优化。只有嵌套在内部的RecyclerView使用才有效 RecyclerView.setHasFixedSize\nsetHasFixedSize的作用(伪代码)： 1 2 3 4 5 6 7  void onContentsChanged(){ if(mHasFixedSize){ layoutChildren(); }else{ requestLayout(); } }    多个RecyclerView共用RecycledViewPool 当一个ViewPager中多个列表的ItemView相似时可以共享缓存池 DiffUtil 计算两个list的差异实现局部更新\nnotifyItemXXX不适合所有情况，有时可能我们无法拿到position或比较困难。\nnotifyDataSetChange会导致整个布局重绘，重新绑定所有ViewHodler,而且会丢失动画效果\n  https://github.com/cymcsg/UltimateRecyclerView\nhttps://github.com/lgvalle/Material-Animations\nhttps://www.jianshu.com/p/b2aaaa6decdb\n"
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%AE%97%E6%B3%95/",
	"title": "算法",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%AE%97%E6%B3%95/",
	"title": "算法",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%AE%97%E6%B3%95/",
	"title": "算法",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%AE%97%E6%B3%95-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E6%A0%91/",
	"title": "算法-二分搜索树",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "算法-二分搜索树",
	"content": "占坑，敬请期待\u0026hellip;\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%AE%97%E6%B3%95-%E5%A0%86%E6%8E%92%E5%BA%8F/",
	"title": "算法-堆排序",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "算法-堆排序",
	"content": "O(nlogn)\n二叉堆 二叉堆是一个完全二叉树\n最大二叉堆 堆中某个节点的值总是不大于其父节点的值\n最小二叉堆 堆中某个节点的值总是不小于其父节点的值\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%AE%97%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/",
	"title": "算法-快速排序算法",
	"tags": ["算法"],
	"categories": [],
	"series": ["算法"],
	"description": "快速排序算法",
	"content": "前言 快速排序算法(Quick Sort)是对冒泡排序算法的改进。\n算法思想 任意取一数据(比如数组中一个元素)作为关键数据，称为基准数(Pivot)。然后将所有比它小的数据放在它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序，也称为分区（partition）操作。这样前面一部分的数据会比后面一部分的数据都要小。然后再分别对两部分数据再次快速排序，依此类推进行递归。以达到整个数组变成有序序列。但这可能出现一种情况：所选基准数恰好就是最小值或最大值，这将极大影响快速排序性能，所以选择合适的基准数很重要。为了提升性能，有时我们在分割后独立的两部分的个数小于某个数（比如15）的情况下，会采用其他排序算法，比如插入排序。\n算法实现 双基准快速排序(Dual Pivot Quick Sort) 双基准排序是对快速快速的改进，即使用两个基准数排序。双基准排序在实验上看比快速排序提高10%的性能(节省10%性能)。\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%BC%93%E5%AD%98%E5%8F%8Alru%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "缓存及LRU源码解析",
	"tags": [""],
	"categories": [],
	"series": [],
	"description": "缓存及LRU源码解析",
	"content": "占坑，敬请期待\u0026hellip;\nLRU实际上是对访问排序LinkedHashMap的封装\n"
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": ["编程基础"],
	"categories": [],
	"series": ["编程基础"],
	"description": "编程基础",
	"content": "字长 字长是CPU的主要技术指标之一，指的是CPU一次最大能并行处理的二进制位数\n现在主流的计算机字长是32位与64位\n原码\u0026amp;反码\u0026amp;补码 为了表示负数，将最高位解释为符号位\n正数的原码、反码、补码均相同\n对于负数，已知原码求反码，符号位不变，其它位按位求反\n对于负数，已知原码求补码，先求反码，再在反码末位加1\n计算机中数值都是以补码的方式存储的。这样做的好处是：\n符号位和其他位可以统一运算处理，减法可以按照加法处理\n堆栈（stack）和堆(heap) 堆栈（stack）和堆(heap)是应用程序中的两个地址空间，任何应用程序都有，和语言无关。栈和堆映射到物理内存RAM上，只不过栈使用栈这中数据结构存储数据。通常栈是有一定上限的(比如windows是2M)，而堆可以使用整个RAM的80%，但Android稍微有些例外，Android会给每个App设置一个内存上限。\n小端序列\u0026amp;大端序列 \u0026laquo;、\u0026raquo;和\u0026raquo;\u0026gt;运算 见参考Java中的\u0026laquo; 和 \u0026raquo; 和 \u0026raquo;\u0026gt; 详细分析\n \u0026lt;\u0026lt; 有符号左移位运算 \u0026gt;\u0026gt; 有符号右移位运算 \u0026gt;\u0026gt;\u0026gt; 无符号右移位运算  没有\u0026laquo;\u0026lt;(无符号左移位运算)。\n参考：\n Java中的\u0026laquo; 和 \u0026raquo; 和 \u0026raquo;\u0026gt; 详细分析  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/",
	"title": "网络基础",
	"tags": ["java"],
	"categories": [],
	"series": ["java"],
	"description": "网络基础",
	"content": "TCP/IP和OSI TCP/IP协议簇 TCP/IP协议簇既然是以TCP和IP两个协议命名，足以说明TCP和IP两个协议在这个协议簇中的重要性了。另外这个协议簇中比较重要的还有SLIP协议、PPP协议、ICMP协议、ARP协议、UDP协议、FTP协议、DNS协议、SMTP协议等\nTCP/IP模型 TCP/IP协议簇构成的通信互联系统，当前工业中事实上的标准是TCP/IP四层模型。\n  链路层(网络接口层)(Link Layer)\n链路层主要包括：MAC(媒体接入控制)、RLC(无线链路控制)、BMC(广播/组播控制)、MTU(最大传输单元)、PDCP(分组数据汇聚协议)、PPP(点对电协议)、SLIP(串行线路因特网协议)、CSLIP(压缩的串行线路因特网协议)、ARP(地址解析协议)、RARP(反向地址转换协议)。\nMTU、PPP、CSLIP、SLIP、ARP、RARP等用于传输有地址的帧以及错误检测功能。\nISO2110、IEEE802、IEEE802.2等用于以二进制数据形式在物理媒体上传输数据。\n链路层主要是负责提供介质访问和链路管理及物理传输。\n对应OSI模型的数据链路层和物理层。\n  网络层(网际层)(Internet Layer)\n网络层的协议主要有：IP、ICMP、IGMP、BGP、RIP、OSPF等。\n网络层主要是负责IP寻址和路由选择。\n对应OSI模型的网络层。\n  传输层(Transport Layer)\n传输层的协议主要有：TCP、UDP、RTP、SCTP。\n传输层主要是负责建立、管理和维护端对端的连接。\n对应OSI模型的传输层。\n  应用层(Application Layer)\n应用层的主要协议有：HTTP、SMTP、SNMP、FTP、Telnet、SSH、NFS、DNS、TFTP等。\n对应OSI模型的应用层、表示层、会话层。\n  OSI(Open System Interconnection) OSI(开放式系统互联)是国际标准组织制定的的模型，由于其模型过于复杂理想化并没有市场。\n  物理层(Physical Layer)\n物理层主要是负责在物理媒体(网卡，网线，集线器，中继器，调制解调器)上传输原始的数据比特流。\n  数据链路层(Data Link Layer)\n数据链路层主要是负责提供介质访问和链路管理。包括将数据分成一个个数据帧，以数据帧为单位传输。有应有答，遇错重发。该层的设备有：网卡，网桥，网路交换机等。\n  网络层(Network Layer)\n网络层主要是负责IP寻址和路由选择。包括将数据分成一定长度的分组，将分组穿过通信子网，从信源选择路径后传到信宿。该层的设备有：路由。\n  传输层(Transport Layer)\n传输层主要负责建立、管理和维护端对端的连接。包括提供不具体网络的高效、经济、透明的端到端数据传输服务。\n  会话层(Session Layer)\n会话层主要负责建立、管理和维护会话。进程间的对话也称为会话，会话层管理不同主机上各进程间的对话。\n  表示层(Presentation Layer)\n表示层主要负责对来自应用层的命令和数据进行解释，对各种语法赋予相应 的含义，并按照一定的格式传送给会话层。其主要功能是\u0026quot;处理用户信息的表示问题，如编码、 数据格式转换和加密解密，压缩解压缩\u0026quot;等\n  应用层(Application Layer)\n应用层主要负责为应用程序提供网络服务，提供应用程序访问OSI环境的手段。\n  TCP/IP五层模型 OSI和TCP/IP四层模型都有各自的缺陷，TCP/IP五层模型是结合OSI和TCP/IP优点的分层，是OSI的简化模型。五层模型主要用于学术学习。\nTCP/IP五层分别是：\n  物理层(Physical Layer)\n对应OSI模型的物理层\n  数据链路层(Data Link Layer)\n对应OSI模型的数据链路层。\n  网络层(Internet Layer)\n对应OSI模型的网络层。\n  传输层(Transport Layer)\n对应OSI模型的传输层。\n  应用层(Application Layer)\n对应OSI模型的应用层、表示层、会话层。\n  URI和URL URI(Uniform Resource Identifier) 统一资源标识符，用于标识某一互联网资源的字符串。\nURI的格式如下：\n[协议名] : //[用户名]:[密码]@[服务器地址]:[服务器端口号]/[路径]?[查询字符串]#[片段ID\nURL(Uniform Resource Locator)统一资源定位符，因特网的万维网服务程序上用于指定信息位置的表示方法。\n可以认为URL是URI特例、子集。\nMAC地址 IP地址 端口号   MAC(Media Access Control)地址\nMAC地址一般是由6字节(12个十六进制数表示，如：08:00:20:0A:8C:6D)，前3字节(24位)是由生产网卡的厂商向IEEE申请的厂商地址，后3字节由厂商自行分配给所生产的每个网卡设备(厂商将MAC地址写进网卡的BIOS里)且保证不重复，这样就保证了全球唯一。现在一般的接入Internet的方式是将主机通过局域网组织在一起然后通过交换机和Internet相连，为了防止IP盗用问题在交换机在内部存在一个IP地址-MAC地址的映射表，当有数据包发给局域网内某一台主机时交换机接收下来并根据映射表转发给对应的主机上。\n  IP地址 定位到某个计算机\n  端口号 端口号用16位表示，即0~65535，用于定位到主机上的某个应用程序，其中:\n 0~1023 是分配给系统的端口号 1024~49151 是登记端口号，是要是分配给第三方应用使用，但是必须在IANA（互联网数字分配机构）按照规定手续登记 49152~65535 是短暂端口号，是留给客户进程选择暂时使用，一个进程使用完就可以供其他进程使用。    常用端口号：\n   TCP端口号 应用程序     21 FTP服务器   22 SSH服务器   25 SMTP服务器   80 HTTP服务器   2000 FTP客户端   2001 HTTP客户端    Socket 根据RFC793的定义：端口号拼接到IP地址就构成了套接字。即Socket用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。\nSocket(套接字)是一个抽象层。传输层实现端到端的通信，两边的通信端点(主机IP地址+端口号)即是Socket。每个TCP的Socket的内核中都有一个发送缓冲区和一个接收缓冲区。\n在编程中Socket是应用层与TCP/IP协议族通信的中间软件抽象层，一组编程接口，对TCP/IP的封装。\nJava中的Socket类则是对套接字的具体实现。\n全双工\u0026amp;半双工\u0026amp;单工  全双工 客户端向服务端发送数据的同时服务端也可以向客户端发送数据 半双工 同一时刻允许客户端向服务端发送数据或 服务端向客户端发送数据，两者不可同时进行 单工 只能客户端向服务端发送数据  TCP 数据在TCP层称为流（Stream），数据分组称为分段（Segment）。\nTCP是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但网络层不提供这样的流机制，IP只提供不可靠的包交换。\nTCP协议的运行可划分为三个阶段：连接创建(connection establishment)、数据传送（data transfer）和连接终止（connection termination）。\nACK：Acknowledgment，确认应答，表示已收到消息。ACK是一些通信协议下用来做确认消息的控制字符。在TCP协议中表示创建连接时收到了SYN数据包或使用连接时收到数据包或断开连接时收到FIN数据包。\nRST：重置连接\nSYN：Synchronize，发起了一个新连接\nFIN：为1表示发送方没有数据要传输了，要求释放连接。\nTCB：当主机收到一个TCP包时，用两端的IP地址与端口号来标识这个TCP包属于哪个session。使用一张表来存储所有的session，表中的每条记录称作Transmission Control Block（TCB），TCB结构的定义包括连接使用的源端口、目的端口、目的ip、序号、应答序号、对方窗口大小、己方窗口大小、tcp状态、tcp输入/输出队列、应用层输出队列、tcp的重传有关变量等\nCRC：Cyclic redundancy check，循环冗余校验，CRC为校验和的一种。一种根据网络数据包或电脑文件等数据产生简短固定位数校验码的一种散列函数，主要用来检测或校验数据传输或者保存后可能出现的错误。\nMTU：Maximum Transmission Unit，最大传输单元，是指数据链接层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络卡、串口等）。\nRTT：Round-trip delay time，在通信（Communication）、电脑网络（Computer network）领域中，意指：在双方通信中，发讯方的信号（Signal）传播（Propagation）到收讯方的时间（意即：传播延迟（Propagation delay）），加上收讯方回传消息到发讯方的时间（如果没有造成双向传播速率差异的因素，此时间与发讯方将信号传播到收讯方的时间一样久）。\nMSS：最大分段大小，是在单个分段中TCP愿意接受的数据的字节数最大值。MSS应当足够小以避免IP分片，它会导致丢包或过多的重传。在TCP连接创建时，双端在SYN报文中用MSS选项宣布各自的MSS，这是从双端各自直接相连的数据链路层的最大传输单元(MTU)的尺寸减去固定的IP首部和TCP首部长度。\nTCP数据包头结构见参考TCP Header\nTCP建立连接 - TCP三次握手(three-way handshake) 三次握手主要是解决数据传输的可靠性，交换TCP通信的初始序号。因为数据传输过程中数据包会拆分成多个Segment，每个Segment由一个序号标识。\n两个终端的连接通常是由一端(服务器端)打开一个套接字（socket）(比如HTTP的80，HTTPS的443端口)然后监听来自另一方的连接，这就是通常所指的被动打开（passive open）。服务器端被被动打开以后，用户端就能开始创建主动打开（active open）。\n为什么是三次握手？TCP是全双工传输，如果是两次握手只能保证客户端给服务端发送数据的可靠性(第二次握手已经可以确认第一次握手客户端发送给服务端的序号已收到)，但不能保证服务端给客户端发送数据的可靠性，因为并不能保证第二次握手服务端发送给客户端的序号客户端已收到。\n  客户端请求建立连接\n客户端向服务端 发送一个SYN数据包，SYN位置为1，SYN数据包包含一个随机数J。\nClient -\u0026gt; Server SYN=1，seq=J(系统生成的随机数)\n客户端进入SYN_SEND状态。\nseq为什么必须是随机数？想象一下如果在第一次握手后网络意外断开然后重新连接再次握手，如果是固定的一个序列数那就没法判断之前第一次握手的数据包到底是哪一次的。\n  针对客户端的SYN的确认应答并请求建立连接\n服务端收到SYN数据包并确认合法后想客户端发送一个SYN-ACK数据包，SYN位和ACK位置为1，SYN-ACK数据包包含一个随机产生的序号K，另外作为对客户端请求建立连接的确认应答，确认应答码ack=J+1。\nServer-\u0026gt;Client SYN=1，ACK=1，ack=J+1，seq=K\n其中ack=J+1是向客户端表示服务端确实收到客户端的seq且无误\n服务端进入SYN_RECV状态。\n  针对服务端的SYN的确认应答\n客户端收到服务端的SYN-ACK数据包并确认合法后向服务端发送一个ACK数据包，ACK位置为1，作为对服务端请求建立连接的确认应答，确认应答码ack=K+1。当服务端收到ACK数据包时就完成了三次握手，并进入了连接创建状态。\nServer-\u0026gt;Client ACK=1，ack=K+1\n其中ack=K+1是向服务端表示客户端确实收到服务端的seq且无误，第三次握手是可以同时携带数据的\n客户端和服务端进入ESTABLISHED状态\n  三次握手漏洞 SYN洪泛攻击 定义：\n通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。\n原理：\n攻击者客户端利用伪造的IP地址向服务端发出请求(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(永远都不会有的)，服务端在等待这种半开的连接过程中消耗了资源，如果有成千上万的这种连接，主机资源将被耗尽，从而达到攻击的目的。\n服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow决定超出能力时的行为。\n解决方案：1.无效连接监控释放 2.延缓TCB(Transmission Control Block)分配方法 3.防火墙\nTCP数据传输 三次握手建立连接后TCP向应用层发送信号开始传输数据和通信，TCP按照以下方式处理数据传输：\n TCP使用HTTP，SMTP和POP3（电子邮件）和FTP等协议将来自应用程序的消息分解为适当长度(通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制)的Segment并标记序列号。 TCP将Segment（message pieces）传输到远程主机。 远程主机上的TCP会重组这些Segment。 远程主机收到Segment会向发送方发送ACK确认应答消息表示已收到某个Segment。  TCP断开连接 - TCP四次挥手(four-way handshake) 四次挥手是HTTP断开连接的过程，断开连接可能是客户端向服务端请求断开连接，也可能是服务端向客户端请求断开连接，两者过程基本一致。\nTCP连接可以工作在TCP半开状态。即一侧关闭了连接，不再发送数据；但另一侧没有关闭连接，仍可以发送数据。已关闭的一侧仍然应接收数据，直至对侧也关闭了连接。\n首先发出FIN的一侧，如果给对侧的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接。在这段超时等待时间内，本地的端口不能被新连接使用；避免延时的包的到达与随后的新连接相混淆。RFC793定义了MSL为2分钟，Linux设置成了30s。\n以客户端向服务端断开连接为例：\n  客户端向服务端发送关闭连接请求\nClient-\u0026gt;Server FIN=1，seq=u\n第一次挥手后客户端不能再向服务端发送数据了。\n  服务端向客户端发送关闭连接确认\n此时服务端仍可向客户端发送数据，但客户端不能向服务端发送数据\nServer-\u0026gt;Client ACK=1，ack=u+1，seq=v\n  服务端向客户端发送关闭连接请求\nServer-\u0026gt;Client FIN=1，ACK=1，ack=u+1，seq=w\n  客户端向服务端发送关闭连接确认\nClient-\u0026gt;Server ACK=1，ack=w+1，seq=u+1\n  为什么需要四次挥手 原因和三次握手一样，TCP是全双工的，但不同于握手，2、3过程可能无法合并，因为服务端此时可能并未将所有数据发送给客户端。如果客户端向服务端发送关闭连接请求时服务端也正好要向客户端发送关闭连接请求，那么2、3是可能合并的，即四次挥手是可能变成三次挥手的。\nTCP为什么是可靠的？ TCP提供了对丢失，损坏，重复或接收顺序错误的Segment的恢复机制：\n TCP会将来自应用层的数据分解成多个Segment，通过用序列号标记每个Segment的顺序。每个Segment还附加一个CRC校验码，TCP服务端收到Segment后可以用过CRC校验码进行CRC校验Segment是否损坏，不匹配CRC校验的Segment将被丢弃。 TCP协议要求TCP服务端收到Segment后需要客户端返回ACK确认应答消息(并不绝对一个Segment对应一个ACK确认应答消息，)，如果TCP客户端在合理的往返时延（RTT）内未收到ACK确认应答消息，TCP客户端会重发这个Segment。  滑动窗口机制 发送方和接收方都会维护一个数据帧的序列，这个序列被成为窗口。\n发送方的窗口由接收方确定。接收方在“接收窗口”域指出还可接收的字节数量。发送方在没有新的确认包的情况下至多发送“接收窗口”允许的字节数量。\n滑动窗口的目的：\n确保数据不丢失，如果发送的数据丢失了可以重新发。\n控制发送速度，控制发送速度，以免接收方的缓存不够大导致溢出，同时控制流量也可以避免网络拥塞。\nUDP(User Datagram Protocol) 数据在UDP中分组称为Message。\nUDP是一种无连接的、不可靠的、面向报文、没有拥塞控制的通信协议。\n  无连接的：和TCP要建立连接不同，UDP传输数据不需要建立连接，就像写信，在信封写上收信人名称、地址就可以交给邮局发送了，至于能不能送到，就要看邮局的送信能力和送信过程的困难程度了。\n  不可靠的：因为UDP发出去的数据包发出去就不管了，不管它会不会到达，所以很可能会出现丢包现象，使传输的数据出错。\n  面向报文：数据报文，就相当于一个数据包，应用层交给UDP多大的数据包，UDP就照样发送，不会像TCP那样拆分。\n  没有拥塞控制：拥塞，是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象，就像交通堵塞一样。TCP建立连接后如果发送的数据因为信道质量的原因不能到达目的地，它会不断重发，有可能导致越来越塞，所以需要一个复杂的原理来控制拥塞。而UDP就没有这个烦恼，发出去就不管了。\n  应用场景 很多的实时应用（如IP电话、实时视频会议、某些多人同时在线游戏等）要求源主机以很定的速率发送数据，并且允许在网络发生拥塞时候丢失一些数据，但是要求不能有太大的延时，UDP就刚好适合这种要求。\n  UDP报文结构 UDP报文由报文首部和报文数据两部分组成。其中报文首部有八字节四部分组成：源端口(2字节)+目的端口(2字节)+长度(2字节)+校验和(2字节)。\n 源端口 源端口号，在需要对方回信时选用，不需要时可用全0。 目的端口 目的端口号，这在终点交付报文时必须要使用到。 长度 UDP用户数据包的长度，其最小值是8（仅有首部时）。 校验和 检测UDP用户数据报在传输中是否有错,有错就丢弃。  IP 数据在IP层称为Datagram，数据分组称为分片（Fragment）。\nIP协议定义了寻址方法和数据报的封装结构。\n参考：\n TCP/IP详解（中文版） TCP/IP模型及OSI七层参考模型各层的功能和主要协议 ISO/OSI网络体系结构和TCP/IP协议模型 MAC地址的意义及作用？（mac） 维基百科-传输控制协议 维基百科-互联网协议套件 TCP 3-Way Handshake (SYN,SYN-ACK,ACK) TCP Header  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-measurelayoutdraw/",
	"title": "自定义View-measure&amp;layout",
	"tags": ["自定义view", "android"],
	"categories": [],
	"series": ["自定义view"],
	"description": "measure&amp;layout&amp;draw",
	"content": "View\u0026amp;ViewGroup的自定义 measure/onMeasure  measure\n是View测量自己所需空间的方法，通常是调用onMeasure方法完成子控件的测量并最终确定自己的尺寸。measure方法一般无需也尽量不要重写。无论是View还是ViewGroup都可以重写onMeasure完成具体计算 onMeasure\n是父控件调用子控件测量自身的方法(通常是childView.measure())完成测量，并最终确定自己尺寸大小。并在测量完成后调用setMeasuredDimension()方法传入width/height，setMeasuredDimension()会将传入的width/height储存起来，在layout时用调用该view的getMeasuredWidth()获取测量尺寸进行布局，需要注意的是必须在onMeasure()中调用setMeasuredDimension()，因为View的measure()方法中会检测是否有PFLAG_MEASURED_DIMENSION_SET标志，若没有则会抛出异常，而PFLAG_MEASURED_DIMENSION_SET正是在被setMeasuredDimension()方法调用的setMeasuredDimensionRaw()方法中设置。另外需要明确的是setMeasuredDimension()是设置自己的大小，因此不是所有都需要先调用childView.measure()先确定子控件大小再调用setMeasuredDimension()，控件自身大小和子控件也没有强制关系，全看实现，一旦确定自身的大小就可调用setMeasuredDimension()。例如NestedScrollView自身的尺寸是有限的，但子控件的尺寸是无限的。\n无论是measure还是onMeasure，其两个参数int类型是MeasureSpec结构的，即：高2位是测量的Mode类型：EXACTLY/AT_MOST/UNSPECIFIED，低30位是尺寸大小值。可以通过MeasureSpec类方便获得。而onMeasure中调用的setMeasuredDimension()参数并不一定完全是尺寸值，可能包含MeasureState，MeasureState占这个int参数的高8位，剩余低24位才是真正的尺寸值。见其他API\nView中measure源码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  /** * \u0026lt;p\u0026gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * \u0026lt;/p\u0026gt; * * \u0026lt;p\u0026gt; * The actual measurement work of a view is performed in * {@link #onMeasure(int, int)}, called by this method. Therefore, only * {@link #onMeasure(int, int)} can and must be overridden by subclasses. * \u0026lt;/p\u0026gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) { //判断是否是视觉边界，做相应处理  boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } // Suppress sign extension for the low bytes  long key = (long) widthMeasureSpec \u0026lt;\u0026lt; 32 | (long) heightMeasureSpec \u0026amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); //是否是强制重新布局，当调用requestLayut()时会添加PFLAG_FORCE_LAYOUT标志  final boolean forceLayout = (mPrivateFlags \u0026amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // Optimize layout by avoiding an extra EXACTLY pass when the view is  // already measured as the correct size. In API 23 and below, this  // extra pass is required to make LinearLayout re-distribute weight.  final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY \u0026amp;\u0026amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) \u0026amp;\u0026amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); final boolean needsLayout = specChanged \u0026amp;\u0026amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); //如果是强制重新布局或者尺寸改变需要重新布局  if (forceLayout || needsLayout) { // first clears the measured dimension flag  mPrivateFlags \u0026amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex \u0026lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back  onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed  setMeasuredDimensionRaw((int) (value \u0026gt;\u0026gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise  // an exception to warn the developer  if ((mPrivateFlags \u0026amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(\u0026#34;View with id \u0026#34; + getId() + \u0026#34;: \u0026#34; + getClass().getName() + \u0026#34;#onMeasure() did not set the\u0026#34; + \u0026#34; measured dimension by calling\u0026#34; + \u0026#34; setMeasuredDimension()\u0026#34;); } //添加需要重新布局标志  mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; /将结果转成long类型，高32位是mMeasuredWidth，低32位是mMeasuredHeight。缓存合成的measure结果 mMeasureCache.put(key, ((long) mMeasuredWidth) \u0026lt;\u0026lt; 32 | (long) mMeasuredHeight \u0026amp; 0xffffffffL); // suppress sign extension }   layout/onLayout  layout\n是View确定自己位置的方法(通过调用setFrame)，并调用onLayout方法布局子控件。layout方法一般不需要重写。 onLayout\n是父控件确定子控件位置的方法，一般是在onLayout方法中调用子控件的layout方法来实现。如：childView.layout()。View中该方法是一个空方法。ViewGroup中重写为一个抽象方法。因此自定义继承自ViewGroup的控件需要重写该方法。而自定义继承View的控件因为不包含子控件，因此不需要重写该方法\nView中layout源码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 \u0026amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //是否是视觉边界布局，调用响应方法，setFrame返回边界是否改变  boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); //如果边界改变或者尺寸改变需要重新布局，调用onLayout让childView也重新布局  if (changed || (mPrivateFlags \u0026amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); ... mPrivateFlags \u0026amp;= ~PFLAG_LAYOUT_REQUIRED; ... } ... //清除强制布局标志  mPrivateFlags \u0026amp;= ~PFLAG_FORCE_LAYOUT; //添加布局完成标志  mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; ... }   draw/onDraw draw 图画前景/背景/Edges等，并调用onDraw图画自身内容以及调用dispatchDraw图画子控件,onDraw具体使用因为设计较多内容我会另开一篇\n为什么measure和layout分开 理想情况measure后知道了尺寸即可layout，但是measure的情况比较复杂，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;LinearLayout android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/orange_red\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView2\u0026#34; android:layout_width=\u0026#34;360dp\u0026#34; android:layout_height=\u0026#34;220dp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34;\u0026gt; \u0026lt;/LinearLayout\u0026gt;   LinearLayout需要经过两次测量才可以确定textView1的尺寸，因此需要将measure和layout分开处理，不然layout也要进行两次。因为LinearLayout是wrap_content，即内容多大本身尺寸就多大，而textView1是match_parent，即充满LinearLayout，这就造成了矛盾，此时LinearLayout的测量过程是：测量textView1，先将textView1的宽高测量为0，再测量textView2，宽：360，高：220，此时父控件宽：360dp，高：220。再次onMeasure方法测量，此时再将textView1宽度设置为360，高为0。\n见View:\n1 2 3 4 5 6 7  public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 \u0026amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } ... }   ViewGroup ViewGroup 中封装了getChildMeasureSpec/measureChildren/measureChild/measureChildWithMargins几个方法方便我们自定义控件时使用\n getChildMeasureSpec\n根据传入的parentMeasureSpec(即onMeasure的参数)确定子控件的childMeasureSpec。源码较长，但逻辑十分简单，这里就不贴了。 measureChild 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding. * The heavy lifting is done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param parentHeightMeasureSpec The height requirements for this view */ protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }    measureChildren 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this view * @param heightMeasureSpec The height requirements for this view */ protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i \u0026lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags \u0026amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } }    measureChildWithMargins 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this view * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */ protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }     在自定义view的measure时可以使用上面四个方法，大部分情况无需再自己写，如：FrameLayout，但还是看具体情况，如NestedScrollView这类滚动的View就重写了measureChild及measureChildWithMargins，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Override protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { ViewGroup.LayoutParams lp = child.getLayoutParams(); int childWidthMeasureSpec; int childHeightMeasureSpec; childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, getPaddingLeft() + getPaddingRight(), lp.width); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } @Override protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( lp.topMargin + lp.bottomMargin, MeasureSpec.UNSPECIFIED); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }   View中读取xml布局文件中View属性的源码：\n1 2 3 4 5  public void encode(@NonNull ViewHierarchyEncoder stream) { stream.beginObject(this); encodeProperties(stream); stream.endObject(); }   测量模式：EXACTLY/AT_MOST/UNSPECIFIED  EXACTLY 精确测量，子控件大小已经确定 AT_MOST 子控件需要多大就多大，但不超过MeasureSpec.getSize(measureSpec)，如父控件是MATCH_PARENT，子控件是WRAP_CONTENT，则子控件的测量模式是AT_MOST。由于顶级父控件是一个确定的屏幕尺寸，因此只要控件是WRAP_CONTENT，根据getChildMeasureSpec的实现只要它的父控件不是UNSPECIFIED则它的测量模式就是AT_MOST UNSPECIFIED 不加任何限制，子控件要多大就多大，通常是Scrollview高度的测量模式  其他API   getMeasuredState\n将宽度的MeasuredState和高度的MeasuredState合并成一个int类型，高16位是宽度的MeasuredState，低16位是高度的MeasuredState，但MeasuredState只占一个8位长度，所以其实只有高16位的低8位和低16位的低8位是有效值，其高8位都被0填充了\n1 2 3 4 5  public final int getMeasuredState() { return (mMeasuredWidth\u0026amp;MEASURED_STATE_MASK) | ((mMeasuredHeight\u0026gt;\u0026gt;MEASURED_HEIGHT_STATE_SHIFT) \u0026amp; (MEASURED_STATE_MASK\u0026gt;\u0026gt;MEASURED_HEIGHT_STATE_SHIFT)); }     getMeasuredWidthAndState()\n可以看出getMeasuredWidthAndState就是返回mMeasuredWidth值，而我们平时常用的getMeasuredWidth返回的是mMeasuredWidth的低24位，即去除MeasuredState的尺寸值。目前View的MeasuredState似乎只有一个值：MEASURED_STATE_TOO_SMALL\n1 2 3 4 5 6  public final int getMeasuredWidthAndState() { return mMeasuredWidth; } public final int getMeasuredWidth() { return mMeasuredWidth \u0026amp; MEASURED_SIZE_MASK; }     getMeasuredHeightAndState()\n类似getMeasuredWidthAndState()\n  resolveSize\u0026amp;resolveSizeAndState()\nSDK自带的计算尺寸的方法，resolveSizeAndState()是获取带MeasureState的尺寸，resolveSize调用resolveSizeAndState但去除了MeasureState部分保留的是真正的尺寸。setMeasuredDimension()究竟应该传递这两个哪个方法计算的结果？答案：都可以。看你需要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public static int resolveSize(int size, int measureSpec) { return resolveSizeAndState(size, measureSpec, 0) \u0026amp; MEASURED_SIZE_MASK; } public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) { final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) { case MeasureSpec.AT_MOST: if (specSize \u0026lt; size) { result = specSize | MEASURED_STATE_TOO_SMALL; } else { result = size; } break; case MeasureSpec.EXACTLY: result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; } return result | (childMeasuredState \u0026amp; MEASURED_STATE_MASK); }     getMeasureWidth和getWidth  getMeasureWidth\n从源码可以看出getMeasureWidth是mMeasuredWidth的尺寸值部分，而mMeasuredWidth是onMeasure中调用setMeasuredDimension()设置的 1 2 3  public final int getMeasuredWidth() { return mMeasuredWidth \u0026amp; MEASURED_SIZE_MASK; }    getWidth 1 2 3  public final int getWidth() { return mRight - mLeft; }   \n从源码看出getWidth()是边界计算而来，而设置边界是layout方法中调用的setFrame设置的，设置的值是layout方法的参数，而我们自定义View时在在onLayout方法中调用child.layout()传递而来的。而最初的这个值是由谁传递来的呢？说来话长：当我们启动activity时会执行到ActivityThread.handleResumeActivity，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  @Override public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,String reason) { ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); if (r == null) { // We didn\u0026#39;t actually resume the activity, so skipping any follow-up actions.  return; } ... final Activity a = r.activity; ... if (r.window == null \u0026amp;\u0026amp; !a.mFinished \u0026amp;\u0026amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity  // in addView-\u0026gt;ViewRootImpl#setView. If we are instead reusing  // the decor view we have to notify the view root that the  // callbacks may have changed.  ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; wm.addView(decor, l); } else { // The activity will get a callback for this {@link LayoutParams} change  // earlier. However, at that time the decor will not be set (this is set  // in this method), so no action will be taken. This call ensures the  // callback occurs with the decor set.  a.onWindowAttributesChanged(l); } } // If the window has already been added, but during resume  // we started another activity, then don\u0026#39;t yet make the  // window visible.  }else if (!willBeVisible) { if (localLOGV) Slog.v(TAG, \u0026#34;Launch \u0026#34; + r + \u0026#34; mStartedActivity set\u0026#34;); r.hideForNow = true; } }   这其中的impl.notifyChildRebuilt();最终会调用ViewRootImpl自己的performLayout。另外wm.addView(decor, l);也会会如下依次调用WindowManagerGlobal.addView()-\u0026gt;ViewRootImpl.setView()-\u0026gt;ViewRootImpl.requestLayout()-\u0026gt;\u0026hellip;-\u0026gt;ViewRootImpl.performLayout()\n1 2 3 4 5 6 7  private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { ... //这里的host是ViewRootImpl.setView()时传递过来的DecorView，最终实现从的DecorView开始一级一级传递。  host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ... }   由此可以看出getWith()最初是和getMeasuredWidth()有关系的，正常情况两者是一致的。但不是绝对的，你非要让其不一样也是可以的。\n  总结：由于setFrame设置的是控件显示的范围，setMeasuredDimension()设置的是控件测量出来自身需要的尺寸的值。所以with/height代表的是最终控件显示的范围，measuredWidth/measuredheight代表的是理想的测量值\n参考：\n Android 4.3中的视觉边界布局(Optical bounds layout)  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-pulllayout/",
	"title": "自定义View-PullLayout",
	"tags": ["android", "自定义view"],
	"categories": [],
	"series": ["自定义view"],
	"description": "自定义高可用，易扩展下拉刷新上拉加载空间",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
	"title": "设计模式",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
	"title": "设计模式",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
	"title": "设计模式",
	"tags": ["java"],
	"categories": [],
	"series": [],
	"description": "部分设计模式",
	"content": "设计模式是解决问题的思想，是前辈总结的成熟的设计方案。\n设计的总原则是：低耦合、高内聚，实现可复用，易维护。\n设计模式原则   开闭原则\n对扩展开放，对修改关闭。尽量通过扩展软件实体来解决需求变化，而不是通过修改已有的代码来完成变化\n  单一职责原则\n一个类只负责一项职责或者说有且仅有一个原因引起类的变更。单一职责原则提出了一个编程标准，用职责和变化原因衡量接口和类的设计是否优良，但职责和变化原因是不可度量的应因情况而定。\n比如一个用户类只负责用户相关的功能\n好处：类复杂度降低，可读性、维护性、可扩展性提高，降低变更带来的风险。\n  依赖倒置原则\n既面向接口编程，这样通过抽象(接口或抽象类)使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。\n比如Java中每个Service都有一个接口类和实现类，接口一般不会改变，但实现类可能会不断有微小的变化，这样我们都以接口返回给调用者\n  里氏替换原则\n子类可以扩展父类的功能但不要修改父类的功能。这样在父类出现的地方，子类可以完全替换。这可以增强程序的健壮性，即使增加子类原有子类依然可以继续运行。如果子类不能完整实现父类或者父类的某些地方在子类中发生了畸变不能完全替换父类建议断开继承关系使用依赖、组合、聚合等关系替代。\n  接口隔离原则\n设计接口尽量细粒度，最小功能单元，但注意限度，如果过小，则会造成接口数量过多，使设计复杂化。\n  迪米特法则\n降低耦合(局部变量中不要引入新的类)，一个类对自己依赖的类知道的越少越好。\n  设计模式分配 Java中设计模式有三大类：\n 创建型\n工厂模式主要是将对象的创建和对对象使用分开实现解耦。  单例模式 静态工厂模式 将多有对象的创建集中到一个工厂类管理 工厂方法模式 一个工厂只负责一个类的对象创建 抽象工厂模式 将一个系列的类的对象创建合并 建造者模式   结构型  组合模式 当可以使用继承和组合来实现一个功能时优先使用组合 代理模式 适配器模式 桥接模式 装饰模式 外观模式/门面模式   行为型  观察者模式 访问者模式 责任链模式 模版方法模式 策略模式 明亮模式    使用场景及简单使用   简单工厂模式\n 把对象的创建和使用分开 把生产过程集中便于管理 当对象有变化时使用者不需要改变代码\n示例：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  class Apple implements Fruit { } class Orange implements Fruit { } class Banana implements Fruit { } class FruitFactory { //方式一  public static final int FRUIT_APPLE = 0; public static final int FRUIT_ORANGE = 1; public static final int FRUIT_BANANA = 2; public static Fruit getFruit(int fruit) { if (fruit == FRUIT_APPLE) { return new Apple(); } else if (fruit == FRUIT_ORANGE) { return new Orange(); } else if (fruit == FRUIT_BANANA) { return new Banana(); } return null; } //工厂也可以修改成多方法形式  //方式二  public static Apple getApple() { return new Apple(); } public static Orange getOrange() { return new Orange(); } public static Banana getBanana() { return new Banana(); } }     工厂方法模式\n简单工厂模式不符合单一职责原则，而且每次增加新的对象都要修改原有代码，可以修改如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  interface FruitFactory { Fruit getFruit(int fruit); } class AppleFactory implements FruitFactory { @Override public Fruit getFruit(int fruit) { return new Apple(); } } class OrangeFactory implements FruitFactory { @Override public Fruit getFruit(int fruit) { return new Orange(); } } class BananaFactory implements FruitFactory { @Override public Fruit getFruit(int fruit) { return new Banana(); } }     抽象工厂\n如果一个果园销售水果既要采摘水果又要打包，那么既有多个水果工厂又有多个打包工厂，这样采摘和打包工厂很大可能会出错，我们可以把一类水果的采摘和打包放在一个抽象工厂类。\n  建造这模式\n建造者模式适合复杂多变的对象，不同的模版构建过程产生不同的对象有不同的行为。\n  单例模式\n饿汉式\n懒汉式\n  适配器模式\n将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。\n适配器是将原有的对象因为某个需求适配使用，当大量使用适配时可以说是一种设计失误。适配器应该恰当使用或者作为一种对原有代码的补救。\n  桥接模式\n当对象有多个扩展纬度时将多个扩展纬度对象作为构成当前对象的成员变量\n  装饰模式\n装饰器模式装饰器可以多次装饰，附加多个功能。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  public interface Bag { void pack(); } public class AppleBag implements Bag { @Override public void pack() { System.out.print(\u0026#34;--苹果使用纸箱包装\u0026#34;); } } public class BagDecorator implements Bag { private Bag bag; //维持一个对抽象构件对象的引用  public BagDecorator(Bag bag) //注入一个抽象构件类型的对象  { this.bag = bag; } public void pack() { bag.pack(); } } public class CheckedBagDecorator extends BagDecorator { public CheckedBagDecorator(Bag bag) { super(bag); } public void pack() { super.pack(); //调用原有业务方法  checked(); //打印防伪标识  } //增加防伪标识  public void checked() { System.out.println(\u0026#34;------\u0026#34;); System.out.println(\u0026#34;打印上防伪标识\u0026#34;); } }     代理模式\n代理模式即是给目标对象提供一个代理对象，由代理对象控制对目标对象的引用。\n引入代理对象的目的：\n 通过代理对象间接访问目标对象，防止直接访问目标对象带来的不必要的复杂性 通过代理对象对原有的业务增强    组合模式\n组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。它创建了对象组的树形结构。\n使用场景：比如行政区划全国-\u0026gt;省-\u0026gt;市-\u0026gt;区-\u0026gt;乡-\u0026gt;村 这样的树形数据。\n  外观模式\n使用场景：当访问是一个比较复杂的流程过程，将流程封装成一个接口供外部使用\n比如有采摘/打包/发送三个服务，客户端需要分别调用三个服务，而且三个服务中可能还有其他和客户端不相关的功能也暴漏了。这时候可以使用外观模式：新建一个外观类：Facable，客户端只需要调用Facable，而Facable调用采摘/打包/发送三个服务，并屏蔽不相关的功能\n  模版方法模式\n在父类编写模版接口方法，延后到子类实现\n  策略模式\n通过选择不同策略类执行不同算法分支，核心是通过注入对象改变行为。优点类似IOC\n比如优惠券设计有：信任优惠券、满减优惠券、二次购优惠券，当结算时选择不同优惠券策略类执行不同的满减算法。\n  责任链模式\n比如不同的几类优惠券可以叠加使用，可以给优惠券设计链式结构：加上next的优惠券对象，当前优惠券计算完毕直接调用next继续。\n现实中比如客户点菜，客户通知服务员，服务员通知厨师，厨师做好菜服务员端菜递送到客户。\n编程中常用到的如过滤器、拦截器\n  观察者模式\n  命令模式\n通过增加Command抽象命令类将不符合抽象编程的Handle调用转为抽象编程\n  访问者模式\n利用双重分派机制弥补Java中多态中的方法重载是静态化的不足\n  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/",
	"title": "贝塞尔曲线(Bezier curve)",
	"tags": ["编程基础", "android"],
	"categories": [],
	"series": [],
	"description": "贝塞尔曲线详解",
	"content": "前置知识 Bezier曲线是用一系列点控制曲线状态的，主要分为：\n 数据点 确定曲线的起始和结束位置 控制点 确定曲线的弯曲程度  其中数据点又叫锚点，只有起始和结束两个点，控制点有0～n个，按控制点个数可分为一阶贝塞尔曲线，二阶贝塞尔曲线，三阶贝塞尔曲线，\u0026hellip;，N阶贝塞尔曲线\n一阶贝塞尔曲线 0个控制点 即为一条直线\n给定点P0，P1，其中初始点P0，结束点P1，t为比率，在P0，P1上取一点D，D即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=t $$\n一阶比较简单我们作为例子演算出公式，上面的表达式可改写为：\n$$ \\frac{D-P_0}{P_1-P_0}=t $$\n再进一步演算为：\n$$ D=t*({P_1-P_0})+P_0 $$\nD记为B(t)，推出公式：\n$$ B(t)=(1-t)P_0+tP_1,t{\\in}[0,1] $$\n二阶贝塞尔曲线(quadratic Bezier curve) 1个控制点\n给定点P0，P1，P2，其中初始点P0，结束点P2，控制点P1，t为比率，在P0P1上取一点D，P1P2取一点E，在DE上取一点F，F即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=\\frac{P_1E}{P_1P_2}=\\frac{DF}{DE}=t $$\n推出公式：\n$$ B(t)=(1-t)^2P_0+2t(1-t)P_1+t^2P_2,t{\\in}[0,1] $$\n三阶贝塞尔曲线(cubic Bezier curve) 2个控制点\n给定点P0，P1，P2，P3，其中初始点P0，结束点P3，控制点P1，P2，t为比率，在P0P1上取一点D，P1P2取一点E，P2P3取一点F，在DE上取一点G，在EF上取一点H，在GH上取一点I，I即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=\\frac{P_1E}{P_1P_2}=\\frac{P_2F}{P_2P_3}=\\frac{DG}{DE}=\\frac{EH}{EF}=\\frac{GI}{GH}=t $$\n推出公式：\n$$ B(t)=(1-t)^3P_0+3P_1t(1-t)^2+3P_2t^2(1-t)+P_3t^3,t{\\in}[0,1] $$\n多阶贝塞尔曲线 \u0026hellip;\n贝塞尔曲线的意义 确定初始点和结束点，很容易利用控制点得到一条曲线，控制简单。因此贝塞尔曲线在Android动画中有很多应用,比如Android中的PathInterpolator,PathInterpolator初始点是(0,0)，结束点是(1,1)，构造方法中传入控制点\n参考：\n cubic-bezier  "
},
{
	"uri": "https://dshcao.github.io/zh/series/%E9%9F%B3%E8%A7%86%E9%A2%91/",
	"title": "音视频",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/",
	"title": "音视频",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/",
	"title": "音视频",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/about/",
	"title": "关于",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Hugo, dshcao about",
	"content": "  GitHub.\n  掘金.\n  微博.\n  "
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E9%9A%8F%E7%AC%94/",
	"title": "随笔",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E9%9A%8F%E7%AC%94/",
	"title": "随笔",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/",
	"title": "随笔",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Note page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/android/%E9%9A%8F%E8%AE%B0/",
	"title": "随记",
	"tags": ["随笔"],
	"categories": [],
	"series": [""],
	"description": "小知识点",
	"content": "一、Manifest配置 allowBackup fullBackupContent https://developer.android.com/guide/topics/data/autobackup\nallowBackup配置用来开启停用自动备份\nfullBackupContent用来配置配分规则，如：android:fullBackupContent=\u0026rdquo;@xml/backup_rules\u0026rdquo;\n1 2 3 4 5 6 7 8 9  \u0026lt;!--backup_rules --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;full-backup-content\u0026gt; \u0026lt;include domain=[\u0026#34;file\u0026#34; | \u0026#34;database\u0026#34; | \u0026#34;sharedpref\u0026#34; |\u0026#34;external\u0026#34; | \u0026#34;root\u0026#34;] path=\u0026#34;string\u0026#34; requiredFlags=[\u0026#34;clientSideEncryption\u0026#34; | \u0026#34;deviceToDeviceTransfer\u0026#34;] /\u0026gt; \u0026lt;exclude domain=[\u0026#34;file\u0026#34; | \u0026#34;database\u0026#34; | \u0026#34;sharedpref\u0026#34; |\u0026#34;external\u0026#34; | \u0026#34;root\u0026#34;] path=\u0026#34;string\u0026#34; /\u0026gt; \u0026lt;/full-backup-content\u0026gt;   另外还可实现BackupAgent应用于你的备份逻辑\n如何保证序列化和反序列化仍然是同一个对象？比如单例模式从而实现线程安全\nprotected Object readResolve() throws ObjectStreamException {\nreturn mInstance;\n}\n原因，看ObjectInputStream注释文档\ncustomized: any class-specific readObject, readObjectNoData, and readResolve methods defined by enum types are ignored during deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored--all enum types have a fixed serialVersionUID of 0L. ObjectInputStream反序列化源码检测是否定义了readResolve()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  if (obj != null \u0026amp;\u0026amp; handles.lookupException(passHandle) == null \u0026amp;\u0026amp; desc.hasReadResolveMethod()){ Object rep = desc.invokeReadResolve(obj); if (unshared \u0026amp;\u0026amp; rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Android-removed: ObjectInputFilter logic, to be reconsidered. http://b/110252929  /* // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } */ handles.setObject(passHandle, obj = rep); } }   suppressLayout suppressLayout(true)会将mSuppressLayout标志置为true时所有触发layout()操作不会执行真正的layout()，而是在layout()中将mLayoutCalledWhileSuppressed标志置为true，直到suppressLayout(false)重置mSuppressLayout标志时会触发执行一次requestLayout()，并将mLayoutCalledWhileSuppressed置为false\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * Tells this ViewGroup to suppress all layout() calls until layout * suppression is disabled with a later call to suppressLayout(false). * When layout suppression is disabled, a requestLayout() call is sent * if layout() was attempted while layout was being suppressed. */ public void suppressLayout(boolean suppress) { mSuppressLayout = suppress; if (!suppress) { if (mLayoutCalledWhileSuppressed) { requestLayout(); mLayoutCalledWhileSuppressed = false; } } }   getLocationOnScreen clipBounds finishActivity public void finishActivity(int requestCode)\nandroid:windowIsTranslucent=true 适配 Activity android:persistableMode=\u0026quot;persistAcrossReboots\u0026rdquo; PersistableBundle\nUniversal Android Music Player Sample\nhttps://github.com/android/uamp.git\nStackView的循环实现 优秀博客 https://blog.csdn.net/aigestudio?t=1\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/blogging/",
	"title": "Blogging",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/ctest/",
	"title": "cTest",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/development/",
	"title": "Development",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/fast/",
	"title": "fast",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/go/",
	"title": "Go",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/go-web-dev/",
	"title": "Go Web Dev",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-1/",
	"title": "Note-1",
	"tags": ["Development", "Go", "fast", "Blogging"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
	"content": "post-1 content\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec. Quisque metus tellus, tincidunt eu consequat consequat, placerat sed ante. Cras pulvinar eros ex, vel luctus eros viverra sed. Donec nec quam aliquam, ultricies neque sed, sollicitudin lorem. Aenean faucibus, velit et facilisis semper, leo tellus pellentesque orci, non suscipit libero ipsum sed lacus. Fusce pharetra arcu sed tellus convallis, vel hendrerit turpis rhoncus.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-2/",
	"title": "Note-2",
	"tags": ["Go", "fast", "Blogging"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis,",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-3/",
	"title": "Note-3",
	"tags": ["Development", "Go", "fast"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis,",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-1-1/go-1/",
	"title": "Go 1",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 1 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-2/",
	"title": "Go 2",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 2 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-4/",
	"title": "Go 4",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 4 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-1-1/go-1-1-1/go-5/",
	"title": "Go 5",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 5 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/",
	"title": "Java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Note Sub List",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": "s\u0026mdash;\ntitle: \u0026ldquo;Android-事件分发机制\u0026rdquo;\ndate: 2019-10-11T10:33:41+09:00\ndescription: \u0026ldquo;Android-事件分发机制详解\u0026rdquo;\ntags: [\n\u0026ldquo;android\u0026rdquo;\n]\nseries: [\n\u0026ldquo;android\u0026rdquo;,\u0026ldquo;自定义view\u0026rdquo;\n]\ncategories: [\n\u0026ldquo;android\u0026rdquo;\n] View mAttachInfo初始化 查看View源码可以知道mAttachInfo是在dispatchAttachedToWindow中赋值的\nView#dispatchAttachedToWindow\n1 2 3 4 5 6 7  @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P) void dispatchAttachedToWindow(AttachInfo info, int visibility) { mAttachInfo = info; ... onAttachedToWindow(); ... }   继续追踪可以知道View的dispatchAttachedToWindow是在ViewGroup的dispatchAttachedToWindow调用的。\nViewGroup#dispatchAttachedToWindow\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Override @UnsupportedAppUsage void dispatchAttachedToWindow(AttachInfo info, int visibility) { mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; super.dispatchAttachedToWindow(info, visibility); mGroupFlags \u0026amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i \u0026lt; count; i++) { final View child = children[i]; child.dispatchAttachedToWindow(info, combineVisibility(visibility, child.getVisibility())); } final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size(); for (int i = 0; i \u0026lt; transientCount; ++i) { View view = mTransientViews.get(i); view.dispatchAttachedToWindow(info, combineVisibility(visibility, view.getVisibility())); } }   那么ViewGroup#dispatchAttachedToWindow最初是在哪调用的呢？答案是：Activity启动是执行ActivityThread.handleResumeActivity最终会调用到ViewRootImpl中，mAttachInfo即是在ViewRootImpl的构造方法中创建，并在ViewRootImpl#performTraversals中由DecorView调用dispatchAttachedToWindow实现mAttachInfo依次向下传递。\nViewRootImpl#performTraversals\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public ViewRootImpl(Context context, Display display) { ... mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this, context); ... } private void performTraversals() { ... mAttachInfo.mUse32BitDrawingCache = true; mAttachInfo.mWindowVisibility = viewVisibility; mAttachInfo.mRecomputeGlobalAttributes = false; ... //这里的host即是DecorView  host.dispatchAttachedToWindow(mAttachInfo, 0); mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); ... }   上面是在Activiy生命周期中的调用，如果是动态添加的View其dispatchAttachedToWindow是怎么调用的呢？顺着ViewGroup#addView方法可以看到最终会在addViewInner中调用。\n1 2 3 4 5  private void addViewInner(View child, int index, LayoutParams params,boolean preventRequestLayout) { ... child.dispatchAttachedToWindow(mAttachInfo, (mViewFlags\u0026amp;VISIBILITY_MASK)); ... }   isInTouchMode/isFocusableInTouchMode()/setFocusableInTouchMode(boolean) 是否是触摸模式。因为android不仅支持屏幕触摸操作还支持键盘等设备操作。当使用键盘操作时需要对当前操作的UI元素高亮(聚焦)让用户知道当前操作的是哪个UI元素。触摸操作时不需要一直高亮某个UI元素，用户操作的是哪个UI元素就去触摸哪个元素。触摸模式下只需要在按下时高亮(聚焦)即可，此时的高亮(聚焦)是由设置的pressed状态决定的。为了区别两种模式就有了touchmode，isInTouchMode即是当前是否是触摸模式。\nView#isInTouchMode\n1 2 3 4 5 6 7  public boolean isInTouchMode() { if (mAttachInfo != null) { return mAttachInfo.mInTouchMode; } else { return ViewRootImpl.isInTouchMode(); } }   上面说过触摸模式下不需要高亮(聚焦)，但某些特殊控件如：EditText需要在触摸模式下也能获取焦点。isFocusableInTouchMode()/setFocusableInTouchMode(boolean)判断/设置View在触摸模式下是否可以获取焦点\nonFilterTouchEventForSecurity 过滤TouchEvent应对安全策略。可以在这里过滤TouchEvent，false则丢弃TouchEvent，true则不过滤继续分发这个TouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * Filter the touch event to apply security policies. * * @param event The motion event to be filtered. * @return True if the event should be dispatched, false if the event should be dropped. * * @see #getFilterTouchesWhenObscured */ public boolean onFilterTouchEventForSecurity(MotionEvent event) { //noinspection RedundantIfStatement  if ((mViewFlags \u0026amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 \u0026amp;\u0026amp; (event.getFlags() \u0026amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) { // Window is obscured, drop this touch.  return false; } return true; }   什么是FILTER_TOUCHES_WHEN_OBSCURED和MotionEvent.FLAG_WINDOW_IS_OBSCURED呢，看View源码的一段注释：\n1 2 3 4 5 6 7 8 9 10  * To enable touch filtering, call {@link #setFilterTouchesWhenObscured(boolean)} or set the * android:filterTouchesWhenObscured layout attribute to true. When enabled, the framework * will discard touches that are received whenever the view\u0026#39;s window is obscured by * another visible window. As a result, the view will not receive touches whenever a * toast, dialog or other window appears above the view\u0026#39;s window. * \u0026lt;/p\u0026gt;\u0026lt;p\u0026gt; * For more fine-grained control over security, consider overriding the * {@link #onFilterTouchEventForSecurity(MotionEvent)} method to implement your own * security policy. See also {@link MotionEvent#FLAG_WINDOW_IS_OBSCURED}. * \u0026lt;/p\u0026gt;   说的清楚FILTER_TOUCHES_WHEN_OBSCURED是setFilterTouchesWhenObscured(boolean)设置的表示可以过滤模糊不清楚的TouchEvent，MotionEvent#FLAG_WINDOW_IS_OBSCURED表示当前TouchEvent是模糊不清楚的。什么是模糊不清楚呢？当toast dialog等显示在这个view上时在这个view区域上的TouchEvent对这个view来说即是模糊不清楚的，这个TouchEvent会被添加MotionEvent#FLAG_WINDOW_IS_OBSCUREDflag，view默认会过滤这样的TouchEvent。\nrequestDisallowInterceptTouchEvent 当子控件不想父控件及其祖先控件拦截TouchEvent时可以调用此方法，该方法会逐级调用父控件requestDisallowInterceptTouchEvent通知父控件及其祖先控件不要拦截\nViewGroup#requestDisallowInterceptTouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * Called when a child does not want this parent and its ancestors to * intercept touch events with * {@link ViewGroup#onInterceptTouchEvent(MotionEvent)}. * * \u0026lt;p\u0026gt;This parent should pass this call onto its parents. This parent must obey * this request for the duration of the touch (that is, only clear the flag * after this parent has received an up or a cancel.\u0026lt;/p\u0026gt; * * @param disallowIntercept True if the child does not want the parent to * intercept touch events. */ @Override public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We\u0026#39;re already in this state, assume our ancestors are too  return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags \u0026amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent  if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); } }   dispatchTouchEvent Android触摸事件的生成、传递和分发见深入理解Android之Touch事件的分发。最终会传递到ViewRootImpl调用ViewRootImpl#processPointerEvent处理。ViewRootImpl#processPointerEvent中会调用DecorView#dispatchPointerEvent处理。DecorView#dispatchPointerEvent会调用父类View#dispatchPointerEvent，该方法中判断event.isTouchEvent()，若是TouchEvent，调用DecorView#dispatchTouchEvent。DecorView#dispatchTouchEvent最终会调用Window#Callback#dispatchTouchEvent或者ViewGroup#dispatchTouchEvent。\nDecorView#dispatchTouchEvent \nViewRootImpl#processPointerEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  private int processPointerEvent(QueuedInputEvent q) { final MotionEvent event = (MotionEvent)q.mEvent; mAttachInfo.mUnbufferedDispatchRequested = false; mAttachInfo.mHandlingPointerEvent = true; boolean handled = mView.dispatchPointerEvent(event); maybeUpdatePointerIcon(event); maybeUpdateTooltip(event); mAttachInfo.mHandlingPointerEvent = false; if (mAttachInfo.mUnbufferedDispatchRequested \u0026amp;\u0026amp; !mUnbufferedInputDispatch) { mUnbufferedInputDispatch = true; if (mConsumeBatchedInputScheduled) { scheduleConsumeBatchedInputImmediately(); } } return handled ? FINISH_HANDLED : FORWARD; }   View#dispatchPointerEvent\n1 2 3 4 5 6 7 8  @UnsupportedAppUsage public final boolean dispatchPointerEvent(MotionEvent event) { if (event.isTouchEvent()) { return dispatchTouchEvent(event); } else { return dispatchGenericMotionEvent(event); } }   DecorView#dispatchTouchEvent\n1 2 3 4 5 6 7 8 9 10  /** The feature ID of the panel, or -1 if this is the application\u0026#39;s DecorView */ private final int mFeatureId; @Override public boolean dispatchTouchEvent(MotionEvent ev) { final Window.Callback cb = mWindow.getCallback(); //如果当前window#Callback不为null，window也没有销毁，且window的panel是DecorView则调用window#Callback的dispatchTouchEvent，否则调用ViewGroup#dispatchTouchEvent  return cb != null \u0026amp;\u0026amp; !mWindow.isDestroyed() \u0026amp;\u0026amp; mFeatureId \u0026lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); }   Activity#dispatchTouchEvent Activity是继承Window.Callback的，由上面DecorView#dispatchTouchEvent源码可知Activity中DecorView#dispatchTouchEvent会走Window.Callback#dispatchTouchEvent。即Activity#dispatchTouchEvent。\n从ViewRootImpl开始到Activity的调用链：ViewRootImpl#processPointerEvent -\u0026gt; DecorView#dispatchPointerEvent -\u0026gt; View#dispatchPointerEvent -\u0026gt; DecorView#dispatchTouchEvent -\u0026gt; Activity#dispatchTouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { // 回调表示当前activity进入和用户互动状态，与之对应的是onUserLeaveHint，该方法由performUserLeaving方法调用，而performUserLeaving是在ActivityThread#handlePauseActivity中满足userLeaving参数为true时调用。那么userLeaving什么情况下为true呢？大致是用户主动操作导致activity进入pause状态时。非用户主动操作如来电导致当前activity进入pasuse时userLeaving=false，performUserLeaving不会被调用。需要注意的是performUserLeaving不只调用onUserLeaveHint还会再次调用onUserInteraction。所以onUserInteraction可能会被调用两次。onUserInteraction回调旨在帮助activities智能地管理状态栏通知；特别是帮助activities确定取消通知的正确时间  onUserInteraction(); } //调用window的superDispatchTouchEvent分发事件。最终是PhoneWindow#superDispatchTouchEvent调用DecorView#superDispatchTouchEvent，再由DecorView#superDispatchTouchEvent调用DecorView#dispatchTouchEvent实现逐级下发询问子控件  if (getWindow().superDispatchTouchEvent(ev)) { return true; } //如果没有view消费TouchEvent，则调用activity的onTouchEvent处理  return onTouchEvent(ev); } public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; }   View#dispatchTouchEvent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  public boolean dispatchTouchEvent(MotionEvent event) { ... boolean result = false; //开启本view检查器检查事件的连续性  if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); //如果是ACTION_DOWN事件，通知可能存在的上一次嵌套滚动停止  if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture  stopNestedScroll(); } //如果事件没有被过滤丢弃  if (onFilterTouchEventForSecurity(event)) { //控件是enable状态且事件被scrollbar消费  if ((mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement  ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnTouchListener != null \u0026amp;\u0026amp; (mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } //如果事件没有被scrollbar/OnTouchListener消费询问控件本身是否消费  if (!result \u0026amp;\u0026amp; onTouchEvent(event)) { result = true; } } //通知事件连续性验证器事件未被本view消费，不再做事件连续性验证  if (!result \u0026amp;\u0026amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } // Clean up after nested scrolls if this is the end of a gesture;  // also cancel it if we tried an ACTION_DOWN but we didn\u0026#39;t want the rest  // of the gesture.  //如果事件结束或者当前view没有消费事件，通知嵌套滚动通知滚动  if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; !result)) { stopNestedScroll(); } return result; }   ViewGroup#dispatchTouchEvent 分析源码前我们首先要了解一个变量：mFirstTouchTarget。它是一个链表的结构将TouchTargets链接起来。而这个mFirstTouchTarget就是链表的首个元素。其初始化是在ViewGroup#dispatchTouchEvent中调用的addTouchTarget中初始化的。addTouchTarget唯一被ViewGroup#dispatchTouchEvent调用。\ndispatchTouchEvent流程：\n如果是ACTION_DOWN事件，先清除之前可能因为app切换/ANR或者其他一些状态改变导致的未完成的事件序列，正常的时间序列应该是ACTION_DOWN-\u0026gt;ACTION_UP/ACTION_CANCEL。如果有未完成的事件序列则发送一个ACTION_CANCEL事件结束这个事件序列以便开始当前ACTION_DOWN事件触发的事件序列。清除动作包括清除相关flag，释放TouchTargets，将mFirstTouchTarget置为null\n1 2 3  // First touch target in the linked list of touch targets. @UnsupportedAppUsage private TouchTarget mFirstTouchTarget;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347  public boolean dispatchTouchEvent(MotionEvent ev) { //开启ViewGroup EventConsistency检查器检查事件的连续性  if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } ... boolean handled = false; //如果事件没有被过滤丢弃  if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action \u0026amp; MotionEvent.ACTION_MASK; // Handle an initial down.  if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture.  // The framework may have dropped the up or cancel event for the previous gesture  // due to an app switch, ANR, or some other state change.  //1.清除View(target.child)暂不接受TouchEvent的标志：PFLAG_CANCEL_NEXT_UP_EVENT以便接收新的事件序列  //2.如果mFirstTouchTarget不为null则会合成cancel event或者将ev暂时设置成ACTION_CANCEL传递给TouchTargets完成事件序列或者叫做清除上次的事件序列目的是以此次ACTION_DOWN event事件作为新的事件序列。  //3.mFirstTouchTarget重置为null  cancelAndClearTouchTargets(ev); //清除相关flag  resetTouchState(); // private void resetTouchState() {  // clearTouchTargets();  // resetCancelNextUpFlag(this);  // mGroupFlags \u0026amp;= ~FLAG_DISALLOW_INTERCEPT;  // mNestedScrollAxes = SCROLL_AXIS_NONE;  // }  } // Check for interception.  final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { //检查子控件是否调用了requestDisallowInterceptTouchEvent通知父控件不要拦截  //由于ACTION_DOWN时前面的resetTouchState会被调用，而resetTouchState方法中有 mGroupFlags \u0026amp;= ~FLAG_DISALLOW_INTERCEPT;，所以当ACTION_DOWN时此处的disallowIntercept肯定为false，即ACTION_DOWN时肯定会执行onInterceptTouchEvent，若在ACTION_DOWN时当前ViewGroup#onInterceptTouchEvent就返回true，那么子控件调用mParent.requestDisallowInterceptTouchEvent也是没用的。  final boolean disallowIntercept = (mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); //由于在上面的cancelAndClearTouchTargets-\u0026gt;dispatchTransformedTouchEvent方法中action有可能被临时设置为ACTION_CANCEL，在这里对其恢复  ev.setAction(action); // restore action in case it was changed  } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down  // so this view group continues to intercept touches.  intercepted = true; } // If intercepted, start normal event dispatch. Also if there is already  // a view that is handling the gesture, do normal event dispatch.  if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // Check for cancelation.  final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed.  final boolean split = (mGroupFlags \u0026amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //既不是ACTION_CANCEL事件且当前ViewGroup又不拦截  if (!canceled \u0026amp;\u0026amp; !intercepted) { // If the event is targeting accessibility focus we give it to the  // view that has accessibility focus and if it does not handle it  // we clear the flag and dispatch the event to all children as usual.  // We are looking up the accessibility focused host to avoid keeping  // state since these events are very rare.  View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down  final int idBitsToAssign = split ? 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they  // have become out of sync.  //清除此pointer id的早期touch targets，以防它们不同步。比如之前这个pointers作用的是A view，先在的ACTION_DOWN事件序列即将作用在B view上，需要先清除，防止同时对A view/B view都有效果  removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026amp;\u0026amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event.  // Scan children from front to back.  //buildTouchDispatchChildList是一个按View Z值排序的list。  final ArrayList\u0026lt;View\u0026gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026amp;\u0026amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i \u0026gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it  // to get the event first and if not handled we will perform a  // normal dispatch. We may do a double iteration but this is  // safer given the timeframe.  if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //canReceivePointerEvents:child可见或者child执行动画中  //isTransformedTouchPointInView:触摸点在child范围内  if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds.  // Give it the new pointer in addition to the ones it is handling.  newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); //向child传递触摸事件，如果消费了事件执行下面内容  if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds.  mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index  for (int j = 0; j \u0026lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn\u0026#39;t handle the event, so clear  // the flag and do a normal dispatch to all children.  ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null \u0026amp;\u0026amp; mFirstTouchTarget != null) { // Did not find a child to receive the event.  // Assign the pointer to the least recently added target.  newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets.  if (mFirstTouchTarget == null) {//事件被自己拦截或没有view消费事件导致mFirstTouchTarget==null  // No touch targets so treat this as an ordinary view.  //handled:true 自己消费了事件  //handled:false 自己未消费事件  handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else {//有view消费事件  // Dispatch to touch targets, excluding the new touch target if we already  // dispatched to it. Cancel touch targets if necessary.  TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026amp;\u0026amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed.  if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } //通知事件连续性验证器事件未被本view消费，不再做事件连续性验证  if (!handled \u0026amp;\u0026amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } } /** * Cancels and clears all touch targets. */ private void cancelAndClearTouchTargets(MotionEvent event) { //如果已经有TouchTarget就构造一个取消触摸事件传递给TouchTarget用于完成整个事件序列  if (mFirstTouchTarget != null) { boolean syntheticEvent = false; if (event == null) { final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; } for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) { //PFLAG_CANCEL_NEXT_UP_EVENT 意为自这次打上该标志起不再接受后面的TouchEvent事件  //清除TouchTarget中被打上暂不接受TouchEvent的标志：PFLAG_CANCEL_NEXT_UP_EVENT以便重新开始接受触摸事件序列。  resetCancelNextUpFlag(target.child); //分发取消TouchEvent完成整个事件序列  dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); } //循环释放TouchTargets对象，将mFirstTouchTarget重置为null  clearTouchTargets(); if (syntheticEvent) { event.recycle(); } } } /** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ //将MotionEvent转换为特定子视图的坐标空间，过滤掉不相关的指针ID，并根据需要覆盖其操作。如果child为空，则假定MotionEvent将被发送到此ViewGroup private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don\u0026#39;t need to perform any transformations  // or filtering. The important part is the action, not the contents.  final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver.  final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits \u0026amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we  // might produce a motion event with no pointers in it, then drop the event.  if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don\u0026#39;t need to perform any fancy  // irreversible transformations, then we can reuse the motion event for this  // dispatch as long as we are careful to revert any changes we make.  // Otherwise we need to make a copy.  final MotionEvent transformedEvent; //多点触控情况判断是否是同一个触控点或者手指  if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); //向child传递分发  handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } //如果child不为null且child经过缩放/平移/旋转变换则构建一个新的event供后面根据child的缩放做相应的transform处理  transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch.  //当ACTION_DOWN事件被自己拦截时child==null  if (child == null) { //super.dispatchTouchEvent即是View#dispatchTouchEvent，逻辑最终是调用自己的onTouchEvent，即自己处理  handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); //如果child经过缩放/平移/旋转变换那么transformedEvent也做相应变化  if (! child.hasIdentityMatrix()) { //getInverseMatrix反变换操作  transformedEvent.transform(child.getInverseMatrix()); } //向下传递事件  handled = child.dispatchTouchEvent(transformedEvent); } // Done.  transformedEvent.recycle(); return handled; }   ViewGroup#onInterceptTouchEvent 一般自定义view都需要重写该方法\n1 2 3 4 5 6 7 8 9 10  public boolean onInterceptTouchEvent(MotionEvent ev) { //默认实现只拦截来自鼠标的作用在滚动滑块的ACTION_DOWN事件  if (ev.isFromSource(InputDevice.SOURCE_MOUSE) \u0026amp;\u0026amp; ev.getAction() == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) \u0026amp;\u0026amp; isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; }   View#onTouchEvent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237  /** * Implement this method to handle touch screen motion events. * \u0026lt;p\u0026gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * {@link #performClick()}. This will ensure consistent system behavior, * including: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;obeying click sound preferences * \u0026lt;li\u0026gt;dispatching OnClickListener calls * \u0026lt;li\u0026gt;handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when * accessibility features are enabled * \u0026lt;/ul\u0026gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */ public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags \u0026amp; CLICKABLE) == CLICKABLE || (viewFlags \u0026amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //view DISABLED状态下如果是clickable则默认消费了事件但不做任何事情，如果是非clickable状态则返回false，不消费事件  if ((viewFlags \u0026amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch  // events, it just doesn\u0026#39;t respond to them.  return clickable; } //如果设置了TouchDelegate，则完全走TouchDelegate的处理逻辑  if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //clickable的view默认消费事件  if (clickable || (viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { handleTooltipUp(); } if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } boolean prepressed = (mPrivateFlags \u0026amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don\u0026#39;t have it already and we should in  // touch mode.  boolean focusTaken = false; if (isFocusable() \u0026amp;\u0026amp; isFocusableInTouchMode() \u0026amp;\u0026amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually  // showed it as pressed. Make it show the pressed  // state now (before scheduling the click) to ensure  // the user sees it.  setPressed(true, x, y); } if (!mHasPerformedLongPress \u0026amp;\u0026amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check  removeLongPressCallback(); // Only perform take click actions if we were in the pressed state  if (!focusTaken) {//当前有焦点触发onclick事件  // Use a Runnable and post this rather than calling  // performClick directly. This lets other visual state  // of the view update before click actions start.  if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClickInternal(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now  mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } mHasPerformedLongPress = false; if (!clickable) { checkForLongClick( ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); break; } if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we\u0026#39;re inside a scrolling container.  boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for  // a short period in case this is a scroll.  if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away  setPressed(true, x, y); checkForLongClick( ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); } break; case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) { drawableHotspotChanged(x, y); } final int motionClassification = event.getClassification(); final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE; int touchSlop = mTouchSlop; if (ambiguousGesture \u0026amp;\u0026amp; hasPendingLongPressCallback()) { final float ambiguousMultiplier = ViewConfiguration.getAmbiguousGestureMultiplier(); if (!pointInView(x, y, touchSlop)) { // The default action here is to cancel long press. But instead, we  // just extend the timeout here, in case the classification  // stays ambiguous.  removeLongPressCallback(); long delay = (long) (ViewConfiguration.getLongPressTimeout() * ambiguousMultiplier); // Subtract the time already spent  delay -= event.getEventTime() - event.getDownTime(); checkForLongClick( delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); } touchSlop *= ambiguousMultiplier; } // Be lenient about moving outside of buttons  if (!pointInView(x, y, touchSlop)) { // Outside button  // Remove any future long press/tap checks  removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; } final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS; if (deepPress \u0026amp;\u0026amp; hasPendingLongPressCallback()) { // process the long click action immediately  removeLongPressCallback(); checkForLongClick( 0 /* send immediately */, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS); } break; } return true; } return false; }   MotionEvent  key event 键盘、遥控器按键，鼠标点击会生成按键事件（key event） hover event 鼠标在屏幕上的停留、滑动会产生hover event scroll event 鼠标滚轮的滚动会生成scroll event touch event 对触屏设备，当用户用手指或触控笔在设备屏幕上操作时会产生触屏事件（touch event）\n其中MotionEvent是对hover event\u0026amp;scroll event\u0026amp;touch event的封装\nKeyEvent是对key event的封装  ACTION说明 event.getAction() action中0~7存储类别，8~15存储pointerIndex，这从getAction、getActionMasked和getActionIndex源码就可以看出来。pointerIndex和pointerId都是从0开始的整数。\n指针id(pointerId)和指针index(pointerIndex)\npointerId在整个手势操作过程中是不会变化的，可以根据pointerId跟踪某个pointer\npointerIndex在整个手势操作过程中会随着手指的增减变化\n ACTION_DOWN 多点触控第一个指针按下，如果当前触摸设备已经有存在pointer则 ACTION_UP 多点触控最后指针抬起，不一定是ACTION_DOWN对应的指针，可能是ACTION_POINTER_DOWN对应的指针 ACTION_MOVE 指针移动 ACTION_CANCEL 触摸取消，可以视为ACTION_UP事件，但不要做ACTION_UP的任何操作。ACTION_CANCEL发生的时机通常有几种：1.主动发送 2.重新开始一个事件序列时可能被程序触发 3.当接收过ACTION_DOWN事件的view在后面的ACTION_MOVE被父控件拦截时会触发ACTION_CANCEL事件，具体实现在ViewGroup#dispatchTouchEvent源码中： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view.  handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already  // dispatched to it. Cancel touch targets if necessary.  TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026amp;\u0026amp; target == newTouchTarget) { handled = true; } else { //被拦截后cancelChild为true  final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; //dispatchTransformedTouchEvent会向子view分发ACTION_CANCEL事件  if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } }    ACTION_OUTSIDE 在UI元素之外发生的触摸事件 ACTION_POINTER_DOWN 多点触控使用，非第一个指针按下 ACTION_POINTER_UP 多点触控使用，非最后一个指针抬起  其余如：ACTION_SCROLL/ACTION_BUTTON_PRESS/ACTION_BUTTON_RELEASE/ACTION_HOVER_ENTER/ACTION_HOVER_MOVE/ACTION_HOVER_EXIT 非触摸事件action，这些事件传递到onGenericMotionEvent(MotionEvent)处理\n getDeviceId() 返回event来源设备的id，通常是触摸屏。可用于InputDevice.getDevice(deviceId)获取InputDevice后进一步获取相关信息 getActionIndex() 获取当前event的pointerIndex getPointerId(pointerIndex) 获取指定pointerIndex的pointerId findPointerIndex(pointerId) 获取指定pointerId的pointerIndex，其和getActionIndex()的返回值意义是一样的，区别在于一个是获得当前event的pointerIndex，一个是获取指定pointerId pointer的pointerIndex getHistorySize() 获取event的历史触控点数，仅适用于ACTION_MOVE getRawX(int pointerIndex) 返回未经过接受触摸事件窗口和视图调整的相对于屏幕的原始坐标 getX(pointerIndex) 获取指定pointerIndex pointer当前触控点的相对于接受触摸事件窗口和视图的x坐标 getHistoricalX(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点的x坐标，pos小于getHistorySize() getSize(pointerIndex) 获取指定pointerIndex pointer当前触控点与触摸设备的按压接触面积大小。范围是0~1，至于0~1代表具体像素范围和触摸设备有关 getHistoricalSize(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点与触摸设备的按压接触面积大小 getPressure(pointerIndex) 获取指定pointerIndex pointer当前触控点的压力值。通常压力值是0(毫无压力)~1(正常压力)，但根据具体的输入设备校准，压力也可能是大于1的值 getHistoricalPressure(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点的压力值 getOrientation()/getHistoricalOrientation() (历史)触控点的方向，范围-PI/2~PI/2。可以将手指或触控笔与屏幕接触点的接触面积类似的看作一个椭圆。那么以长轴向上弧度为0，是垂直方向；长轴指向左边则是正值0~PI/2，长轴指向右边则是负值0~-PI/2。当然手指或触控笔与屏幕接触点的接触面积可能是一个正圆形。那么此时的方向是未知的 getTouchMajor()/getHistoricalTouchMajor() 将手指或触控笔与屏幕接触点的接触面积类似的看作一个椭圆。返回该椭圆长轴的长度 setEdgeFlags(flags)/getEdgeFlags() 触摸的是否是edge。getEdgeFlags仅在ACTION_DOWN事件中使用。 getFlags() 见：FLAG_WINDOW_IS_OBSCURED/FLAG_WINDOW_IS_PARTIALLY_OBSCURED  FLAG_WINDOW_IS_OBSCURED 表示接受触摸事件的窗口被其上另一个可见的窗口部分或全部遮挡。如果该触摸事位置是其上可见的窗口区域则返回true。安全敏感的应用程序可以检查此标志，以确定恶意应用程序可能为了误导用户或劫持操作而掩盖其部分内容的情况。 FLAG_WINDOW_IS_PARTIALLY_OBSCURED 类似FLAG_WINDOW_IS_OBSCURED，但触摸事位置不一定是在其上可见窗口的区域。   getXPrecision() 返回X坐标的精度。你可以用getX()乘以这个数字来找到X坐标的实际硬件值   setLocation(x, y)/offsetLocation(deltaX, deltaY) 设置/调整触摸事件的位置 transform(matrix) 使用矩阵转换event所有触控点  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public final int getAction() { return nativeGetAction(mNativePtr); } //取低八位ACTION类别信息 public final int getActionMasked() { //取低八位有效值，去除8~15位的pointerIndex信息  return nativeGetAction(mNativePtr) \u0026amp; ACTION_MASK; } //为ACTION_POINTER_DOWN/ACTION_POINTER_UP操作使用的，返回的是pointer index。当getPointerId(int)/getX(int)/getY(int)/getPressure(int)/getSize(int)时使用 public final int getActionIndex() { //取高8~16位有效值，然后右移8位  return (nativeGetAction(mNativePtr) \u0026amp; ACTION_POINTER_INDEX_MASK) \u0026gt;\u0026gt; ACTION_POINTER_INDEX_SHIFT; }   View如何实现longclick事件的 参考：\n 深入理解Android之Touch事件的分发 getEdgeFlags always returning 0? MotionEvent 详解  "
}]