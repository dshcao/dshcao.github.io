[
{
	"uri": "https://dshcao.github.io/zh/",
	"title": "",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/",
	"title": "Categories",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/",
	"title": "Series",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/",
	"title": "Tags",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/",
	"title": "文章",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Post page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E8%87%AA%E5%AE%9A%E4%B9%89view/",
	"title": "自定义view",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-imagecropview/",
	"title": "自定义view-ImageCropView",
	"tags": ["android", "自定义view"],
	"categories": [],
	"series": ["自定义view"],
	"description": "一个文件实现自定义头像裁剪控件",
	"content": "项目中需要为用户截取头像，刚开始调用系统自带功能，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  Intent intent = new Intent(\u0026#34;com.android.camera.action.CROP\u0026#34;); intent.setDataAndType(Uri.fromFile(new File(itemData.getPath())), \u0026#34;image/*\u0026#34;); intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION); intent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION); // crop=true是设置在开启的Intent中设置显示的VIEW可裁剪 intent.putExtra(\u0026#34;crop\u0026#34;, \u0026#34;true\u0026#34;); // aspectX aspectY 是宽高的比例 intent.putExtra(\u0026#34;aspectX\u0026#34;, 1); intent.putExtra(\u0026#34;aspectY\u0026#34;, 1); // outputX outputY 是裁剪图片宽高 intent.putExtra(\u0026#34;outputX\u0026#34;, 350); intent.putExtra(\u0026#34;outputY\u0026#34;, 350); intent.putExtra(\u0026#34;scale\u0026#34;, true); intent.putExtra(\u0026#34;noFaceDetection\u0026#34;, false);//取消人脸识别功能 intent.putExtra(\u0026#34;outputFormat\u0026#34;, Bitmap.CompressFormat.PNG.toString()); //true则图片在intent中返回，如果图片过大，会导致oom，这里设置为false intent.putExtra(\u0026#34;return-data\u0026#34;, false); File avatar = new File(getExternalFilesDir(Environment.DIRECTORY_PICTURES), AppConfig.Path.AVATAR); // FileProvider.getUriForFile(AvatarPickerActivity.this, getPackageName() + \u0026#34;.provider\u0026#34;, new File(itemData.getPath())); Uri outputUri = Uri.fromFile(avatar);//裁剪后输出位置 intent.putExtra(MediaStore.EXTRA_OUTPUT, outputUri); startActivityForResult(intent, REQUEST_CROP);   但使用过程中发现各手机ui不一致，更严重的是发现锤子手机有问题，锤子手机缩放图片后截取的图像仍是未缩放时的区域，然后就一顿搜索发现github上有不少这个项目，但效果不满意，且实现复杂，就这一个功能拆成N个文件。\n代码讲究 高内聚 低耦合 可重用\n最终目的方便维护\n首先分析如何实现：\n重写onDraw添加自己的逻辑代码，画一层蒙板，蒙板要覆盖整个imageview,周围是半透明，中间是方形或者圆形透明区域，可以用Path实现，还需要手势支持，所以还要用到GestureDetector ScaleGestureDetector，另外图片大小不一，第一次加载到imageview中肯定不是原尺寸，要经过缩放，那我们缩放到什么程度呢？因为我们截图不能使图像缩放小于中间透明区域，所以我们规定初次加载图像最短边缩放到中间透明区域，这里图片说明，这里还用到Matrix从来缩放图像,不太了解的可先看下文档谷歌一下\n首先为了使用方便自定义属性：\n1 2 3 4 5 6 7 8 9 10  \u0026lt;declare-styleable name=\u0026#34;ImageCropView\u0026#34;\u0026gt; \u0026lt;attr name=\u0026#34;aspectX\u0026#34; format=\u0026#34;integer\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;aspectY\u0026#34; format=\u0026#34;integer\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewStrokeColor\u0026#34; format=\u0026#34;color|reference\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewStrokeWidth\u0026#34; format=\u0026#34;dimension\u0026#34; /\u0026gt; \u0026lt;attr name=\u0026#34;viewShape\u0026#34; format=\u0026#34;enum\u0026#34;\u0026gt; \u0026lt;enum name=\u0026#34;square\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;enum name=\u0026#34;circle\u0026#34; value=\u0026#34;2\u0026#34; /\u0026gt; \u0026lt;/attr\u0026gt; \u0026lt;/declare-styleable\u0026gt;   自定义注解取代枚举\nViewShape\n1 2 3 4 5 6 7 8  @Retention(AnnotationRetention.SOURCE) @IntDef(SQUARE, CIRCLE) annotation class ViewShape(val value: Int = CIRCLE) { companion object { const val SQUARE = 1 const val CIRCLE = 1 shl 1 } }   ImageCropView\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117  class ImageCropView @JvmOverloads constructor( context: Context, attrs: AttributeSet? = null, defStyleAttr: Int = 0 ) : AppCompatImageView(context, attrs, defStyleAttr), ViewTreeObserver.OnGlobalLayoutListener, ScaleGestureDetector.OnScaleGestureListener { @ViewShape var viewShape = ViewShape.CIRCLE//透明区域形状  private var viewStrokeWidth: Float = 1f//透明区域Stroke宽度  private var viewStrokeColor: Int = Color.WHITE//透明区域Stroke颜色  private var viewMaskColor: Int = Color.parseColor(\u0026#34;#77000000\u0026#34;)//半透明区域颜色  var aspectX: Int = 1//宽高比  var aspectY: Int = 1//宽高比  private val touchSlop: Int var overViewOffset = RectF() private var overViewSpace: Int = 0//透明区域与控件边缘的space  private var imageSpace: Int = 0//  private val paint: Paint//半透明区域  private val paintS: Paint//stroke  private var gestureDetector: GestureDetector private var scaleGestureDetector: ScaleGestureDetector var mValues = FloatArray(9) var mMatrix = Matrix() var initScale: Float = 0f var minScale: Float = 0f var maxScale: Float = 0f var max = 6 var overViewPath = Path() var overView = RectF() init { if (attrs != null) { val a = context.obtainStyledAttributes(attrs, R.styleable.ImageCropView) viewStrokeWidth = a.getDimension(R.styleable.ImageCropView_viewStrokeWidth, viewStrokeWidth) viewStrokeColor = a.getColor(R.styleable.ImageCropView_viewStrokeColor, viewStrokeColor) viewMaskColor = a.getColor(R.styleable.ImageCropView_viewStrokeColor, viewMaskColor) aspectX = a.getInt(R.styleable.ImageCropView_aspectX, aspectX) aspectY = a.getInt(R.styleable.ImageCropView_aspectY, aspectY) viewShape = if (aspectX != aspectY) ViewShape.SQUARE else viewShape a.recycle() } touchSlop = ViewConfiguration.get(context).scaledTouchSlop setLayerType(View.LAYER_TYPE_SOFTWARE, null) scaleType = ScaleType.MATRIX paint = Paint(Paint.ANTI_ALIAS_FLAG) paint.color = viewMaskColor paintS = Paint(Paint.ANTI_ALIAS_FLAG) paintS.color = viewStrokeColor paintS.style = Paint.Style.STROKE paintS.strokeWidth = viewStrokeWidth if (overViewSpace == 0) overViewSpace = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 42f, resources.displayMetrics) .toInt() imageSpace = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1f, resources.displayMetrics) .toInt() val gestureListener: SimpleOnGestureListener = object :SimpleOnGestureListener() { override fun onDoubleTap(e: MotionEvent): Boolean { //双击时若当前缩放小于最大缩放的一半时就缩放到最大，反之回到到初始加载的缩放  val currScale: Float = getCurrentScale() val midScale: Float = maxScale / (max / 2f) if (currScale \u0026lt; midScale) { val rScale = midScale / currScale scale(rScale, rScale, e.x, e.y) } else { val rScale: Float = initScale / currScale scale(rScale, rScale, e.x, e.y) } return true } override fun onScroll( e1: MotionEvent, e2: MotionEvent, distanceX: Float, distanceY: Float ): Boolean { val dx: Float val dy: Float val matrixRectF: RectF = getMatrixRectF() //滑动时判断滑动的距离是否超出中间透明区域，取两者最小值，即最多只能滑动到透明区域边缘  if (distanceX \u0026lt; 0) { dx = distanceX.coerceAtLeast(matrixRectF.left - overViewOffset.left) } else { dx = distanceX.coerceAtMost(matrixRectF.right - overViewOffset.right) } if (distanceY \u0026lt; 0) { dy = distanceY.coerceAtLeast(matrixRectF.top - overViewOffset.top) } else { dy = distanceY.coerceAtMost(matrixRectF.bottom - overViewOffset.bottom) } translate(-dx, -dy) return true } } gestureDetector = GestureDetector(context, gestureListener) scaleGestureDetector = ScaleGestureDetector(context, this) } ....暂时省略 }   onGlobalLayout中确定初始值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69  override fun onAttachedToWindow() { super.onAttachedToWindow() viewTreeObserver.addOnGlobalLayoutListener(this) } //onGlobalLayout作用是获取构造函数中获取不到的尺寸以便确定初始缩放大小 //最大最小缩放根据初始缩放决定 override fun onGlobalLayout() { val drawable = drawable ?: return val scale: Float val viewWidth = width val viewHeight = height val overViewSize: Int = Math.min(viewWidth, viewHeight) - overViewSpace * 2 val drawableWidth = drawable.intrinsicWidth val drawableHeight = drawable.intrinsicHeight //build overview path  overViewPath.addRect( 0f, 0f, viewWidth.toFloat(), viewHeight.toFloat(), Path.Direction.CCW ) val circlePath = Path() val radius = overViewSize / 2.toFloat() if (viewShape == ViewShape.CIRCLE) { circlePath.addCircle( viewWidth / 2.toFloat(), viewHeight / 2.toFloat(), radius, Path.Direction.CCW ) } else { circlePath.addRect( viewWidth / 2f - radius, viewHeight / 2f - radius, viewWidth / 2f + radius, viewHeight / 2f + radius, Path.Direction.CCW ) } overViewPath.op(circlePath, Path.Op.XOR) overView.set( viewWidth / 2f - radius, viewHeight / 2f - radius, viewWidth / 2f + radius, viewHeight / 2f + radius ) overViewOffset.set(overView) overViewOffset.inset(-imageSpace.toFloat(), -imageSpace.toFloat()) //calculate the scale  scale = (overViewSize + imageSpace * 2) * 1f / Math.min( drawableWidth, drawableHeight ) initScale = scale minScale = initScale maxScale = minScale * max //calculate the delta move to center  val dx = viewWidth / 2 - drawableWidth / 2 val dy = viewHeight / 2 - drawableHeight / 2 mMatrix.postTranslate(dx.toFloat(), dy.toFloat()) mMatrix.postScale(initScale, initScale, viewWidth / 2.toFloat(), viewHeight / 2.toFloat()) imageMatrix = mMatrix //初始测量一次就够了  viewTreeObserver.removeOnGlobalLayoutListener(this) }   onDraw\n1 2 3 4 5 6 7 8 9 10 11 12  override fun onDraw(canvas: Canvas?) { super.onDraw(canvas) //画蒙层  canvas!!.drawPath(overViewPath, paint) //画stroke  if (viewStrokeWidth \u0026gt; 0) { canvas.drawCircle( overView.centerX(), overView.centerY() , (overView.width() + viewStrokeWidth) / 2, paintS ) } }   缩放处理逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  override fun onScale(detector: ScaleGestureDetector?): Boolean { val currScale = getCurrentScale() var scaleFactor = detector!!.scaleFactor //主要是判断不能小于最小缩放值，不能大于最大缩放值  scaleFactor = if (scaleFactor \u0026lt; 1 \u0026amp;\u0026amp; currScale \u0026gt; minScale) { Math.max(scaleFactor, minScale / currScale) } else if (scaleFactor \u0026gt; 1 \u0026amp;\u0026amp; currScale \u0026lt; maxScale) { Math.min(scaleFactor, maxScale / currScale) } else { 1f } if (scaleFactor != 1f) { scale(scaleFactor, scaleFactor, detector.focusX, detector.focusY) } return true }   裁剪图片,这里可以替换其他方式，提高效率,这里使用中够用，暂时这样处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  fun crop(file: File, outputX: Int, outputY: Int): Boolean { val bitmap = cropImage(outputX, outputY) ?: return false try { if (!file.exists()) { if (!file.parentFile.mkdirs() || !file.createNewFile()) { return false } } val fos = FileOutputStream(file) //java 中可以直接bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos)  //kotlin中报错，必须work线程中处理  val thread = Thread(Runnable { bitmap.compress(Bitmap.CompressFormat.PNG, 100, fos) }) thread.join() fos.flush() fos.close() bitmap.recycle() return true } catch (e: Exception) { e.printStackTrace() } return false } fun cropImage(outputX: Int, outputY: Int): Bitmap? { val drawable = (drawable ?: return null) as? BitmapDrawable ?: return null val scale = getCurrentScale() val mRectF = getMatrixRectF() val w: Float = overView.width() / scale val h: Float = overView.height() / scale val left: Float = (overView.left - mRectF.left) / scale val top: Float = (overView.top - mRectF.top) / scale val srcBmp = drawable.bitmap val cropBmp = Bitmap.createBitmap( srcBmp, left.toInt(), top.toInt(), w.toInt(), h.toInt() ) val bmp = Bitmap.createScaledBitmap(cropBmp, outputX, outputY, false) cropBmp.recycle() return bmp }   最开始写这个控件的时候是java，写文章的时候重写改成kotlin，继承OnScaleGestureListener ,onScaleEnd这里原不需要逻辑，结果kotlin自动生成TODO(\u0026quot;not implemented\u0026quot;) ，这个标志必须删除，不然缩放的时候会崩溃。。。\noverride fun onScaleEnd(detector: ScaleGestureDetector?) {\nTODO(\u0026ldquo;not implemented\u0026rdquo;) //To change body of created functions use File | Settings | File Templates.\n}\n 源码\n "
},
{
	"uri": "https://dshcao.github.io/zh/series/android/",
	"title": "android",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/renderscript%E4%BD%BF%E7%94%A8/",
	"title": "Android RenderScript使用",
	"tags": ["android"],
	"categories": [],
	"series": ["renderscript"],
	"description": "Android RenderScript详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-transition/",
	"title": "Android-Transition",
	"tags": ["android", "animation"],
	"categories": [],
	"series": ["android"],
	"description": "android Transition详解.",
	"content": "Transition Android中Transition是两个场景(Scene)之间的一个过渡转场动画效果。\nTransition有两个构造函数\n1 2 3 4 5 6  //代码创建 public Transition() {} //从res/transition资源文件加载创建 public Transition(Context context, AttributeSet attrs) { ... }   如：\n1 2 3 4 5 6 7 8  \u0026lt;transitionSet xmlns:android=\u0026#34;http://schemas.android.com/apk/res/android\u0026#34;\u0026gt; \u0026lt;changeBounds/\u0026gt; \u0026lt;fade android:fadingMode=\u0026#34;fade_in\u0026#34; android:duration=\u0026#34;200\u0026#34;\u0026gt; \u0026lt;targets\u0026gt; \u0026lt;target android:targetId=\u0026#34;@id/transition_title\u0026#34; /\u0026gt; \u0026lt;/targets\u0026gt; \u0026lt;/fade\u0026gt; \u0026lt;/transitionSet\u0026gt;   TransitionManager.changeScene/TransitionManager.beginDelayedTransition-\u0026gt;\nsceneChangeRunTransition\nsceneChangeRunTransition中为sceneRoot设置监听器监听onPreDraw，在onPreDraw调用transition.playTransition-\u0026gt;runAnimators\nPathMotion 1 2 3 4 5  public abstract class PathMotion { public PathMotion() {} public PathMotion(Context context, AttributeSet attrs) {} public abstract Path getPath(float startX, float startY, float endX, float endY); }   Scene和TransitionInflater/TransitionManager Scene 场景，即UI状态\nTransitionInflater 初始化Scene或TransitionManager\nTransitionManager 控制Scene使用某个Transition动画效果转换\n new Scene() Scene.getSceneForLayout scene.enter() scene.exit() TransitionInflater.from(context).inflateTransition() TransitionInflater.from(context).inflateTransitionManager() TransitionManager.go() 默认transition效果是AutoTransition，也可以指定其他Transition实现 transitionManager.transitionTo()  Transition 的实现  TransitionSet 多个transition(TransitionSet也是transition)的集合，TransitionSet是集合子transition的parent，通过ORDERING_TOGETHER和ORDERING_SEQUENTIAL两种play方式实现复杂的转场效果。TransitionSet对子transitions管理  AutoTransition 继承自TransitionSet并使用初始化的指定效果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public class AutoTransition extends TransitionSet { public AutoTransition() { init(); } public AutoTransition(Context context, AttributeSet attrs) { super(context, attrs); init(); } private void init() { setOrdering(ORDERING_SEQUENTIAL); addTransition(new Fade(Fade.OUT)). addTransition(new ChangeBounds()). addTransition(new Fade(Fade.IN)); } }      ChangeBounds Scene改变前后布局边界转场动画 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * Setting this flag tells ChangeBounds to track the before/after parent * of every view using this transition. The flag is not enabled by * default because it requires the parent instances to be the same * in the two scenes or else all parents must use ids to allow * the transition to determine which parents are the same. * * @param reparent true if the transition should track the parent * container of target views and animate parent changes. * @deprecated Use {@link android.transition.ChangeTransform} to handle * transitions between different parents. */ @Deprecated public void setReparent(boolean reparent) { mReparent = reparent; }    ChangeTransform Scene改变前后视图缩放和旋转动画 ChangeClipBounds Scene改变前后视图clipBounds边界转场动画 ChangeImageTransform Scene改变前后imageView matrix变换动画 ChangeScroll Scene改变前后view x/y上滚动变换动画 Visibility Scene改变前后view visibility变换动画  Slide Scene改变前后根据视图可见性，操作视图translationX/translationY将视图从场景某个边缘移入或移出 Explode Scene改变前后根据视图可见性，操作视图translationX/translationY将视图从场景边缘移入或移出,其中移入动画源码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public Animator onAppear(ViewGroup sceneRoot, View view, TransitionValues startValues, TransitionValues endValues) { if (endValues == null) { return null; } Rect bounds = (Rect) endValues.values.get(PROPNAME_SCREEN_BOUNDS); float endX = view.getTranslationX(); float endY = view.getTranslationY(); calculateOut(sceneRoot, bounds, mTempLoc); float startX = endX + mTempLoc[0]; float startY = endY + mTempLoc[1]; return TranslationAnimationCreator.createAnimation(view, endValues, bounds.left, bounds.top, startX, startY, endX, endY, sDecelerate, this); }    Fade Scene改变前后视图transitionAlpha变换动画 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private Animator createAnimation(final View view, float startAlpha, final float endAlpha) { if (startAlpha == endAlpha) { return null; } view.setTransitionAlpha(startAlpha); final ObjectAnimator anim = ObjectAnimator.ofFloat(view, \u0026#34;transitionAlpha\u0026#34;, endAlpha); if (DBG) { Log.d(LOG_TAG, \u0026#34;Created animator \u0026#34; + anim); } final FadeAnimatorListener listener = new FadeAnimatorListener(view); anim.addListener(listener); addListener(new TransitionListenerAdapter() { @Override public void onTransitionEnd(Transition transition) { view.setTransitionAlpha(1); transition.removeListener(this); } }); return anim; }       自定义Transition 过渡动画Transition需要捕获两个Sence之间的差异并使用属性动画实现过渡。属性动画是更改指定时间段内的起始值和结束值之间的视图属性，因此Transition框架需要同时具有属性的起始值和结束值才能构建动画，可参考官方文档创建自定义过渡动画\n 捕获初始值 override fun captureStartValues(transitionValues: TransitionValues)  Transition有两个抽象方法，一个空方法需要实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  class CustomTransition : Transition() { // package_name:transition_name:property_name  private val PROPNAME_BACKGROUND = \u0026#34;com.example.android.customtransition:CustomTransition:background\u0026#34; override fun captureStartValues(transitionValues: TransitionValues) { captureValues(transitionValues) } override fun captureEndValues(transitionValues: TransitionValues) { captureValues(transitionValues) } private fun captureValues(transitionValues: TransitionValues) { transitionValues.values[PROPNAME_BACKGROUND] = view.background } override fun createAnimator( sceneRoot: ViewGroup, startValues: TransitionValues?, endValues: TransitionValues? ): Animator? { return super.createAnimator(sceneRoot, startValues, endValues) } ... }   ActivityOptions \u0026amp; Activity的过渡动画 Activity的过渡动画是建立在Transition的基础上的。进入动画/退出动画/共享元素动画都是一个transition。Activity的过渡动画主要包含：\n 进入动画/退出动画 必须是继承Visibility的Transition，Android中的实现有Slide Explode Fade 共享元素动画 activity视图中的过渡元素，Android中的实现有ChangeBounds ChangeClipBounds ChangeTransform ChangeImageTransform ChangeScroll等 API分析    window.enterTransition A-\u0026gt;B B中View的动画\n  window.exitTransition A-\u0026gt;B A中View的动画\n  window.returnTransition A-\u0026gt;B 再从B退到A，B中View的动画\n  window.reenterTransition A-\u0026gt;B 再从B退到A，A中View的动画\n  window.sharedElementEnterTransition 针对共享元素的，时机同window.enterTransition\n  window.sharedElementExitTransition 针对共享元素的，时机同window.exitTransition\n  window.sharedElementReturnTransition 针对共享元素的，时机同window.returnTransition\n  window.sharedElementReenterTransition 针对共享元素的，时机同window.reenterTransition\n  ActivityOptions.makeSceneTransitionAnimation() 设置共享元素，此处传递的A中的view和transitionName会与B中有相同transitionName的View做动画，即以A中的某个transitionName的view状态作为初始Sence，以B中该transitionName的view状态作为最终Sence做动画\n  activity.postponeEnterTransition() 延迟EnterTransition，使用场景：图片选择activity进入图片查看activity,图片查看activity的共享元素ImageView需要下载大图资源，显示大图前无法确定ImageView大小，此时可以用postponeEnterTransition()延迟动画，下载完成后调用startPostponedEnterTransition()开启动画。但这也会造成一个问题：如果下载时间较长，下载完成前EnterTransition动画会卡住一段时间，可以使用占位图片等方式配合解决\n  activity.supportPostponedEnterTransition() 支持库版本，会判定版本号是否执行activity.postponeEnterTransition()\n  activity.startPostponedEnterTransition() 配合activity.postponeEnterTransition()使用，开启EnterTransition\n  activity.supportStartPostponedEnterTransition() 支持库版本，会判定版本号是否执行activity.supportStartPostponedEnterTransition()\n  activity.finishAfterTransition()\n  window.transitionManager/activity.contentTransitionManager\n  window.contentScene/activity.contentScene windown content的Sence，activity需要设置window.requestFeature(Window.FEATURE_CONTENT_TRANSITIONS)，否则window.contentScene为null\n  window.allowEnterTransitionOverlap true尽快执行过渡动画，false会等待A的exitTransition执行完执行完再执行B的enterTransition\n  window.allowReturnTransitionOverlap true尽快执行过渡动画，false会等待B的exitTransition执行完再执行A的reenterTransition\n  Activity方法onActivityReenter(resultCode: Int, data: Intent?)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * Called when an activity you launched with an activity transition exposes this * Activity through a returning activity transition, giving you the resultCode * and any additional data from it. This method will only be called if the activity * set a result code other than {@link #RESULT_CANCELED} and it supports activity * transitions with {@link Window#FEATURE_ACTIVITY_TRANSITIONS}. * * \u0026lt;p\u0026gt;The purpose of this function is to let the called Activity send a hint about * its state so that this underlying Activity can prepare to be exposed. A call to * this method does not guarantee that the called Activity has or will be exiting soon. * It only indicates that it will expose this Activity\u0026#39;s Window and it has * some data to pass to prepare it.\u0026lt;/p\u0026gt; * * @param resultCode The integer result code returned by the child activity * through its setResult(). * @param data An Intent, which can return result data to the caller * (various data can be attached to Intent \u0026#34;extras\u0026#34;). */ public void onActivityReenter(int resultCode, Intent data) { }     Window.FEATURE_CONTENT_TRANSITIONS\n1 2 3 4 5 6 7 8 9 10 11  /** * Flag for requesting that window content changes should be animated using a * TransitionManager. * * \u0026lt;p\u0026gt;The TransitionManager is set using * {@link #setTransitionManager(android.transition.TransitionManager)}. If none is set, * a default TransitionManager will be used.\u0026lt;/p\u0026gt; * * @see #setContentView */ public static final int FEATURE_CONTENT_TRANSITIONS = 12;     Window.FEATURE_ACTIVITY_TRANSITIONS\n1 2 3 4 5 6 7 8  /** * Enables Activities to run Activity Transitions either through sending or receiving * ActivityOptions bundle created with * {@link android.app.ActivityOptions#makeSceneTransitionAnimation(android.app.Activity, * android.util.Pair[])} or {@link android.app.ActivityOptions#makeSceneTransitionAnimation( * android.app.Activity, View, String)}. */ public static final int FEATURE_ACTIVITY_TRANSITIONS = 13;     Fragment的过渡动画 Fragment中有类似Activity的方法，区别是：\nvar transaction: FragmentTransaction = supportFragmentManager.beginTransaction()\ntransaction.addSharedElement()//添加共享元素\ntransaction在added, removed, attached, detached, shown,hidden等触发transition过渡动画\n 源码\n 参考：\n 创建自定义过渡动画 用开源项目ActivityOptionsICS让ActivityOptions的动画实现兼容  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-handler%E8%A7%A3%E6%9E%90/",
	"title": "Android源码解析-Handler",
	"tags": ["android", "handler"],
	"categories": [],
	"series": ["源码解析"],
	"description": "android Handler机制详解.",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/animation/",
	"title": "animation",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/animation/",
	"title": "animation",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/handler/",
	"title": "handler",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/http/",
	"title": "http",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/http/",
	"title": "http",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/httphttps/",
	"title": "Http/Https详解",
	"tags": ["http", "https"],
	"categories": [],
	"series": ["编程基础"],
	"description": "Http/Https详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/https/",
	"title": "https",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/jetpack/",
	"title": "jetpack",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/jetpack/",
	"title": "jetpack",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-jobservice/",
	"title": "Jetpack-JobService详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件JobService详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-lifecycles/",
	"title": "Jetpack-Lifecycles",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件Lifecycles详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-navigation/",
	"title": "Jetpack-Navigation详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件Navigation详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-workmanager/",
	"title": "Jetpack-WorkManager详解",
	"tags": ["android", "jetpack"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack组件WorkManager详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/kotlin/",
	"title": "kotlin",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/kotlin-%E8%AF%AD%E6%B3%95/",
	"title": "Kotlin语法",
	"tags": ["kotlin", "android"],
	"categories": [],
	"series": ["kotlin"],
	"description": "Kotlin语法",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/renderscript/",
	"title": "renderscript",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%86%99%E5%9C%A8%E5%BC%80%E5%A7%8B/",
	"title": "写在开始",
	"tags": ["生活"],
	"categories": [],
	"series": ["生活"],
	"description": "写在开始写博客的开始",
	"content": "工作已经很多年，但基本没写过博客。为什么？！！！当然是懒了！！！\n难道工作这么多年就没有想记录或者没有想写的内容吗？当然有！平时把记录的内容都放在了txt文件中。CSDN？当然早就注册了，但总觉得CSDN网站有些潦草。后来，至少是四年前在博客园申请过开博客，当时申请的理由大概是记录生活和学习内容，转载和保存别人的精品文章，结果，emmm\u0026hellip;很明显，被拒绝了，加上懒散，然后很久没有在写文章上花心思了。一晃不知道多久过去了，无意发现简书，支持当时很流行很火的markdown，自己也很想尝试，然后申请了一个账号，才发现写文章真的不是一件很轻松的事\u0026hellip;至少对于我这种先天性缺陷不会组织语言又追求完美的人。然而工作中又有很多东西需要记录，怎么办?于是我把简书当作了草稿箱，只有自己看的明白的杂乱排版，一篇一篇下来也不少了。\n最近准备找工作，写博客当然是加分项，加上自己这个年纪，很多小年轻在上学的时候就开始写了，当然有些唏嘘和忐忑！所以准备再次起航！\n为什么又搭建这个博客而不是继续简书，主要是我觉得简书软文和鸡汤太多，已不如当初，技术氛围已经快丧失完了。就像人：若只如初见！\n当然还有其他技术氛围不错的掘金等，但搭建自己的博客和网站一直是我想做的事，那就干脆就自己搭建一个吧。服务器我已经买，环境也已搭建好，想自己一个一个页面写出来，写了一部分页面，效果并不满意，觉得写页面这事对我还是有点吃力，况且域名还没有备案。于是选择了先在github搭建，比想象简单，两小时通关。\n选择hugo主要是因为是golang写的，虽然搭建又不用写golang ^_-。本人是golang爱好者，在我看来，golang最接近我对编程语言的幻想。\n开始就不会晚！好吧，我承认自己都感觉这话有点虚了，但开始总比没开始好。\n"
},
{
	"uri": "https://dshcao.github.io/zh/series/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%94%9F%E6%B4%BB/",
	"title": "生活",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-nestedscrolling%E8%A7%A3%E6%9E%90/",
	"title": "Android源码解析-NestedScrolling",
	"tags": ["android", "嵌套", "滑动"],
	"categories": [],
	"series": ["源码解析"],
	"description": "android 嵌套发动NestedScrollingXXX.",
	"content": "嵌套滑动实现原理及执行过程 嵌套滑动其实就是一套嵌套滑动回调。难的是嵌套滑动是如何回调的。理解嵌套滑动应该试着从嵌套滑动API的设计者思考。如果你明白了设计思路就可以很简单的在嵌套滑动回调做相应的处理。\n嵌套原理 我们知道触摸事件被父控件拦截后子控件无法收到后续的事件。同样的如果子控件决定了消费触摸事件父控件的onTouchEvent也无法继续收到后续的触摸事件。嵌套滑动如何实现的呢？答案是通过requestDisallowInterceptTouchEvent(true)请求父控件不要拦截触摸事件，触摸事件传递到子控件并在子控件onTouchEvent中调用startNestedScroll开启整个嵌套滚动。startNestedScroll会检测支持嵌套滚动的父控件并持有该父控件。然后通过嵌套滚动API的回调方法实现子控件和父控件的通信\n执行过程 NestedScrollingChild/NestedScrollingChild2/NestedScrollingChild3 NestedScrollingChild2继承自NestedScrollingChild并重载部分方法。为什么重载？增强实现。NestedScrollingChild3继承自NestedScrollingChild2并重载部分方法进一步增强实现。详情看下面源码解析注释。\n主要方法：\n  setNestedScrollingEnabled\n设置是否配合父控件嵌套滚动，前提是该控件实现相应的嵌套滚动功能。View默认实现和NestedScrollingChildHelper默认实现类似，只是NestedScrollingChildHelper做了兼容处理\n1 2 3 4 5 6 7 8  public void setNestedScrollingEnabled(boolean enabled) { if (enabled) { mPrivateFlags3 |= PFLAG3_NESTED_SCROLLING_ENABLED; } else { stopNestedScroll(); mPrivateFlags3 \u0026amp;= ~PFLAG3_NESTED_SCROLLING_ENABLED; } }   如果是在嵌套滚动中调用setNestedScrollingEnabled禁用了嵌套滚动会主动调用stopNestedScroll()\n  isNestedScrollingEnabled\n返回的是setNestedScrollingEnabled设置的结果\n  hasNestedScrollingParent\n子控件是否有支持嵌套滑动父控件，由于ViewGroup继承了ViewParent，而新的ViewParent支持了嵌套滑动API，实际上就是判断是否有父控件。嵌套滑动父控件的设置是在startNestedScroll执行的时候设置的\n  startNestedScroll\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public boolean startNestedScroll(int axes) { if (hasNestedScrollingParent()) { // Already in progress  return true; } if (isNestedScrollingEnabled()) { ViewParent p = getParent(); View child = this; while (p != null) { try { if (p.onStartNestedScroll(child, this, axes)) { //设置嵌套滑动父控件，mNestedScrollingParent是hasNestedScrollingParent判断的依据  mNestedScrollingParent = p; p.onNestedScrollAccepted(child, this, axes); return true; } } catch (AbstractMethodError e) { Log.e(VIEW_LOG_TAG, \u0026#34;ViewParent \u0026#34; + p + \u0026#34; does not implement interface \u0026#34; + \u0026#34;method onStartNestedScroll\u0026#34;, e); // Allow the search upward to continue  } if (p instanceof View) { child = (View) p; } p = p.getParent(); } } return false; }   子控件发起嵌套滚动动作，触摸模式嵌套滑动通常应该在ACTION_DOWN时调用该方法触发嵌套滚动。如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  @Override public boolean onTouchEvent(MotionEvent e) { switch (action) { case MotionEvent.ACTION_DOWN: int nestedScrollAxis = ViewCompat.SCROLL_AXIS_NONE; if (canScrollHorizontally) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_HORIZONTAL; } if (canScrollVertically) { nestedScrollAxis |= ViewCompat.SCROLL_AXIS_VERTICAL; } startNestedScroll(nestedScrollAxis, TYPE_TOUCH); break; ... } }   startNestedScroll源码可知返回true表示找到了支持嵌套滑动的父控件\n  dispatchNestedPreScroll\n分发嵌套滑动事件。在嵌套滑动子控件消费嵌套滑动前调用该方法。View默认实现源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  /** * 控件消费之前调用该方法 * * @param dx 水平方向滚动的像素 * @param dy 垂直方向滚动的像素 * @param consumed 输出参数. 如果不为null, consumed[0] 表示消费的 dx consumed[1] 表示消费的 dy.默认实现这里是被父控件消费 * @param offsetInWindow 可选项. 如果不是 null, 返回的是当前控件在该方法操作前后的视图坐标偏移。使用这个来调整预期的输入坐标跟踪 * @return true 表示父控件消费了部分或全部 */ public boolean dispatchNestedPreScroll(int dx, int dy, @Nullable @Size(2) int[] consumed, @Nullable @Size(2) int[] offsetInWindow) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { if (dx != 0 || dy != 0) { int startX = 0; int startY = 0; if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; } if (consumed == null) { if (mTempNestedScrollConsumed == null) { mTempNestedScrollConsumed = new int[2]; } consumed = mTempNestedScrollConsumed; } consumed[0] = 0; consumed[1] = 0; //调用嵌套父控件处理  mNestedScrollingParent.onNestedPreScroll(this, dx, dy, consumed); if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; } return consumed[0] != 0 || consumed[1] != 0; } else if (offsetInWindow != null) { offsetInWindow[0] = 0; offsetInWindow[1] = 0; } } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。综上即：在嵌套滑动子控件消费嵌套滑动前调用该方法让嵌套滑动父控件先处理。\n  dispatchNestedScroll\n分发嵌套滑动事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43  /** * 支持嵌套滑动的控件应该调用该方法报告父控件的滑动信息。 * * @param dxConsumed Horizontal distance in pixels consumed by this view during this scroll step * @param dyConsumed Vertical distance in pixels consumed by this view during this scroll step * @param dxUnconsumed Horizontal scroll distance in pixels not consumed by this view * @param dyUnconsumed Horizontal scroll distance in pixels not consumed by this view * @param offsetInWindow Optional. If not null, on return this will contain the offset * in local view coordinates of this view from before this operation * to after it completes. View implementations may use this to adjust * expected input coordinate tracking. * @return true if the event was dispatched, false if it could not be dispatched. * @see #dispatchNestedPreScroll(int, int, int[], int[]) */ public boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable @Size(2) int[] offsetInWindow) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { if (dxConsumed != 0 || dyConsumed != 0 || dxUnconsumed != 0 || dyUnconsumed != 0) { int startX = 0; int startY = 0; if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); startX = offsetInWindow[0]; startY = offsetInWindow[1]; } mNestedScrollingParent.onNestedScroll(this, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed); if (offsetInWindow != null) { getLocationInWindow(offsetInWindow); offsetInWindow[0] -= startX; offsetInWindow[1] -= startY; } return true; } else if (offsetInWindow != null) { // No motion, no dispatch. Keep offsetInWindow up to date.  offsetInWindow[0] = 0; offsetInWindow[1] = 0; } } return false; }     dispatchNestedPreFling\n分发fling事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  /** * 不同于scroll，如果父控件消费了fling，该控件不应再消费。即要么父控件要么该子控件消费fling。不应该两者都消费 * 为了获得更好的用户体验，嵌套滑动链中一次应该只有一个view消费fling事件。自定义视图实现应该以两种方式考虑这一点： * 1.如果自定义视图是分页的，并且需要固定到一个固定的页面点，请不要调用dispatchNestedPreFling；使用fling并固定到一个有效的位置 * 2.如果嵌套的父级确实消耗了fling，则该视图根本不应该滚动，甚至不应该回到有效的空闲位置 * * 视图也不应该向当前不支持滚动的轴上的嵌套父视图提供滚动速度 * * @param velocityX Horizontal fling velocity in pixels per second * @param velocityY Vertical fling velocity in pixels per second * @return true 嵌套滑动父控件消费了fling */ public boolean dispatchNestedPreFling(float velocityX, float velocityY) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { return mNestedScrollingParent.onNestedPreFling(this, velocityX, velocityY); } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。综上即：在嵌套滑动子控件消费嵌套fling前调用该方法让嵌套滑动父控件先处理。\n  dispatchNestedFling\n分发fling事件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * 该方法表示达到了fling条件。如：fling速度大于ViewConfiguration#getScaledMinimumFlingVelocity() * * 如果嵌套滑动子控件fling并达到了内容边缘可以使用此方法将fling委托给嵌套滑动父控件消费或观察 * * @param velocityX Horizontal fling velocity in pixels per second * @param velocityY Vertical fling velocity in pixels per second * @param consumed true if the child consumed the fling, false otherwise * @return true if the nested scrolling parent consumed or otherwise reacted to the fling */ public boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed) { if (isNestedScrollingEnabled() \u0026amp;\u0026amp; mNestedScrollingParent != null) { return mNestedScrollingParent.onNestedFling(this, velocityX, velocityY, consumed); } return false; }   从源码可以看出默认实现是让嵌套滑动父控件处理。\n  stopNestedScroll\n停止嵌套滚动\n1 2 3 4 5 6 7 8 9  /** * 嵌套滚动未开始时调用该方法是没有影响的 */ public void stopNestedScroll() { if (mNestedScrollingParent != null) { mNestedScrollingParent.onStopNestedScroll(this); mNestedScrollingParent = null; } }     NestedScrollingChild 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public interface NestedScrollingChild { void setNestedScrollingEnabled(boolean enabled); boolean isNestedScrollingEnabled(); boolean startNestedScroll(@ScrollAxis int axes); void stopNestedScroll(); boolean hasNestedScrollingParent(); boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow); boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow); boolean dispatchNestedFling(float velocityX, float velocityY, boolean consumed); boolean dispatchNestedPreFling(float velocityX, float velocityY); }   NestedScrollingChild2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  public interface NestedScrollingChild2 extends NestedScrollingChild { boolean startNestedScroll(@ScrollAxis int axes, @NestedScrollType int type); void stopNestedScroll(@NestedScrollType int type); boolean hasNestedScrollingParent(@NestedScrollType int type); boolean dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow, @NestedScrollType int type); boolean dispatchNestedPreScroll(int dx, int dy, @Nullable int[] consumed, @Nullable int[] offsetInWindow, @NestedScrollType int type); }   NestedScrollingChild3 1 2 3 4 5 6  public interface NestedScrollingChild3 extends NestedScrollingChild2 { void dispatchNestedScroll(int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @Nullable int[] offsetInWindow, @ViewCompat.NestedScrollType int type, @NonNull int[] consumed); }   NestedScrollingParent/NestedScrollingParent2/NestedScrollingParent3 NestedScrollingParent2继承自NestedScrollingParent并重载部分方法。为什么重载？增强实现。NestedScrollingParent3继承自NestedScrollingParent2并重载部分方法进一步增强实现。详情看下面源码解析注释。\n主要方法：\n  onStartNestedScroll\n该方法被子控件startNestedScroll(int)方法调用的。返回true表示该父控件将在嵌套滚动期间成为支持子控件嵌套滚动的父控件并接受嵌套滑动操作。当嵌套滚动结束后会收到onStopNestedScroll(View)的回调\n1 2 3 4  @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) { return false; }   由上面ViewGroup源码可知默认实现是不会成为嵌套滚动父控件，不接受子控件传递嵌套滑动操作的。一般如果需要支持作为嵌套滑动父控件需要重写此方法。\n1 2 3 4  @Override public boolean onStartNestedScroll(View child, View target, int nestedScrollAxes) { return (nestedScrollAxes \u0026amp; View.SCROLL_AXIS_VERTICAL) != 0; }     onNestedScrollAccepted\n此方法将在onStartNestedScroll返回true后调用。它为视图及其超类提供了执行嵌套滚动的初始配置的机会。此方法的实现应始终调用其超类的此方法的实现（如果存在的话）。\n1 2 3 4  @Override public void onNestedScrollAccepted(View child, View target, int axes) { mNestedScrollAxes = axes; }   ViewGroup的默认实现是记录嵌套滚动的方向。\n  getNestedScrollAxes\n1 2 3  public int getNestedScrollAxes() { return mNestedScrollAxes; }     onNestedPreScroll\n目标视图嵌套滚动前调用该方法。因为嵌套滑动父控件可能想在子控件滚动前有机会消费滚动。onNestedPreScroll是在嵌套滑动子控件调用dispatchNestedPreScroll是被调用的。该方法应该报告消费了多少像素。\n1 2 3 4 5 6 7 8 9 10 11  /** * @param target View that initiated the nested scroll * @param dx Horizontal scroll distance in pixels * @param dy Vertical scroll distance in pixels * @param consumed Output. The horizontal and vertical scroll distance consumed by this parent */ @Override public void onNestedPreScroll(View target, int dx, int dy, int[] consumed) { // Re-dispatch up the tree by default  dispatchNestedPreScroll(dx, dy, consumed, null); }     onNestedScroll\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * * 嵌套滑动子控件分发滑动事件时调用此方法。要想调用到该方法之前的onStartNestedScroll必须返回true * 滚动的消费部分和未消费部分都应该通过此方法报告给父控件。如果有未消耗的部分可以在此方法让父控件继续消费 * * @param target The descendent view controlling the nested scroll * @param dxConsumed Horizontal scroll distance in pixels already consumed by target * @param dyConsumed Vertical scroll distance in pixels already consumed by target * @param dxUnconsumed Horizontal scroll distance in pixels not consumed by target * @param dyUnconsumed Vertical scroll distance in pixels not consumed by target */ Override public void onNestedScroll(View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed) { // Re-dispatch up the tree by default  dispatchNestedScroll(dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed, null); }     onNestedPreFling\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /** * 目标视图消费fling之前父控件对嵌套滑动的相应 * 该方法被调用表示子控件发起了一个fling事件，通常是滑动速度大于ViewConfiguration#getScaledMinimumFlingVelocity() * * 如果父控件通过onNestedPreScroll消费了部分滑动，那么可能也需要通过onNestedPreFling完成通常的动作 * 返回true表示父控件消费了fling，此时子控件不应滚动内容 * * @param target View that initiated the nested scroll * @param velocityX Horizontal velocity in pixels per second * @param velocityY Vertical velocity in pixels per second * @return true if this parent consumed the fling ahead of the target view */ public boolean onNestedPreFling(View target, float velocityX, float velocityY) { // Re-dispatch up the tree by default  return dispatchNestedPreFling(velocityX, velocityY); }     onNestedFling\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  /** * 如果嵌套滑动子控件fling并达到了内容边缘可以使用此方法将fling委托给嵌套滑动父控件消费或观察 * * @param target View that initiated the nested scroll * @param velocityX Horizontal velocity in pixels per second * @param velocityY Vertical velocity in pixels per second * @param consumed true if the child consumed the fling, false otherwise * @return true if this parent consumed or otherwise reacted to the fling */ @Override public boolean onNestedFling(View target, float velocityX, float velocityY, boolean consumed) { // Re-dispatch up the tree by default  return dispatchNestedFling(velocityX, velocityY, consumed); }     onStopNestedScroll\n对嵌套滚动结束的响应\n1 2 3 4 5 6 7 8 9 10 11 12  /** * 当嵌套滚动停止时，将调用此方法，在嵌套滚动操作之后执行清理。默认实现调用stopNestedScroll()来停止正在进行的任何递归嵌套滚动 * 例如当嵌套触摸滚动以{@link MotionEvent{ACTION_UP}或{@link MotionEvent{ACTION_CANCEL}事件结束时。 * 此方法的实现应始终调用其超类的此方法的实现（如果存在）。 * */ @Override public void onStopNestedScroll(View child) { // Stop any recursive nested scrolling.  stopNestedScroll(); mNestedScrollAxes = 0; }     NestedScrollingParent\u0026amp;ViewParent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public interface NestedScrollingParent { boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes); void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes); void onStopNestedScroll(@NonNull View target); void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed); void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed); boolean onNestedFling(@NonNull View target, float velocityX, float velocityY, boolean consumed); boolean onNestedPreFling(@NonNull View target, float velocityX, float velocityY); @ScrollAxis int getNestedScrollAxes(); }   NestedScrollingParent2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public interface NestedScrollingParent2 extends NestedScrollingParent { boolean onStartNestedScroll(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); void onNestedScrollAccepted(@NonNull View child, @NonNull View target, @ScrollAxis int axes, @NestedScrollType int type); void onStopNestedScroll(@NonNull View target, @NestedScrollType int type); void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @NestedScrollType int type); void onNestedPreScroll(@NonNull View target, int dx, int dy, @NonNull int[] consumed, @NestedScrollType int type); }   NestedScrollingParent3 1 2 3 4 5  public interface NestedScrollingParent3 extends NestedScrollingParent2 { void onNestedScroll(@NonNull View target, int dxConsumed, int dyConsumed, int dxUnconsumed, int dyUnconsumed, @ViewCompat.NestedScrollType int type, @NonNull int[] consumed); }   NestedScrollingChildHelper\u0026amp;NestedScrollingParentHelper "
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%B5%8C%E5%A5%97/",
	"title": "嵌套",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%BB%91%E5%8A%A8/",
	"title": "滑动",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-scroller%E8%A7%A3%E6%9E%90/",
	"title": "Android Scroller解析及应用",
	"tags": ["android", "scroller", "源码解析", "滑动"],
	"categories": [],
	"series": ["源码解析"],
	"description": "Scroller 源码解析",
	"content": "OverScroller简介 OverScroller中两个重要属性：\n mMode有两个滚动模式：SCROLL_MODE FLING_MODE SplineOverScroller\nmState有三个滚动状态：SPLINE CUBIC BALLISTIC，查看源码可知： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  void fling(int start, int velocity, int min, int max, int over) { ... if (start \u0026gt; max || start \u0026lt; min) { startAfterEdge(start, min, max, velocity); return; } mState = SPLINE; ... } private void onEdgeReached() { ... mState = BALLISTIC; ... } private void startSpringback(int start, int end, int velocity) { ... mState = CUBIC; ... }     OverScroller API解析   overScroller.setFriction()\nfriction是fling或者scroll时的摩擦系数标量值\n  overScroller.startScroll()\n开始滚动指定的距离，需要调用invalidate()触发重绘\n  overScroller.computeScrollOffset()\n先判断滚动是否结束，结束返回false，否则返回true，并计算出下一次的新位置\n  overScroller.currVelocity\n当前速度\n  overScroller.fling()\n以初始速度velocity滚动，滚动的距离取决于初始速度velocity，当滚动到minX/maxX和minY/maxY范围内时若velocity不为0会根据当前velocity计算滚动的距离和时间，并确保在minX/maxX和minY/maxY范围内为前提再滚动一定距离，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  void fling(int start, int velocity, int min, int max, int over) { mOver = over; mFinished = false; mCurrVelocity = mVelocity = velocity; mDuration = mSplineDuration = 0; mStartTime = AnimationUtils.currentAnimationTimeMillis(); mCurrentPosition = mStart = start; if (start \u0026gt; max || start \u0026lt; min) { startAfterEdge(start, min, max, velocity); return; } mState = SPLINE; double totalDistance = 0.0; if (velocity != 0) { mDuration = mSplineDuration = getSplineFlingDuration(velocity); totalDistance = getSplineFlingDistance(velocity); } mSplineDistance = (int) (totalDistance * Math.signum(velocity)); mFinal = start + mSplineDistance; // Clamp to a valid final position  if (mFinal \u0026lt; min) { adjustDuration(mStart, mFinal, min); mFinal = min; } if (mFinal \u0026gt; max) { adjustDuration(mStart, mFinal, max); mFinal = max; } }     overScroller.abortAnimation()\n停止滚动动画直接将当前位置置为finalX/finalY\n  overScroller.forceFinished()\n停止滚动，停留在当前滚动位置，只是简单将滚动结束标志置为true\n  overScroller.isFinished\n是否结束\n  overScroller.isOverScrolled\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Returns whether the current Scroller is currently returning to a valid position. * Valid bounds were provided by the * {@link #fling(int, int, int, int, int, int, int, int, int, int)} method. * * One should check this value before calling * {@link #startScroll(int, int, int, int)} as the interpolation currently in progress * to restore a valid position will then be stopped. The caller has to take into account * the fact that the started scroll will start from an overscrolled position. * * @return true when the current position is overscrolled and in the process of * interpolating back to a valid value. */ public boolean isOverScrolled() { return ((!mScrollerX.mFinished \u0026amp;\u0026amp; mScrollerX.mState != SplineOverScroller.SPLINE) || (!mScrollerY.mFinished \u0026amp;\u0026amp; mScrollerY.mState != SplineOverScroller.SPLINE)); }     overScroller.notifyHorizontalEdgeReached()\n  overScroller.notifyVerticalEdgeReached()\n  overScroller.springBack() 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  public boolean springBack(int startX, int startY, int minX, int maxX, int minY, int maxY){ mMode = FLING_MODE; // Make sure both methods are called.  final boolean spingbackX = mScrollerX.springback(startX, minX, maxX); final boolean spingbackY = mScrollerY.springback(startY, minY, maxY); return spingbackX || spingbackY; } boolean springback(int start, int min, int max) { mFinished = true; ... if (start \u0026lt; min) { startSpringback(start, min, 0); } else if (start \u0026gt; max) { startSpringback(start, max, 0); } return !mFinished; } private void startSpringback(int start, int end, int velocity) { // mStartTime has been set  mFinished = false; }   可以看出，当(minX \u0026lt;= startX \u0026lt;= maxX) || (minY \u0026lt;= startY \u0026lt;= maxY)时返回false，否则返回true。当调用springBack(int startX, int startY, int minX, int maxX, int minY, int maxY)返回true时，调用invalidate()，然后在computeScroll()中调用OverScroller.computeScrollOffset()计算是否结束，而computeScrollOffset()会调用continueWhenFinished()，continueWhenFinished()再次调用startSpringback实现不断刷新\n  OverScroller 使用 通常自定义view中，在构造函数中初始化OverScroller，然后在onTouchEvent()的ACTION_UP中调用OverScroller的startScroll()或fling() 方法并调用invalidate()，然后在view的computeScroll()方法中调用OverScroller的computeScrollOffset()，若返回true，则做相应处理并再次调用invalidate()实现循环处理\nScroll 相关API View方法view.scrollBy()/view.scrollTo()/view.overScrollBy()  view.scrollBy()\n增量滚动，相对当前滚动位置再滚动x/y距离，最终调用scrollTo() 1 2 3  public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); }    view.scrollTo()\n滚动到指定的x/y位置 1 2 3 4 5 6 7 8 9 10 11 12 13  public void scrollTo(int x, int y) { if (mScrollX != x || mScrollY != y) { int oldX = mScrollX; int oldY = mScrollY; mScrollX = x; mScrollY = y; invalidateParentCaches(); onScrollChanged(mScrollX, mScrollY, oldX, oldY); if (!awakenScrollBars()) { postInvalidateOnAnimation(); } } }    view.overScrollBy()\n  computeVerticalScrollOffset/computeVerticalScrollRange/computeVerticalScrollExtent/canScrollVertically 一般来说:computeVerticalScrollRange()=computeVerticalScrollOffset()+computeVerticalScrollExtent()+未显示部分的高度。canScrollVertically利用该算式实现的API\n  computeVerticalScrollOffset\nview垂直方向已滚动的距离，源码：\n1 2 3  protected int computeVerticalScrollOffset() { return mScrollY; }     computeVerticalScrollExtent\n当前view垂直方向上滑块在整个滚动范围代表的长度，其实就是滚动控件显示出来的这部分内容的高度，一般来说整个滚动控件都会用来显示内容，，即默认实现是滚动控件的高度\n1 2 3  protected int computeVerticalScrollExtent() { return getHeight(); }     computeVerticalScrollRange\n垂直滚动条代表的整个滚动范围。如果是View一般代表的是整个内容的高度，非滚动控件则是控件本身的高度。在ViewGroup(如：NestedScrollView)中即其所有子控件的总高度。\nNestedScrollView的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public int computeVerticalScrollRange() { final int count = getChildCount(); final int parentSpace = getHeight() - getPaddingBottom() - getPaddingTop(); if (count == 0) { return parentSpace; } View child = getChildAt(0); NestedScrollView.LayoutParams lp = (LayoutParams) child.getLayoutParams(); int scrollRange = child.getBottom() + lp.bottomMargin; final int scrollY = getScrollY(); final int overscrollBottom = Math.max(0, scrollRange - parentSpace); //如果是overscroll算上overscroll的距离  if (scrollY \u0026lt; 0) { scrollRange -= scrollY; } else if (scrollY \u0026gt; overscrollBottom) { scrollRange += scrollY - overscrollBottom; } return scrollRange; }     canScrollVertically\n是否可以垂直某个方向上滚动，下面源码可以看出是利用上面三个API实现的\n1 2 3 4 5 6 7 8 9 10  public boolean canScrollVertically(int direction) { final int offset = computeVerticalScrollOffset(); final int range = computeVerticalScrollRange() - computeVerticalScrollExtent(); if (range == 0) return false; if (direction \u0026lt; 0) { return offset \u0026gt; 0; } else { return offset \u0026lt; range - 1; } }     VelocityTracker  VelocityTracker\n跟踪触摸事件的速度，实现fling和类似手势的助手类。通常的使用如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  @Override public boolean onTouchEvent(MotionEvent event) { int action = event.getActionMasked(); switch (action) { case MotionEvent.ACTION_DOWN: if (velocityTracker == null) { velocityTracker = VelocityTracker.obtain(); } else { velocityTracker.clear(); } break; case MotionEvent.ACTION_MOVE: velocityTracker.addMovement(event); break; case MotionEvent.ACTION_UP: case MotionEvent.ACTION_CANCEL: velocityTracker.computeCurrentVelocity(1000); float velocity = velocityTracker.getYVelocity(); //todo  if (velocityTracker != null) { velocityTracker.recycle(); velocityTracker = null; } break; } return super.onTouchEvent(event); }    computeCurrentVelocity\n基于addMovement收集的触摸点计算当前速度，调用getYVelocity/getYVelocity获取速度前必须先调用这个方法    view.offsetLeftAndRight()/view.offsetTopAndBottom() 自定义 参考：\n 使用Fling动画移动视图 以动画方式显示滚动手势  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/scroller/",
	"title": "scroller",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/dir/fourth/",
	"title": "Fourth",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My fourth presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/",
	"title": "展厅",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Presentation list with reveal.js",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/third/",
	"title": "Third",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My third presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/second/",
	"title": "Second",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My second presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/pt/first/",
	"title": "First",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "My first presentation",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/archive/",
	"title": "存档",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Archive Page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/adroid/",
	"title": "adroid",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/app%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/",
	"title": "Android-App启动流程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android-App启动流程",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-apt/",
	"title": "Android-APT",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android-APT详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-ffmpeg/",
	"title": "Android-FFmpeg",
	"tags": ["ffmpeg", "音视频", "android"],
	"categories": [],
	"series": [""],
	"description": "Android中FFmpeg的使用",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-flutter/",
	"title": "Android-Flutter",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android-Flutter使用",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-lottie/",
	"title": "Android-lottie",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android lottie动画",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-ndk/",
	"title": "Android-NDK",
	"tags": ["adroid", "ndk"],
	"categories": [],
	"series": ["ndk"],
	"description": "ndroid NDK",
	"content": "android内部是怎么实现发送延时消息\n怎么减小so包的体积\n怎么给一个应用加固\n怎么从trace.log中找到ANR的原因及出现的地方\n什么是NDK库?\n如何在jni中注册native函数，有几种注册方式?\nBinder怎么实现进程间通信的\n怎么检测内存泄漏的\n现在下载速度很慢,试从网络协议的角度分析原因并优化\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-vrar/",
	"title": "Android-VR&amp;AR",
	"tags": ["vr", "ar"],
	"categories": [],
	"series": [""],
	"description": "Android-VR&amp;AR",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/",
	"title": "Android-事件分发机制",
	"tags": ["android"],
	"categories": [],
	"series": ["android", "自定义view"],
	"description": "Android-事件分发机制详解",
	"content": "View mAttachInfo初始化 查看View源码可以知道mAttachInfo是在dispatchAttachedToWindow中赋值的\nView#dispatchAttachedToWindow\n1 2 3 4 5 6 7  @UnsupportedAppUsage(maxTargetSdk = Build.VERSION_CODES.P) void dispatchAttachedToWindow(AttachInfo info, int visibility) { mAttachInfo = info; ... onAttachedToWindow(); ... }   继续追踪可以知道View的dispatchAttachedToWindow是在ViewGroup的dispatchAttachedToWindow调用的。\nViewGroup#dispatchAttachedToWindow\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  @Override @UnsupportedAppUsage void dispatchAttachedToWindow(AttachInfo info, int visibility) { mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; super.dispatchAttachedToWindow(info, visibility); mGroupFlags \u0026amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW; final int count = mChildrenCount; final View[] children = mChildren; for (int i = 0; i \u0026lt; count; i++) { final View child = children[i]; child.dispatchAttachedToWindow(info, combineVisibility(visibility, child.getVisibility())); } final int transientCount = mTransientIndices == null ? 0 : mTransientIndices.size(); for (int i = 0; i \u0026lt; transientCount; ++i) { View view = mTransientViews.get(i); view.dispatchAttachedToWindow(info, combineVisibility(visibility, view.getVisibility())); } }   那么ViewGroup#dispatchAttachedToWindow最初是在哪调用的呢？答案是：Activity启动是执行ActivityThread.handleResumeActivity最终会调用到ViewRootImpl中，mAttachInfo即是在ViewRootImpl的构造方法中创建，并在ViewRootImpl#performTraversals中由DecorView调用dispatchAttachedToWindow实现mAttachInfo依次向下传递。\nViewRootImpl#performTraversals\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  public ViewRootImpl(Context context, Display display) { ... mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this, context); ... } private void performTraversals() { ... mAttachInfo.mUse32BitDrawingCache = true; mAttachInfo.mWindowVisibility = viewVisibility; mAttachInfo.mRecomputeGlobalAttributes = false; ... //这里的host即是DecorView host.dispatchAttachedToWindow(mAttachInfo, 0); mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(true); dispatchApplyInsets(host); ... }   上面是在Activiy生命周期中的调用，如果是动态添加的View其dispatchAttachedToWindow是怎么调用的呢？顺着ViewGroup#addView方法可以看到最终会在addViewInner中调用。\n1 2 3 4 5  private void addViewInner(View child, int index, LayoutParams params,boolean preventRequestLayout) { ... child.dispatchAttachedToWindow(mAttachInfo, (mViewFlags\u0026amp;VISIBILITY_MASK)); ... }   isInTouchMode/isFocusableInTouchMode()/setFocusableInTouchMode(boolean) 是否是触摸模式。因为android不仅支持屏幕触摸操作还支持键盘等设备操作。当使用键盘操作时需要对当前操作的UI元素高亮(聚焦)让用户知道当前操作的是哪个UI元素。触摸操作时不需要一直高亮某个UI元素，用户操作的是哪个UI元素就去触摸哪个元素。触摸模式下只需要在按下时高亮(聚焦)即可，此时的高亮(聚焦)是由设置的pressed状态决定的。为了区别两种模式就有了touchmode，isInTouchMode即是当前是否是触摸模式。\nView#isInTouchMode\n1 2 3 4 5 6 7  public boolean isInTouchMode() { if (mAttachInfo != null) { return mAttachInfo.mInTouchMode; } else { return ViewRootImpl.isInTouchMode(); } }   上面说过触摸模式下不需要高亮(聚焦)，但某些特殊控件如：EditText需要在触摸模式下也能获取焦点。iisFocusableInTouchMode()/setFocusableInTouchMode(boolean)判断/设置View在触摸模式下是否可以获取焦点\nonFilterTouchEventForSecurity 过滤TouchEvent应对安全策略。可以在这里过滤TouchEvent，false则丢弃TouchEvent，true则不过滤继续分发这个TouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  /** * Filter the touch event to apply security policies. * * @param event The motion event to be filtered. * @return True if the event should be dispatched, false if the event should be dropped. * * @see #getFilterTouchesWhenObscured */ public boolean onFilterTouchEventForSecurity(MotionEvent event) { //noinspection RedundantIfStatement  if ((mViewFlags \u0026amp; FILTER_TOUCHES_WHEN_OBSCURED) != 0 \u0026amp;\u0026amp; (event.getFlags() \u0026amp; MotionEvent.FLAG_WINDOW_IS_OBSCURED) != 0) { // Window is obscured, drop this touch.  return false; } return true; }   什么是FILTER_TOUCHES_WHEN_OBSCURED和MotionEvent.FLAG_WINDOW_IS_OBSCURED呢，看View源码的一段注释：\n1 2 3 4 5 6 7 8 9 10  * To enable touch filtering, call {@link #setFilterTouchesWhenObscured(boolean)} or set the * android:filterTouchesWhenObscured layout attribute to true. When enabled, the framework * will discard touches that are received whenever the view\u0026#39;s window is obscured by * another visible window. As a result, the view will not receive touches whenever a * toast, dialog or other window appears above the view\u0026#39;s window. * \u0026lt;/p\u0026gt;\u0026lt;p\u0026gt; * For more fine-grained control over security, consider overriding the * {@link #onFilterTouchEventForSecurity(MotionEvent)} method to implement your own * security policy. See also {@link MotionEvent#FLAG_WINDOW_IS_OBSCURED}. * \u0026lt;/p\u0026gt;   说的清楚FILTER_TOUCHES_WHEN_OBSCURED是setFilterTouchesWhenObscured(boolean)设置的表示可以过滤模糊不清楚的TouchEvent，MotionEvent#FLAG_WINDOW_IS_OBSCURED表示当前TouchEvent是模糊不清楚的。什么是模糊不清楚呢？当toast dialog等显示在这个view上时在这个view区域上的TouchEvent对这个view来说即是模糊不清楚的，这个TouchEvent会被添加MotionEvent#FLAG_WINDOW_IS_OBSCUREDflag，view默认会过滤这样的TouchEvent。\nrequestDisallowInterceptTouchEvent 当子控件不想父控件及其祖先控件拦截TouchEvent时可以调用此方法，该方法会逐级调用父控件requestDisallowInterceptTouchEvent通知父控件及其祖先控件不要拦截\nViewGroup#requestDisallowInterceptTouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * Called when a child does not want this parent and its ancestors to * intercept touch events with * {@link ViewGroup#onInterceptTouchEvent(MotionEvent)}. * * \u0026lt;p\u0026gt;This parent should pass this call onto its parents. This parent must obey * this request for the duration of the touch (that is, only clear the flag * after this parent has received an up or a cancel.\u0026lt;/p\u0026gt; * * @param disallowIntercept True if the child does not want the parent to * intercept touch events. */ @Override public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) { if (disallowIntercept == ((mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0)) { // We\u0026#39;re already in this state, assume our ancestors are too  return; } if (disallowIntercept) { mGroupFlags |= FLAG_DISALLOW_INTERCEPT; } else { mGroupFlags \u0026amp;= ~FLAG_DISALLOW_INTERCEPT; } // Pass it up to our parent  if (mParent != null) { mParent.requestDisallowInterceptTouchEvent(disallowIntercept); } }   dispatchTouchEvent Android触摸事件的生成、传递和分发见深入理解Android之Touch事件的分发。最终会传递到ViewRootImpl调用ViewRootImpl#processPointerEvent处理。ViewRootImpl#processPointerEvent中会调用DecorView#dispatchPointerEvent处理。DecorView#dispatchPointerEvent会调用父类View#dispatchPointerEvent，该方法中判断event.isTouchEvent()，若是TouchEvent，调用DecorView#dispatchTouchEvent。DecorView#dispatchTouchEvent最终会调用Window#Callback#dispatchTouchEvent或者ViewGroup#dispatchTouchEvent。\nDecorView#dispatchTouchEvent \nViewRootImpl#processPointerEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  private int processPointerEvent(QueuedInputEvent q) { final MotionEvent event = (MotionEvent)q.mEvent; mAttachInfo.mUnbufferedDispatchRequested = false; mAttachInfo.mHandlingPointerEvent = true; boolean handled = mView.dispatchPointerEvent(event); maybeUpdatePointerIcon(event); maybeUpdateTooltip(event); mAttachInfo.mHandlingPointerEvent = false; if (mAttachInfo.mUnbufferedDispatchRequested \u0026amp;\u0026amp; !mUnbufferedInputDispatch) { mUnbufferedInputDispatch = true; if (mConsumeBatchedInputScheduled) { scheduleConsumeBatchedInputImmediately(); } } return handled ? FINISH_HANDLED : FORWARD; }   View#dispatchPointerEvent\n1 2 3 4 5 6 7 8  @UnsupportedAppUsage public final boolean dispatchPointerEvent(MotionEvent event) { if (event.isTouchEvent()) { return dispatchTouchEvent(event); } else { return dispatchGenericMotionEvent(event); } }   DecorView#dispatchTouchEvent\n1 2 3 4 5 6 7 8 9 10  /** The feature ID of the panel, or -1 if this is the application\u0026#39;s DecorView */ private final int mFeatureId; @Override public boolean dispatchTouchEvent(MotionEvent ev) { final Window.Callback cb = mWindow.getCallback(); //如果当前window#Callback不为null，window也没有销毁，且window的panel是DecorView则调用window#Callback的dispatchTouchEvent，否则调用ViewGroup#dispatchTouchEvent  return cb != null \u0026amp;\u0026amp; !mWindow.isDestroyed() \u0026amp;\u0026amp; mFeatureId \u0026lt; 0 ? cb.dispatchTouchEvent(ev) : super.dispatchTouchEvent(ev); }   Activity#dispatchTouchEvent Activity是继承Window.Callback的，由上面DecorView#dispatchTouchEvent源码可只Activity中DecorView#dispatchTouchEvent会走Window.Callback#dispatchTouchEvent。即Activity#dispatchTouchEvent。\n从ViewRootImpl开始到Activity的调用链：ViewRootImpl#processPointerEvent -\u0026gt; DecorView#dispatchPointerEvent -\u0026gt; View#dispatchPointerEvent -\u0026gt; DecorView#dispatchTouchEvent -\u0026gt; Activity#dispatchTouchEvent\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  /** * Called to process touch screen events. You can override this to * intercept all touch screen events before they are dispatched to the * window. Be sure to call this implementation for touch screen events * that should be handled normally. * * @param ev The touch screen event. * * @return boolean Return true if this event was consumed. */ public boolean dispatchTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { // 回调表示当前activity进入和用户互动状态，与之对应的是onUserLeaveHint，该方法由performUserLeaving方法调用，而performUserLeaving是在ActivityThread#handlePauseActivity中满足userLeaving参数为true时调用。那么userLeaving什么情况下为true呢？大致是用户主动操作导致activity进入pause状态时。非用户主动操作如来电导致当前activity进入pasuse时userLeaving=false，performUserLeaving不会被调用。需要注意的是performUserLeaving不只调用onUserLeaveHint还会再次调用onUserInteraction。所以onUserInteraction可能会被调用两次。onUserInteraction回调旨在帮助activities智能地管理状态栏通知；特别是帮助activities确定取消通知的正确时间  onUserInteraction(); } //调用window的superDispatchTouchEvent分发事件。最终是PhoneWindow#superDispatchTouchEvent调用DecorView#superDispatchTouchEvent，再由DecorView#superDispatchTouchEvent调用DecorView#dispatchTouchEvent实现逐级下发询问子控件  if (getWindow().superDispatchTouchEvent(ev)) { return true; } //如果没有view消费TouchEvent，则调用activity的onTouchEvent处理  return onTouchEvent(ev); } public boolean onTouchEvent(MotionEvent event) { if (mWindow.shouldCloseOnTouch(this, event)) { finish(); return true; } return false; }   View#dispatchTouchEvent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49  public boolean dispatchTouchEvent(MotionEvent event) { ... boolean result = false; //开启本view检查器检查事件的连续性  if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(event, 0); } final int actionMasked = event.getActionMasked(); //如果是ACTION_DOWN事件，通知可能存在的上一次嵌套滚动停止  if (actionMasked == MotionEvent.ACTION_DOWN) { // Defensive cleanup for new gesture  stopNestedScroll(); } //如果事件没有被过滤丢弃  if (onFilterTouchEventForSecurity(event)) { //控件是enable状态且事件被scrollbar消费  if ((mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement  ListenerInfo li = mListenerInfo; if (li != null \u0026amp;\u0026amp; li.mOnTouchListener != null \u0026amp;\u0026amp; (mViewFlags \u0026amp; ENABLED_MASK) == ENABLED \u0026amp;\u0026amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } //如果事件没有被scrollbar/OnTouchListener消费询问控件本身是否消费  if (!result \u0026amp;\u0026amp; onTouchEvent(event)) { result = true; } } //通知事件连续性验证器事件未被本view消费，不再做事件连续性验证  if (!result \u0026amp;\u0026amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(event, 0); } // Clean up after nested scrolls if this is the end of a gesture;  // also cancel it if we tried an ACTION_DOWN but we didn\u0026#39;t want the rest  // of the gesture.  //如果事件结束或者当前view没有消费事件，通知嵌套滚动通知滚动  if (actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_CANCEL || (actionMasked == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; !result)) { stopNestedScroll(); } return result; }   ViewGroup#dispatchTouchEvent 分析源码前我们首先要了解一个变量：mFirstTouchTarget。它是一个链表的结构将TouchTargets链接起来。而这个mFirstTouchTarget就是链表的首个元素。其初始化是在ViewGroup#dispatchTouchEvent中调用的addTouchTarget中初始化的。addTouchTarget唯一被ViewGroup#dispatchTouchEvent调用。\ndispatchTouchEvent流程：\n如果是ACTION_DOWN事件，先清除之前可能因为app切换/ANR或者其他一些状态改变导致的未完成的事件序列，正常的时间序列应该是ACTION_DOWN-\u0026gt;ACTION_UP/ACTION_CANCEL。如果有未完成的事件序列则发送一个ACTION_CANCEL事件结束这个事件序列以便开始当前ACTION_DOWN事件触发的事件序列。清除动作包括清除相关flag，释放TouchTargets，将mFirstTouchTarget置为null\n1 2 3  // First touch target in the linked list of touch targets. @UnsupportedAppUsage private TouchTarget mFirstTouchTarget;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339  public boolean dispatchTouchEvent(MotionEvent ev) { //开启ViewGroup EventConsistency检查器检查事件的连续性  if (mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onTouchEvent(ev, 1); } ... boolean handled = false; //如果事件没有被过滤丢弃  if (onFilterTouchEventForSecurity(ev)) { final int action = ev.getAction(); final int actionMasked = action \u0026amp; MotionEvent.ACTION_MASK; // Handle an initial down.  if (actionMasked == MotionEvent.ACTION_DOWN) { // Throw away all previous state when starting a new touch gesture.  // The framework may have dropped the up or cancel event for the previous gesture  // due to an app switch, ANR, or some other state change.  //1.清除View(target.child)暂不接受TouchEvent的标志：PFLAG_CANCEL_NEXT_UP_EVENT以便接收新的事件序列  //2.如果mFirstTouchTarget不为null则会合成cancel event或者将ev暂时设置成ACTION_CANCEL传递给TouchTargets完成事件序列或者叫做清除上次的事件序列目的是以此次ACTION_DOWN event事件作为新的事件序列。  //3.mFirstTouchTarget重置为null  cancelAndClearTouchTargets(ev); //清除相关flag  resetTouchState(); } // Check for interception.  final boolean intercepted; if (actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null) { //检查子控件是否调用了requestDisallowInterceptTouchEvent通知父控件不要拦截  final boolean disallowIntercept = (mGroupFlags \u0026amp; FLAG_DISALLOW_INTERCEPT) != 0; if (!disallowIntercept) { intercepted = onInterceptTouchEvent(ev); //由于在上面的cancelAndClearTouchTargets-\u0026gt;dispatchTransformedTouchEvent方法中action有可能被临时设置为ACTION_CANCEL，在这里对其恢复  ev.setAction(action); // restore action in case it was changed  } else { intercepted = false; } } else { // There are no touch targets and this action is not an initial down  // so this view group continues to intercept touches.  intercepted = true; } // If intercepted, start normal event dispatch. Also if there is already  // a view that is handling the gesture, do normal event dispatch.  if (intercepted || mFirstTouchTarget != null) { ev.setTargetAccessibilityFocus(false); } // Check for cancelation.  final boolean canceled = resetCancelNextUpFlag(this) || actionMasked == MotionEvent.ACTION_CANCEL; // Update list of touch targets for pointer down, if needed.  final boolean split = (mGroupFlags \u0026amp; FLAG_SPLIT_MOTION_EVENTS) != 0; TouchTarget newTouchTarget = null; boolean alreadyDispatchedToNewTouchTarget = false; //既不是ACTION_CANCEL事件且当前ViewGroup又不拦截  if (!canceled \u0026amp;\u0026amp; !intercepted) { // If the event is targeting accessibility focus we give it to the  // view that has accessibility focus and if it does not handle it  // we clear the flag and dispatch the event to all children as usual.  // We are looking up the accessibility focused host to avoid keeping  // state since these events are very rare.  View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus() ? findChildWithAccessibilityFocus() : null; if (actionMasked == MotionEvent.ACTION_DOWN || (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN) || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { final int actionIndex = ev.getActionIndex(); // always 0 for down  final int idBitsToAssign = split ? 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex) : TouchTarget.ALL_POINTER_IDS; // Clean up earlier touch targets for this pointer id in case they  // have become out of sync.  //清除此pointer id的早期touch targets，以防它们不同步。比如之前这个pointers作用的是A view，先在的ACTION_DOWN事件序列即将作用在B view上，需要先清除，防止同时对A view/B view都有效果  removePointersFromTouchTargets(idBitsToAssign); final int childrenCount = mChildrenCount; if (newTouchTarget == null \u0026amp;\u0026amp; childrenCount != 0) { final float x = ev.getX(actionIndex); final float y = ev.getY(actionIndex); // Find a child that can receive the event.  // Scan children from front to back.  final ArrayList\u0026lt;View\u0026gt; preorderedList = buildTouchDispatchChildList(); final boolean customOrder = preorderedList == null \u0026amp;\u0026amp; isChildrenDrawingOrderEnabled(); final View[] children = mChildren; for (int i = childrenCount - 1; i \u0026gt;= 0; i--) { final int childIndex = getAndVerifyPreorderedIndex( childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView( preorderedList, children, childIndex); // If there is a view that has accessibility focus we want it  // to get the event first and if not handled we will perform a  // normal dispatch. We may do a double iteration but this is  // safer given the timeframe.  if (childWithAccessibilityFocus != null) { if (childWithAccessibilityFocus != child) { continue; } childWithAccessibilityFocus = null; i = childrenCount - 1; } //canReceivePointerEvents:child可见或者child执行动画中  //isTransformedTouchPointInView:触摸点在child范围内  if (!child.canReceivePointerEvents() || !isTransformedTouchPointInView(x, y, child, null)) { ev.setTargetAccessibilityFocus(false); continue; } newTouchTarget = getTouchTarget(child); if (newTouchTarget != null) { // Child is already receiving touch within its bounds.  // Give it the new pointer in addition to the ones it is handling.  newTouchTarget.pointerIdBits |= idBitsToAssign; break; } resetCancelNextUpFlag(child); //向child传递触摸事件，如果消费了事件执行下面内容  if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) { // Child wants to receive touch within its bounds.  mLastTouchDownTime = ev.getDownTime(); if (preorderedList != null) { // childIndex points into presorted list, find original index  for (int j = 0; j \u0026lt; childrenCount; j++) { if (children[childIndex] == mChildren[j]) { mLastTouchDownIndex = j; break; } } } else { mLastTouchDownIndex = childIndex; } mLastTouchDownX = ev.getX(); mLastTouchDownY = ev.getY(); newTouchTarget = addTouchTarget(child, idBitsToAssign); alreadyDispatchedToNewTouchTarget = true; break; } // The accessibility focus didn\u0026#39;t handle the event, so clear  // the flag and do a normal dispatch to all children.  ev.setTargetAccessibilityFocus(false); } if (preorderedList != null) preorderedList.clear(); } if (newTouchTarget == null \u0026amp;\u0026amp; mFirstTouchTarget != null) { // Did not find a child to receive the event.  // Assign the pointer to the least recently added target.  newTouchTarget = mFirstTouchTarget; while (newTouchTarget.next != null) { newTouchTarget = newTouchTarget.next; } newTouchTarget.pointerIdBits |= idBitsToAssign; } } } // Dispatch to touch targets.  if (mFirstTouchTarget == null) {//事件被自己拦截或没有view消费事件导致mFirstTouchTarget==null  // No touch targets so treat this as an ordinary view.  //handled:true 自己消费了事件  //handled:false 自己未消费事件  handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else {//有view消费事件  // Dispatch to touch targets, excluding the new touch target if we already  // dispatched to it. Cancel touch targets if necessary.  TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026amp;\u0026amp; target == newTouchTarget) { handled = true; } else { final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } } // Update list of touch targets for pointer up or cancel, if needed.  if (canceled || actionMasked == MotionEvent.ACTION_UP || actionMasked == MotionEvent.ACTION_HOVER_MOVE) { resetTouchState(); } else if (split \u0026amp;\u0026amp; actionMasked == MotionEvent.ACTION_POINTER_UP) { final int actionIndex = ev.getActionIndex(); final int idBitsToRemove = 1 \u0026lt;\u0026lt; ev.getPointerId(actionIndex); removePointersFromTouchTargets(idBitsToRemove); } } //通知事件连续性验证器事件未被本view消费，不再做事件连续性验证  if (!handled \u0026amp;\u0026amp; mInputEventConsistencyVerifier != null) { mInputEventConsistencyVerifier.onUnhandledEvent(ev, 1); } } /** * Cancels and clears all touch targets. */ private void cancelAndClearTouchTargets(MotionEvent event) { //如果已经有TouchTarget就构造一个取消触摸事件传递给TouchTarget用于完成整个事件序列  if (mFirstTouchTarget != null) { boolean syntheticEvent = false; if (event == null) { final long now = SystemClock.uptimeMillis(); event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0); event.setSource(InputDevice.SOURCE_TOUCHSCREEN); syntheticEvent = true; } for (TouchTarget target = mFirstTouchTarget; target != null; target = target.next) { //PFLAG_CANCEL_NEXT_UP_EVENT 意为自这次打上该标志起不再接受后面的TouchEvent事件  //清除TouchTarget中被打上暂不接受TouchEvent的标志：PFLAG_CANCEL_NEXT_UP_EVENT以便重新开始接受触摸事件序列。  resetCancelNextUpFlag(target.child); //分发取消TouchEvent完成整个事件序列  dispatchTransformedTouchEvent(event, true, target.child, target.pointerIdBits); } //循环释放TouchTargets对象，将mFirstTouchTarget重置为null  clearTouchTargets(); if (syntheticEvent) { event.recycle(); } } } /** * Transforms a motion event into the coordinate space of a particular child view, * filters out irrelevant pointer ids, and overrides its action if necessary. * If child is null, assumes the MotionEvent will be sent to this ViewGroup instead. */ //将MotionEvent转换为特定子视图的坐标空间，过滤掉不相关的指针ID，并根据需要覆盖其操作。如果child为空，则假定MotionEvent将被发送到此ViewGroup private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { final boolean handled; // Canceling motions is a special case. We don\u0026#39;t need to perform any transformations  // or filtering. The important part is the action, not the contents.  final int oldAction = event.getAction(); if (cancel || oldAction == MotionEvent.ACTION_CANCEL) { event.setAction(MotionEvent.ACTION_CANCEL); if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } event.setAction(oldAction); return handled; } // Calculate the number of pointers to deliver.  final int oldPointerIdBits = event.getPointerIdBits(); final int newPointerIdBits = oldPointerIdBits \u0026amp; desiredPointerIdBits; // If for some reason we ended up in an inconsistent state where it looks like we  // might produce a motion event with no pointers in it, then drop the event.  if (newPointerIdBits == 0) { return false; } // If the number of pointers is the same and we don\u0026#39;t need to perform any fancy  // irreversible transformations, then we can reuse the motion event for this  // dispatch as long as we are careful to revert any changes we make.  // Otherwise we need to make a copy.  final MotionEvent transformedEvent; //多点触控情况判断是否是同一个触控点或者手指  if (newPointerIdBits == oldPointerIdBits) { if (child == null || child.hasIdentityMatrix()) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; event.offsetLocation(offsetX, offsetY); //向child传递分发  handled = child.dispatchTouchEvent(event); event.offsetLocation(-offsetX, -offsetY); } return handled; } //如果child不为null且child经过缩放/平移/旋转变换则构建一个新的event供后面根据child的缩放做相应的transform处理  transformedEvent = MotionEvent.obtain(event); } else { transformedEvent = event.split(newPointerIdBits); } // Perform any necessary transformations and dispatch.  //当ACTION_DOWN事件被自己拦截时child==null  if (child == null) { //super.dispatchTouchEvent即是View#dispatchTouchEvent，逻辑最终是调用自己的onTouchEvent，即自己处理  handled = super.dispatchTouchEvent(transformedEvent); } else { final float offsetX = mScrollX - child.mLeft; final float offsetY = mScrollY - child.mTop; transformedEvent.offsetLocation(offsetX, offsetY); //如果child经过缩放/平移/旋转变换那么transformedEvent也做相应变化  if (! child.hasIdentityMatrix()) { //getInverseMatrix反变换操作  transformedEvent.transform(child.getInverseMatrix()); } //向下传递事件  handled = child.dispatchTouchEvent(transformedEvent); } // Done.  transformedEvent.recycle(); return handled; }   ViewGroup#onInterceptTouchEvent 一般自定义view都需要重写该方法\n1 2 3 4 5 6 7 8 9 10  public boolean onInterceptTouchEvent(MotionEvent ev) { //默认实现只拦截来自鼠标的作用在滚动滑块的ACTION_DOWN事件  if (ev.isFromSource(InputDevice.SOURCE_MOUSE) \u0026amp;\u0026amp; ev.getAction() == MotionEvent.ACTION_DOWN \u0026amp;\u0026amp; ev.isButtonPressed(MotionEvent.BUTTON_PRIMARY) \u0026amp;\u0026amp; isOnScrollbarThumb(ev.getX(), ev.getY())) { return true; } return false; }   View#onTouchEvent 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237  /** * Implement this method to handle touch screen motion events. * \u0026lt;p\u0026gt; * If this method is used to detect click actions, it is recommended that * the actions be performed by implementing and calling * {@link #performClick()}. This will ensure consistent system behavior, * including: * \u0026lt;ul\u0026gt; * \u0026lt;li\u0026gt;obeying click sound preferences * \u0026lt;li\u0026gt;dispatching OnClickListener calls * \u0026lt;li\u0026gt;handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when * accessibility features are enabled * \u0026lt;/ul\u0026gt; * * @param event The motion event. * @return True if the event was handled, false otherwise. */ public boolean onTouchEvent(MotionEvent event) { final float x = event.getX(); final float y = event.getY(); final int viewFlags = mViewFlags; final int action = event.getAction(); final boolean clickable = ((viewFlags \u0026amp; CLICKABLE) == CLICKABLE || (viewFlags \u0026amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE; //view DISABLED状态下如果是clickable则默认消费了事件但不做任何事情，如果是非clickable状态则返回false，不消费事件  if ((viewFlags \u0026amp; ENABLED_MASK) == DISABLED) { if (action == MotionEvent.ACTION_UP \u0026amp;\u0026amp; (mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; // A disabled view that is clickable still consumes the touch  // events, it just doesn\u0026#39;t respond to them.  return clickable; } //如果设置了TouchDelegate，则完全走TouchDelegate的处理逻辑  if (mTouchDelegate != null) { if (mTouchDelegate.onTouchEvent(event)) { return true; } } //clickable的view默认消费事件  if (clickable || (viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { switch (action) { case MotionEvent.ACTION_UP: mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; if ((viewFlags \u0026amp; TOOLTIP) == TOOLTIP) { handleTooltipUp(); } if (!clickable) { removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; break; } boolean prepressed = (mPrivateFlags \u0026amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don\u0026#39;t have it already and we should in  // touch mode.  boolean focusTaken = false; if (isFocusable() \u0026amp;\u0026amp; isFocusableInTouchMode() \u0026amp;\u0026amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually  // showed it as pressed. Make it show the pressed  // state now (before scheduling the click) to ensure  // the user sees it.  setPressed(true, x, y); } if (!mHasPerformedLongPress \u0026amp;\u0026amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check  removeLongPressCallback(); // Only perform take click actions if we were in the pressed state  if (!focusTaken) {//当前有焦点触发onclick事件  // Use a Runnable and post this rather than calling  // performClick directly. This lets other visual state  // of the view update before click actions start.  if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClickInternal(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now  mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; case MotionEvent.ACTION_DOWN: if (event.getSource() == InputDevice.SOURCE_TOUCHSCREEN) { mPrivateFlags3 |= PFLAG3_FINGER_DOWN; } mHasPerformedLongPress = false; if (!clickable) { checkForLongClick( ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); break; } if (performButtonActionOnTouchDown(event)) { break; } // Walk up the hierarchy to determine if we\u0026#39;re inside a scrolling container.  boolean isInScrollingContainer = isInScrollingContainer(); // For views inside a scrolling container, delay the pressed feedback for  // a short period in case this is a scroll.  if (isInScrollingContainer) { mPrivateFlags |= PFLAG_PREPRESSED; if (mPendingCheckForTap == null) { mPendingCheckForTap = new CheckForTap(); } mPendingCheckForTap.x = event.getX(); mPendingCheckForTap.y = event.getY(); postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout()); } else { // Not inside a scrolling container, so show the feedback right away  setPressed(true, x, y); checkForLongClick( ViewConfiguration.getLongPressTimeout(), x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); } break; case MotionEvent.ACTION_CANCEL: if (clickable) { setPressed(false); } removeTapCallback(); removeLongPressCallback(); mInContextButtonPress = false; mHasPerformedLongPress = false; mIgnoreNextUpEvent = false; mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; break; case MotionEvent.ACTION_MOVE: if (clickable) { drawableHotspotChanged(x, y); } final int motionClassification = event.getClassification(); final boolean ambiguousGesture = motionClassification == MotionEvent.CLASSIFICATION_AMBIGUOUS_GESTURE; int touchSlop = mTouchSlop; if (ambiguousGesture \u0026amp;\u0026amp; hasPendingLongPressCallback()) { final float ambiguousMultiplier = ViewConfiguration.getAmbiguousGestureMultiplier(); if (!pointInView(x, y, touchSlop)) { // The default action here is to cancel long press. But instead, we  // just extend the timeout here, in case the classification  // stays ambiguous.  removeLongPressCallback(); long delay = (long) (ViewConfiguration.getLongPressTimeout() * ambiguousMultiplier); // Subtract the time already spent  delay -= event.getEventTime() - event.getDownTime(); checkForLongClick( delay, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__LONG_PRESS); } touchSlop *= ambiguousMultiplier; } // Be lenient about moving outside of buttons  if (!pointInView(x, y, touchSlop)) { // Outside button  // Remove any future long press/tap checks  removeTapCallback(); removeLongPressCallback(); if ((mPrivateFlags \u0026amp; PFLAG_PRESSED) != 0) { setPressed(false); } mPrivateFlags3 \u0026amp;= ~PFLAG3_FINGER_DOWN; } final boolean deepPress = motionClassification == MotionEvent.CLASSIFICATION_DEEP_PRESS; if (deepPress \u0026amp;\u0026amp; hasPendingLongPressCallback()) { // process the long click action immediately  removeLongPressCallback(); checkForLongClick( 0 /* send immediately */, x, y, TOUCH_GESTURE_CLASSIFIED__CLASSIFICATION__DEEP_PRESS); } break; } return true; } return false; }   MotionEvent  key event 键盘、遥控器按键，鼠标点击会生成按键事件（key event） hover event 鼠标在屏幕上的停留、滑动会产生hover event scroll event 鼠标滚轮的滚动会生成scroll event touch event 对触屏设备，当用户用手指或触控笔在设备屏幕上操作时会产生触屏事件（touch event）\n其中MotionEvent是对hover event\u0026amp;scroll event\u0026amp;touch event的封装\nKeyEvent是对key event的封装  ACTION说明 event.getAction() action中0~7存储类别，8~15存储pointerIndex，这从getAction、getActionMasked和getActionIndex源码就可以看出来。pointerIndex和pointerId都是从0开始的整数。\n指针id(pointerId)和指针index(pointerIndex)\npointerId在整个手势操作过程中是不会变化的，可以根据pointerId跟踪某个pointer\npointerIndex在整个手势操作过程中会随着手指的增减变化\n ACTION_DOWN 多点触控第一个指针按下，如果当前触摸设备已经有存在pointer则 ACTION_UP 多点触控最后指针抬起，不一定是ACTION_DOWN对应的指针，可能是ACTION_POINTER_DOWN对应的指针 ACTION_MOVE 指针移动 ACTION_CANCEL 触摸取消，可以视为ACTION_UP事件，但不要做ACTION_UP的任何操作。ACTION_CANCEL发生的时机通常有几种：1.主动发送 2.重新开始一个事件序列时可能被程序触发 3.当接收到ACTION_DOWN事件的view被父控件拦截时会触发ACTION_CANCEL事件，具体实现在ViewGroup#dispatchTouchEvent源码中： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  // Dispatch to touch targets. if (mFirstTouchTarget == null) { // No touch targets so treat this as an ordinary view.  handled = dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS); } else { // Dispatch to touch targets, excluding the new touch target if we already  // dispatched to it. Cancel touch targets if necessary.  TouchTarget predecessor = null; TouchTarget target = mFirstTouchTarget; while (target != null) { final TouchTarget next = target.next; if (alreadyDispatchedToNewTouchTarget \u0026amp;\u0026amp; target == newTouchTarget) { handled = true; } else { //被拦截后cancelChild为true  final boolean cancelChild = resetCancelNextUpFlag(target.child) || intercepted; //dispatchTransformedTouchEvent会向子view分发ACTION_CANCEL事件  if (dispatchTransformedTouchEvent(ev, cancelChild, target.child, target.pointerIdBits)) { handled = true; } if (cancelChild) { if (predecessor == null) { mFirstTouchTarget = next; } else { predecessor.next = next; } target.recycle(); target = next; continue; } } predecessor = target; target = next; } }    ACTION_OUTSIDE 在UI元素之外发生的触摸事件 ACTION_POINTER_DOWN 多点触控使用，非第一个指针按下 ACTION_POINTER_UP 多点触控使用，非最后一个指针抬起  其余如：ACTION_SCROLL/ACTION_BUTTON_PRESS/ACTION_BUTTON_RELEASE/ACTION_HOVER_ENTER/ACTION_HOVER_MOVE/ACTION_HOVER_EXIT 非触摸事件action，这些事件传递到onGenericMotionEvent(MotionEvent)处理\nView如何实现longclick事件的  getDeviceId() 返回event来源设备的id，通常是触摸屏。可用于InputDevice.getDevice(deviceId)获取InputDevice后进一步获取相关信息 getActionIndex() 获取当前event的pointerIndex getPointerId(pointerIndex) 获取指定pointerIndex的pointerId findPointerIndex(pointerId) 获取指定pointerId的pointerIndex，其和getActionIndex()的返回值意义是一样的，区别在于一个是获得当前event的pointerIndex，一个是获取指定pointerId pointer的pointerIndex getHistorySize() 获取event的历史触控点数，仅适用于ACTION_MOVE getRawX(int pointerIndex) 返回未经过接受触摸事件窗口和视图调整的相对于屏幕的原始坐标 getX(pointerIndex) 获取指定pointerIndex pointer当前触控点的相对于接受触摸事件窗口和视图的x坐标 getHistoricalX(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点的x坐标，pos小于getHistorySize() getSize(pointerIndex) 获取指定pointerIndex pointer当前触控点与触摸设备的按压接触面积大小。范围是0~1，至于0~1代表具体像素范围和触摸设备有关 getHistoricalSize(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点与触摸设备的按压接触面积大小 getPressure(pointerIndex) 获取指定pointerIndex pointer当前触控点的压力值。通常压力值是0(毫无压力)~1(正常压力)，但根据具体的输入设备校准，压力也可能是大于1的值 getHistoricalPressure(pointerIndex, pos) 获取指定pointerIndex pointer第pos个历史触控点的压力值 getOrientation()/getHistoricalOrientation() (历史)触控点的方向，范围-PI/2~PI/2。可以将手指或触控笔与屏幕接触点的接触面积类似的看作一个椭圆。那么以长轴向上弧度为0，是垂直方向；长轴指向左边则是正值0~PI/2，长轴指向右边则是负值0~-PI/2。当然手指或触控笔与屏幕接触点的接触面积可能是一个正圆形。那么此时的方向是未知的 getTouchMajor()/getHistoricalTouchMajor() 将手指或触控笔与屏幕接触点的接触面积类似的看作一个椭圆。返回该椭圆长轴的长度 setEdgeFlags(flags)/getEdgeFlags() 触摸的是否是edge。getEdgeFlags仅在ACTION_DOWN事件中使用。 getFlags() 见：FLAG_WINDOW_IS_OBSCURED/FLAG_WINDOW_IS_PARTIALLY_OBSCURED  FLAG_WINDOW_IS_OBSCURED 表示接受触摸事件的窗口被其上另一个可见的窗口部分或全部遮挡。如果该触摸事位置是其上可见的窗口区域则返回true。安全敏感的应用程序可以检查此标志，以确定恶意应用程序可能为了误导用户或劫持操作而掩盖其部分内容的情况。 FLAG_WINDOW_IS_PARTIALLY_OBSCURED 类似FLAG_WINDOW_IS_OBSCURED，但触摸事位置不一定是在其上可见窗口的区域。   getXPrecision() 返回X坐标的精度。你可以用getX()乘以这个数字来找到X坐标的实际硬件值   setLocation(x, y)/offsetLocation(deltaX, deltaY) 设置/调整触摸事件的位置 transform(matrix) 使用矩阵转换event所有触控点  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public final int getAction() { return nativeGetAction(mNativePtr); } //取低八位ACTION类别信息 public final int getActionMasked() { //取低八位有效值，去除8~15位的pointerIndex信息  return nativeGetAction(mNativePtr) \u0026amp; ACTION_MASK; } //为ACTION_POINTER_DOWN/ACTION_POINTER_UP操作使用的，返回的是pointer index。当getPointerId(int)/getX(int)/getY(int)/getPressure(int)/getSize(int)时使用 public final int getActionIndex() { //取高8~16位有效值，然后右移8位  return (nativeGetAction(mNativePtr) \u0026amp; ACTION_POINTER_INDEX_MASK) \u0026gt;\u0026gt; ACTION_POINTER_INDEX_SHIFT; }   参考：\n 深入理解Android之Touch事件的分发 getEdgeFlags always returning 0? MotionEvent 详解  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/android%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6-activityfragment/",
	"title": "Android四大组件-Activity/Fragment",
	"tags": ["四大组件", "android"],
	"categories": [],
	"series": ["四大组件"],
	"description": "Android四大组件-Activity/Fragment使用",
	"content": "Activity、PhoneWindow、DecorView、ViewRootImpl、WindowManagerImpl、WindowManagerGlobal、ActivityThread和Surface\n  ActivityOptions.makeSceneTransitionAnimation()\n  ActivityOptions.makeCustomAnimation()\n  ActivityOptions.makeScaleUpAnimation()\n  ActivityOptions.makeTaskLaunchBehind()\n  ActivityOptions.makeThumbnailScaleUpAnimation()\n  ActivityOptions.makeBasic()\n  ActivityOptions.makeClipRevealAnimation()\n  activity.overridePendingTransition(0, 0)\n  参考：\nAndroid Render(一)Activity窗口构成和绘制解析\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB/",
	"title": "Android属性动画",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android属性动画",
	"content": "RecyclerView 不支持android:animateLayoutChanges=\u0026quot;true\u0026rdquo;\nCaused by: java.lang.IllegalArgumentException: Providing a LayoutTransition into RecyclerView is not supported. Please use setItemAnimator() instead for animating changes to the items in this RecyclerView\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/android%E7%94%BB%E4%B8%AD%E7%94%BB-pictureinpicture/",
	"title": "Android画中画-PictureInPicture",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android画中画-PictureInPicture详解",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%9B%B4%E6%92%AD-%E5%BD%95%E5%88%B6%E5%B1%8F%E5%B9%95/",
	"title": "Android直播-录制屏幕",
	"tags": ["android", "直播", "音视频"],
	"categories": [],
	"series": ["直播"],
	"description": "Syntax highlighting test",
	"content": "录屏的根本是怎么获取屏幕的显示数据\n屏幕录制的几种实现方式：  Linux+framebuffer+root权限 利用View.getDrawingCache() Android shell命令screencap/screenrecord+root权限 SurfaceFlinger+framebuffer VirtualDisplay+MediaProjection  一、Linux+framebuffer+root权限 Android 基于 Linux，所以可以通过读取 /dev/graphics/fb0 设备节点，即 framebuffer 中的帧数据来实现屏幕的录制。但是读取这个设备节点需要 root 权限\n二、View.getDrawingCache() 通过 View 的 cache 内容获取到 Bitmap 对象来达到录屏的效果。但是很多手机上面该方式会存在性能问题，另外该方式并不是一个真正意义上的录屏方式，另外部分 View 组件的内容并不能获取到，比如webview\n三、Android shell命令screencap/screenrecord+root权限 screencap/screenrecord 是 Android shell 的命令，需要root 权限\n creencap -p xxx.png/screenshot xxx.png adb shell screenrecord \u0026ndash;size 1280*720 \u0026ndash;bit-rate 6000000 \u0026ndash;time-limit 30 /sdcard/demo.mp4\n\u0026ndash;size 指定视频分辨率；\n\u0026ndash;bit-rate 指定视频比特率，默认为4M，该值越小，保存的视频文件越小；\n\u0026ndash;time-limit 指定录制时长，若设定大于180，命令不会被执行；  四、SurfaceFlinger + framebuffer 见参考 从surfaceflinger历史变更谈截屏\n五、VirtualDisplay + MediaProjection 在我的华为荣耀8 android8.0 手机上下载虎牙直播测试发现他们使用的是该方案\n代码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121  class ScreenCaptureActivity : AbsActivity() { lateinit var surface: Surface private lateinit var surfaceView: SurfaceView lateinit var projectionManager: MediaProjectionManager private var display: VirtualDisplay? = null private var projection: MediaProjection? = null // private var _resultCode: Int? = null  private var _resultData: Intent? = null private lateinit var capture: TextView companion object { const val REQUEST_PROJECTION = 2 const val STATE_RESULT_CODE = \u0026#34;result_code\u0026#34; const val STATE_RESULT_DATA = \u0026#34;result_data\u0026#34; } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_screen_capture) // _resultCode = savedInstanceState?.getInt(STATE_RESULT_CODE)  _resultData = savedInstanceState?.getParcelable(STATE_RESULT_DATA) surfaceView = findViewById(R.id.surface) surface = surfaceView.holder.surface projectionManager = getSystemService(Context.MEDIA_PROJECTION_SERVICE) as MediaProjectionManager capture = findViewById(R.id.capture) capture.setOnClickListener { if (display == null) { startCapture() capture.text = \u0026#34;停止\u0026#34; } else { stopCapture() capture.text = \u0026#34;开始\u0026#34; } } } override fun onSaveInstanceState(outState: Bundle) { super.onSaveInstanceState(outState) // if (_resultCode != null) { // outState.putInt(STATE_RESULT_CODE, _resultCode!!) // }  if (_resultData != null) { outState.putParcelable(STATE_RESULT_DATA, _resultData) } } override fun onPause() { super.onPause() stopCapture() } override fun onDestroy() { super.onDestroy() projection?.stop() projection = null } private fun startCapture() { if (/*_resultCode == null \u0026amp;\u0026amp;*/ _resultData == null) { startActivityForResult( projectionManager.createScreenCaptureIntent(), REQUEST_PROJECTION ) } else { setup() } } private fun stopCapture() { display?.release() display = null } private fun setup() { if (projection == null) { projection = projectionManager.getMediaProjection( /*_resultCode!!*/Activity.RESULT_OK, _resultData!! ) } if (projection != null) { display = projection!!.createVirtualDisplay( \u0026#34;ScreenCapture\u0026#34;, surfaceView.width, surfaceView.height, Getter.metrics().densityDpi, DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, surface, null, null ) } } override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { REQUEST_PROJECTION -\u0026gt; { if (resultCode != Activity.RESULT_OK) { Toast.makeText(this, \u0026#34;User denied screen sharing permission\u0026#34;, Toast.LENGTH_LONG) .show() return } // _resultCode = resultCode  _resultData = data setup() } } } }   单纯在当前activity或app中实现录屏使用场景有限，实际使用中需要配合Service实现app退到后台继续录屏\n参考：\n 手机游戏直播中的录屏怎么实现 从surfaceflinger历史变更谈截屏  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%9B%B4%E6%92%AD-%E9%87%87%E5%BD%95%E6%91%84%E5%83%8F%E5%A4%B4/",
	"title": "Android直播-采录摄像头",
	"tags": ["android", "直播", "音视频"],
	"categories": [],
	"series": ["直播"],
	"description": "Syntax highlighting test",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E7%BB%84%E4%BB%B6%E5%8C%96/",
	"title": "Android组件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Android组件化",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/anr/",
	"title": "anr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/anr%E5%88%86%E6%9E%90/",
	"title": "ANR分析",
	"tags": ["anr"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ar/",
	"title": "ar",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/camera/",
	"title": "camera",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ffmpeg/",
	"title": "ffmpeg",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/git/",
	"title": "git",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/git-%E8%AF%A6%E8%A7%A3/",
	"title": "git 详解",
	"tags": ["git"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/java/",
	"title": "java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/jetpack-camerax/",
	"title": "Jetpack-CameraX",
	"tags": ["android", "jetpack", "camera", "media"],
	"categories": [],
	"series": ["jetpack"],
	"description": "Jetpack-CameraX",
	"content": "一、camera2 CameraX是Jetpack对camera2功能的封装，并可向后兼容至 Android 5.0（API 级别 21）\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/jvmdalvikart/",
	"title": "JVM/Dalvik/ART",
	"tags": ["android", "java"],
	"categories": [],
	"series": ["编程基础"],
	"description": "SJVM/Dalvik/ART理解",
	"content": "前置知识 Android中每个应用都对应一个单独的虚拟机，独立运行\nJIT\u0026amp;AOT  JIT，Just-in-time，即时编译，运行时动态编译。 AOT，Ahead Of Time，提前编译，运行前编译成机器码。应用在安装的时候会启动 dex2oat 把dex预编译成 ELF 文件，以后运行程序的时候不用重新编译，因此应用启动更快、运行更快、体验更流畅、触感反馈更及时  JIT缺点：\n由于JIT是运行时动态编译，虽然可以对执行次数频繁的dex代码进行一定优化，但运行时编译成机器码仍然更消耗cpu，更耗电\nAOT缺点：\n应用安装和系统升级之后的应用优化比较耗时（重新编译，把程序代码转换成机器语言）优化后的文件会占用额外的存储空间\n寄存器和栈 寄存器是cpu上的一块高速缓存，寄存器的速度要比栈快很多\nclass\u0026amp;dex class和dex都是8位字节的二进制流文件，但相比class，dex(Dalvik executable)去掉了class文件中很多冗余信息，数据排列也紧密，并将很多class文件整合到dex文件中，减少了IO操作，提高了类的查找速度，dex把所有class文件的header头(包含JDK)写成了一个,所有的常量放在一个池里, dex文件只维护了一个索引\n其他 odex(Optimized dex) 是Dalvik环境中使用dexopt对dex文件根据当前ROM特性优化后的dex文件，生成odex文件 最终存在手机的data/dalvik-cache目录下\noat(Optimized Android file Type) ART环境下dex2oat工具处理过dex后的文件data/app 安装目录 安装时会把apk文件copy到这里\ndata/dalvik-cache 如上述描述中的存放.dex(.odex 无论davilk的dex 还是art的oat格式)\ndata/data/pkg/ 存放应用程序的数据\nJVM\u0026amp;Dalvik\u0026amp;ART JVM  基于栈的的虚拟机 将java源文件编译成class字节码文件，多class文件运行在虚拟机上  java-\u0026gt;class-\u0026gt;虚拟机运行\nJVM在运行的时候为每一个类装载字节码\nDalvik  基于寄存器的虚拟机,相对于堆栈模式加载速度更快 将java源文件编译成class字节码文件，再由dex.bat编译成一个dex文件(后来因为65535问题有了MultiDex方案，将原来的一个dex拆分为多个dex文件)运行在虚拟机上 Dalvik采用JIT 相比JVM，Dalvik更适合低内存低cpu运行  ART Android4.4发布ART，此时Dalvik和ART共存，用户可以手动选择，Android5.0废弃DVM，只使用ART，ART和Dalvik的主要区别是ART采用了AOT技术，运行前将dex编译成机器码，另外ART还对GC过程的也进行了改进，GC 保持暂停状态期间并行处理，在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短，Android7.0以前只使用AOT方式，但Android7.0及后AOT和JIT共存，安装时dex不会再被编译成机器码，App运行时,dex文件先通过解析器被直接执行，热点函数会被识别并被JIT编译后存储在 jit code cache 中并生成profile文件以记录热点函数的信息，手机进入 IDLE（空闲） 或者 Charging（充电） 状态的时候，系统会扫描 App 目录下的 profile 文件并执行 AOT 过程进行编译\n参考\n Dalvik和Art,JIT ,AOT, oat, dex, odex Dalvik,ART与ODEX相爱相生  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/kotlin-%E5%8D%8F%E7%A8%8B/",
	"title": "Kotlin协程",
	"tags": ["kotlin", "协程"],
	"categories": [],
	"series": [],
	"description": "Kotlin协程",
	"content": "协程中又一个概念CPS(Continuation Passing Style)\n协程是用户态的行为类似线程的库\n用户态：不想线程在用户态和内核态切换\n类似线程：只是行为类似\n库：协程本质上是一个用线程次调度代码块的库\n可能你会问 没看到线程调度啊 这事编译器字节码操作\n解决线程问题由最开始的代码层面的锁如java中的lock,到一些以node.js为代表的单线程异步回调，异步回调的方式引起Callback hell,再到协程，协程使用状态机处理不同的挂起点，避免了Callback hell\n 线程 actor 协程 协程可以理解为一段代码片段，Kotlin中的协程是利用编译器操作字节码实现的，本质上在利用线程池来切换协程代码片段,协程遇到阻塞会yiel让出cpu并保存上下文,resume恢复的时候恢复上下文  java中的lock避免了锁消耗\nactor和协程的优势是没有锁消耗且切换不想线程那样需要在用户态和内核态切换\n先阶段行业里的比较流行的解决方案之一就是单线程加上异步回调。其代表派是node.js以及Java里的新秀Vert.x。他们的核心思想是一样的，遇到需要进行I/O操作的地方，就直接让出CPU资源，然后注册一个回调函数，其他逻辑则继续往下走，I/O结束后带着结果向事件队列里插入执行结果，然后由事件调度器调度回调函数，传入结果。这时候执行的地方可能就不是你原来的代码区块了，具体表现在代码层面上，你会发现你的局部变量全部丢失，毕竟相关的栈已经被覆盖了，所以为了保存之前的栈上数据，你要么选择带着一起放入回调函数里，要么就不停的嵌套，从而引起反人类的Callback hell。\n因此相关的Promise，CompletableFuture等技术都是为解决相关的问题而产生的。但是本质上还是不能解决业务逻辑的割裂\n相比于callback接口回调的异步框架，Coroutine这个暂停和恢复在没有JVM支持下，比较难以理解，是怎么做到的？有没有什么魔法？其实JVM中Coroutine的实现方式有很多(implementing-coroutines-in-java)，Quasar Fiber则是通过字节码修改技术在编译或载入时织入必要的上下文保存/恢复代码，通过抛异常来暂停，恢复的时候根据保存的上下文(Continuation),恢复jvm的方法调用栈和局部变量,Quasar Fiber提供相应的Java类库来实现,对应用有一定的侵入性(很小)\nQuasar Fiber 主要有 Instrument + Continuation + Scheduler几个部分组成\nInstrument 做一些代码的植入，如park前后上下文的保存/恢复等\nContinuation 保存方法调用的信息，如局部变量，引用等,用户态的stack,这个也是跟akka等基于固定callback接口的异步框架最大的区别\nScheduler 调度器，负责将fiber分配到具体的os thread执行\n参考：\n 次时代Java编程（一）：Java里的协程 Coroutine in Java - Quasar Fiber实现 深入理解JVM - Java内存模型与线程 - 第十二章 Java线程中wait状态和block状态的区别? 用户态和内核态的理解和区别 Java中的锁分类 协程  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/media/",
	"title": "media",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/ndk/",
	"title": "ndk",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/rxjava/",
	"title": "rxjava",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/rxjava/",
	"title": "rxjava",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/rxjava2%E6%BA%90%E7%A0%81%E5%8F%8A%E4%BD%BF%E7%94%A8/",
	"title": "RxJava2源码及使用",
	"tags": ["java", "rxjava", "android"],
	"categories": [],
	"series": ["源码解析", "rxjava"],
	"description": "RxJava2源码及使用",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/vr/",
	"title": "vr",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E5%8D%8F%E7%A8%8B/",
	"title": "协程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%8D%8F%E7%A8%8B/",
	"title": "协程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/",
	"title": "四大组件",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/",
	"title": "四大组件",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/",
	"title": "多线程",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AF%A6%E8%A7%A3/",
	"title": "多线程详解",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "Syntax highlighting test",
	"content": "前置知识 线程状态：\n 初始态（NEW） 运行态（RUNNABLE）  就绪态（READY） 运行态（RUNNNIN）   阻塞态（BLOCKED） 等待态（WAITING） 超时等待态（TIMED_WAITING） 终止态（TERMINATED）  cpu指令分为特权指令和非特权指令  特权指令 对内存空间的访问范围不受限制，即：既可以访问用户存储空间也可以访问系统存储空间，一般只给操作系统使用，特权指令：时钟操作 I/O操作 内存清零 关机等 非特权指令 一般程序使用，只能访问用户存储空间完成一般性的操作和任务  用户态和内核态  用户态 只能运行非特权指令 内核态 可运行特权指令  用户态切换到内核态的三种方式：  系统调用,在CPU中的实现称之为陷阱指令(Trap Instruction) 如：文件操作和网络数据发送 未预知的异常(注意不等同于java中的异常),如：缺页异常 外围设备中断  Intel x86cpu 有Ring0~Ring3四个级别，Linux将Ring0作为内核态，Ring3作为用户态。Linux进程有4G地址空间 1~3G用户态地址空间 3~4G是内核态地址空间\njava线程和操作系统线程是一一对应的关系，每一个java/c++线程都映射到操作系统上的一个线程.Java中对线程的操作，如：创建/阻塞/切换等都要切换到内核态，这种切换消耗大量系统资源，因为用户态与内核态都有各自专用的内存空间，专用的寄存器等，用户态切换至内核态需要传递给许多变量、参数给内核，内核也需要保护好用户态在切换时的一些寄存器值、变量等，以便内核态调用结束后切换回用户态继续工作。Java中synchronized会导致未获得锁的线程进入阻塞状态，引起用户态与内核态的切换\n多线程的意义 首先明确一个cpu核心同时只能执行一个系统线程，这也是为什么一般线程池是和cpu核心关联,通常维护线程alive数量最小设置为CPU_COUNT+1，最大设置为CPU_COUNT*2+1\n多线程的出现是解决并发和性能问题，那么是不是多线程比单线程性能更好呢？那么要看你对性能的理解，对于整个计算机来说并不一定，这要分情况。影响线程性能的主要是线程的状态切换和线程间切换以及为了线程安全引入的线程锁带来的性能消耗\n 单核cpu   计算密集型操作 本身大量占用cpu，多线程的创建和上下文切换反而加重了cpu的负担，影响整个计算机的性能，但程序本身有更多机会竞争cpu时间片 I/O密集型操作 由于操作过程较少占用cpu，多线程有助于提高性能。我们平时大多是这种操作  多核cpu 由于是多核可以同时执行多个线程，此时多线程是有助于极高整个计算机的利用率，提升性能  每个线程维护一个自己的栈\njava内存模型直接保证的原子性包括：read load use assign store write这6个，另外synchronized之间的操作也具备原子性\nLockSupport.park()\nJava线程的API  thread.start()当前线程进入RUNNABLE Thread.yield()不释放锁,当前运行态线程让出cpu时间片给同等优先级的线程执行并进入就绪态 thread.interrupt() 设置thread中断标志位为true,Java中的输入输出流并没有类似于Interrupt的机制，但是Java的InterruptableChanel接口提供了这样的机制，任何实现了InterruptableChanel接口的类的IO阻塞都是可中断的，中断时抛出ClosedByInterruptedException，也是由Thread对象调用Interrupt方法完成中断调用。IO中断后将关闭通道。实现InterruptableChanel接口的类包括FileChannel,ServerSocketChannel, SocketChannel, Pipe.SinkChannel andPipe.SourceChannel，也就是说，原则上可以实现文件、Socket、管道的可中断IO阻塞操作。虽然解除IO阻塞的方法还可以直接调用IO对象的Close方法，这也会抛出IO异常。但是InterruptableChanel机制能够使处于IO阻塞的线程能够有一个和处于中断等待的线程一致的线程停止方案 thread.isInterrupted() 返回thread中断标志位状态 Thread.interrupted() 返回当前thread中断标志位状态并清除中断标志位,另外抛出中断异常被捕获时也会清除中断标志位，如： 1 2 3 4 5 6  try{ Thread.sleep(2000); }catch(InterruptedException e){ e.printStackTrace(); //进入中断异常的catch代码块时会清除中断标志位 }    wait() 释放锁,以便其他等待此锁的线程执行，当前线程进入等待态，必须在synchronized同步代码块中调用 wait(1000) 释放锁,以便其他等待此锁的线程执行，当前线程进入超时等待态，必须在synchronized同步代码块中调 notify()/notifyAll() 当前线程进入RUNNABLE，此时调用当前monitor.wait()的线程重新竞争锁。必须在synchronized同步代码块中调\nnotify是依附于锁(监视器)monitor的，故必须是monitor.wait()/monitor.notifyAll()，如： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  private final Object obj = new Object(); private String name = null; public void xxx() { synchronized (obj) { while (name == null) { try { obj.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } public void yyy() { synchronized (obj) { name = \u0026#34;name\u0026#34;; obj.notify(); } }    thread.join() 当前线程进入等待态,注意不是thread，但thread必须是alive状态否则join无效，join是通过wait实现的 thread.join(1000) 当前线程进入超时等待态，其他同join() thread.isAlive() 当前显示是否alive,A thread is alive if it has been started and has not yet died thread.setDaemon(true) 设置线程为守护线程，必须在调用线程的start()方法之前设置，否则会跑出IllegalThreadStateException异常，Java线程分为两种：用户线程和守护线程。当一个程序中所有用户进程结束，程序也就终止了，守护线程也会随即终止，且不保证守护线程执行完毕,即守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点，这也是利用守护线程的原因。守护线程是用来在后台做通用服务的，如垃圾回收线程即时一个守护线程。不要在守护线程中执行业务逻辑操作(比如对数据的读写等).\njava还有一类特殊线程：Hook (钩子) 线程\nRuntime.getRuntime().addShutdownHook(hook);\n在程序即将退出的时候，也就是 JVM 程序即将退出的时候，Hook 线程就会被启动执行,Hook (钩子) 线程的应用场景：  防止程序重复执行，具体实现可以在程序启动时，校验是否已经生成 lock 文件，如果已经生成，则退出程序，如果未生成，则生成 lock 文件，程序正常执行，最后再注入 Hook 线程，这样在 JVM 退出的时候，线程中再将 lock 文件删除掉 Hook 线程中也可以执行一些资源释放的操作，比如关闭数据库连接，Socket 连接等   Thread.sleep(1000) 不释放锁，当前线程进入超时等待态,Thread.sleep(0)的作用，就是“触发操作系统立刻重新进行一次CPU竞争”  thread.interrupt()和Thread.interrupted()会唤醒Thread.sleep和thread.wait()导致Thread.sleep和thread.wait()抛出中断异常\nthread.stop, thread.suspend and thread.resume为什么被deprecated，详见参考Java Thread Primitive Deprecation\nthread.stop deprecated原因总的说就是太暴力，会引发不可预期问题。因为thread.stop会抛出ThreadDeath异常，而The monitors are unlocked as the ThreadDeath exception propagates up the stack。一般通过代码控制，或者可以通过thread.interrupt()设置锚点配合代码控制\nthread.suspend and thread.resume deprecated原因是容易引起死锁，可以用obj.wait()/obj.notifyAll()替代\n锁分类  公平锁/非公平锁 公平锁非公平锁的区别是是否是按照申请锁的顺序获取锁。其中非公平锁可能会造成优先级反转和饥饿现象。非公平锁的优点是吞吐量比公平锁大，因为维持公平有一定消耗  优先级反转  T0 thread3(低优先级)获得锁SYNC1 T1 thread2(中优先级)与thread3竞争抢占了cpu时间片，thread3仍持有锁 T2 thread1(高优先级)与thread2竞争抢占了cpu时间片 T3 thread1需要获取锁，但锁被thread3持有，thread1挂起 T4 thread2和thread3都处于可运行态，但由于thread2的优先级高于thread3，thread2优先抢占cpu时间片 总结：这导致了一个现象：低优先级thread2比高优先级thread1先执行 解决：优先继承，即高优先级线程需要低优先级线程持有的锁时，临时提升低优先级线程的优先级，如上面将thread3优先级临时提升到thread1的优先级别，当锁被释放的时候thread3恢复到原来的优先级,这一过程一般有操作系统完成   饥饿 高优先级线程不断进入导致低优先级线程一直无法得到执行   独享锁/共享锁 独享锁：只能被一个线程同时持有，共享锁：可被多个线程同时持有 互斥锁/读写锁 自旋锁 在Java中，自旋锁是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少线程上下文切换的消耗，缺点是循环会消耗CPU 可重入锁 又名递归锁，是指已持有该锁再次调用需要该锁的其他代码块自动获取锁。可重入锁有效避险死锁现象 分段锁 分段锁其实是一种锁的设计，并不是具体的一种锁,目的是细化锁的粒度 java中ConcurrentHashMap就是分段锁，当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过hashcode来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入，但在统计size的时候，需要获取hashmap全局信息的时候，就需要获取所有的分段锁才能统计 向锁/轻量级锁/重量级锁 这三种锁是指锁的状态，并且是针对Synchronized。在Java 5通过引入锁升级的机制来实现高效Synchronized。这三种锁的状态是通过对象监视器在对象头中的字段来表明的。\n偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。\n轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，\n重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低 乐观锁/悲观锁 乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。\n悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。\n乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。\n悲观锁在Java中的使用，就是利用各种锁。\n乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新  Java中的锁实现  Synchronized 公平锁 独享锁 可重入锁 synchronized不包含在方法签名，不能继承 Lock Java1.5 通过AQS的来实现线程调度，是代码层面实现的锁，比Synchronized轻量，lock的代码块程序抛出异常也不会释放锁，需要手动释放，故使用Lock必须在try{}catch{}块中进行，并且将释放锁的操s作放在finally代码块\nlock() 获取锁，未获取则等待\ntryLock() 获取锁，未获取则等待，有返回值，表示获取锁是否成功\ntryLock(long time, TimeUnit unit)获取锁，未获取则等待，有返回值表示设定时间内获取锁是否成功\nockInterruptibly() 如果线程正在等待获取锁，则这个线程能够响应中断，通过thread.interrupt()中断线程的等待状态\n注：thread.interrupt()只能中断阻塞的线程，故线程获取锁之后不能响应interrupt()中断  ReentrantLock 可重入锁，独享锁，默认非公平锁，可以通过构造函数指定是否是公平， ReadWriteLock 读写锁 读锁是共享锁，写锁是独享锁，即可以共读读，不能共写读，读写，写写  ReentrantReadWriteLock 可重入读写锁，继承ReadWriteLock，并支持ReentrantLock可重入锁的特性      参考：\n 深入理解java内存模型系列文章 synchronized原理和锁优化 Java 多线程之 Hook (钩子) 线程 Java Thread Primitive Deprecation Java线程中wait状态和block状态的区别? 用户态和内核态的理解和区别 Java中的锁分类 Java 并发性和多线程  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%A1%A5%E5%85%85/",
	"title": "多线程详解补充",
	"tags": ["多线程"],
	"categories": [],
	"series": [],
	"description": "对多线程详解中提到的部分概念的补充",
	"content": "Java内存模型 Java内存模型主要目标：定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variable）与Java编程中的变量略有区别，它包括实例变量/静态字段和构成数组对象的元素，不包括局部变量和方法参数（线程私有）。为获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交换，也没有限制即时编译器调整代码执行顺序这类权利。\nJava内存模型规定所有变量都存储在主存（Main Memory）中（虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory），线程的工作内存保存了被线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取/赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主存来完成。\n这里的主内存/工作内存与Java内存区域中的Java栈/堆/方法区并不是同一个层次的内存划分。如果两者一定要勉强对应起来，那从变量/主内存/工作内存的定义来看，主内存主要对应于Java堆中对象的实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。从更低的层次来说，主存就是硬件的内存，而为获取更好的运算速度，虚拟机及硬件系统可能会让工作内存优先存储于寄存器和高速缓存。\n主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成:lock unlock read load use assign store write\n对long和double型变量的特殊规则 允许虚拟机将没有被volatile修饰的64位数据类型（long和double）的读取操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，就点就是long和double的非原子协定（Nonatomic Treatment of double and long Variables）。\n如果多个线程共享一个为声明为volatile的long或double类型变量，并同时对他们进行读取和修改操作，那么有些线程可能会读取到一个即非原值，也不是其他线程修改值得代表了“半个变量”的数值。\n不过这种读取带“半个变量”的情况非常罕见（在目前商用虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。\n原子性、可见性和有序性  原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，我们大致可以认为基本数据类型的访问具备原子性（long和double例外）。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足需求，尽管虚拟机未把lock和unlock操作直接开放给用户，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反应到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。 可见性（Visibility）：指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 有序性（Ordering）：Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”（Within-Thread As-if-Serial Semantics），后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入  多线程安全 多线程安全问题根本原因是内存copy和时间片分配导致的，要做到线程安全就是要做到“局部串行”或者原子性，比如两个线程同时访问一个临界资源（一个对象，对象中的属性，一个文件，一个数据库等）可能引发线程安全问题，这时就要做到两个线程访问临界资源这一局部顺序是串行执行\n高优先级线程并不一定比低优先级线程先抢占cpu资源，高级优先抢占资源的权重大，但有随机性\nvolatile/Semaphore/AtomicXXX 两者本质上不是同一类东西\n volatile Java关键字 声明某个变量值的一致性(内存同步)，但不保证原子操作，对赋值操作可以保证原子性。如：a=10，不能保证a++操作的原子性，因为a++其实是a=a+1的语法糖，a=a+1在内存中其实是分两步的：temp=a+1 a=temp。对于复杂对象的赋值操作原子性，如：User user=user1;User user=new User;,但不能保证对user.name属性操作的原子性.即可以看作只能赋值操作原子性。volatile 声明某个变量值的一致性(内存同步)，但不保证原子操作 Semaphore 控制同时访问某个特定资源或者某个操作的操作数量 AtomicXXX Java库实现 可以保证a++操作的原子性  CountDownLatch与join 比如有三个线程 thread1,thread2,thread3\n当thread3需要thread1,thread2都执行完毕后执行，则两者皆可实现，但当thread3只需要thread1,thread2其中一个执行完毕就可执行的场景CountDownLatch很容易实现，使用join则并不容易实现\n详见参考：CountDownLatch理解一：与join的区别\nRunable Future Callable   Runable 1.没有返回值 2.无法抛异常\n1 2 3  public interface Runnable { public abstract void run(); }     Callable 1.有返回结果，可以抛异常，但不像Runnable那样通过Thread的start方法就能启动实现类的run方法，通常利用ExecutorService的submit方法去启动call方法自执行任务，而ExecutorService的submit又返回一个Future类型的结果，因此Callable通常也与Future一起使用\n1 2 3  public interface Callable\u0026lt;V\u0026gt; { V call() throws Exception; }     Future 保存异步计算的结果,可以在我们执行任务时去做其他工作,Future有一下方法\n1. boolean cancel(boolean mayInterruptIfRunning);用来取消任务，成功返回true，失败则返回false\n2.boolean isCancelled();任务是否已经取消\n3.boolean isDone();任务是否已经完成\n4.V get() throws InterruptedException, ExecutionException;用来获取执行结果，这个方法会产生阻塞会一直等到任务执行完毕才返回\n5.V get(long timeout, TimeUnit unit)\nthrows InterruptedException, ExecutionException, TimeoutException;用来获取执行结果，如果在指定时间内，还没获取到结果，直接返回null\n使用Future的好处：\n1.获取任务的结果，判断任务是否完成，中断任务\n2.Future的get方法很好的替代的了Thread.join或Thread,join(long millis)\n3.Future的get方法可以判断程序代码(任务)的执行是否超时，如：\n1 2 3 4 5 6  try { future.get(60,TimeUtil.SECOND); } catch(TimeoutException timeout){ og4j.log(\u0026#34;异常，将被取消！！\u0026#34;); future.cancel(); }    FutureTask CompletableFuture 提供了函数式编程的能力，可以通过回调的方式处理计算结果，并且提供了转换和组合CompletableFuture的方法,帮助我们简化异步编程的复杂性,有点类似于rxjava的模式，当然没有提供这么丰富的功能    多线程间的通信  内存共享  共享volatile变量 synchronized+notify+wait lock+condition semaphere+flag   管道  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  public class CommunicateWhitPiping { public static void main(String[] args) { PipedOutputStream pos = new PipedOutputStream(); PipedInputStream pis = new PipedInputStream(); try { //将管道输入流与输出流连接 此过程也可通过重载的构造函数来实现  pos.connect(pis); } catch (IOException e) { e.printStackTrace(); } //创建生产者线程  Producer p = new Producer(pos); //创建消费者线程  Consumer c = new Consumer(pis); //启动线程  p.start(); c.start(); } } //生产者线程(与一个管道输入流相关联) class Producer extends Thread { private PipedOutputStream pos; public Producer(PipedOutputStream pos) { this.pos = pos; } public void run() { int i = 8; try { pos.write(i); } catch (IOException e) { e.printStackTrace(); } } } //消费者线程(与一个管道输入流相关联) class Consumer extends Thread { private PipedInputStream pis; public Consumer(PipedInputStream pis) { this.pis = pis; } public void run() { try { System.out.println(pis.read()); } catch (IOException e) { e.printStackTrace(); } } }    公共接口 消息通信 如：Actor模型  BlockingDeque  BlockingDeque LinkedBlockingQueue LinkedBlockingDeque ConcurrentHashMap ConcurrentLinkedQueue DelayQueue SynchronousQueue LinkedTransferQueue  多线程的经典场景-生产者消费者模式实现  阻塞队列实现 synchronized关键字实现 lock实现  参考：\n 深入理解JVM - Java内存模型与线程 - 第十二章 Java CompletableFuture 详解 CountDownLatch理解一：与join的区别  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E6%8F%92%E4%BB%B6%E5%8C%96/",
	"title": "插件化",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E6%8F%92%E4%BB%B6%E5%8C%96%E5%92%8C%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "插件化和热更新&amp;App Bundle",
	"tags": ["android", "插件化", "热更新"],
	"categories": [],
	"series": ["插件化", "热更新"],
	"description": "Syntax highlighting test",
	"content": "PathClassLoader和DexClassLoader 要做热更新就要用ClassLoader加载hotfix dex中的类,用哪个ClassLoader呢？我们在Activity中打印classLoader::class.java.name可以看到是dalvik.system.PathClassLoader\nAndroid中使用DexClassLoader加载apk dex类文件\n查看PathClassLoader\n1 2 3 4 5 6  public PathClassLoader(String dexPath, ClassLoader parent) { super(dexPath, null, null, parent); } public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) { super(dexPath, null, librarySearchPath, parent); }   只有几个构造方法，但PathClassLoader继承自BaseDexClassLoader，继续进入BaseDexClassLoader查看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  protected Class\u0026lt;?\u0026gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { // 首先检查是否已经加载过  Class\u0026lt;?\u0026gt; c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); } else { c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //parent.loadClass可鞥在此抛出异常  } if (c == null) { c = findClass(name); } } return c; }   loadClass首先检查是不是已加载过这个类，若没有，调用父ClassLoader的loadClass，以此上推检查父ClassLoader是否加载过此类，若都没有加载则调用findClass\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  @Override protected Class\u0026lt;?\u0026gt; findClass(String name) throws ClassNotFoundException { // First, check whether the class is present in our shared libraries.  if (sharedLibraryLoaders != null) { for (ClassLoader loader : sharedLibraryLoaders) { try { return loader.loadClass(name); } catch (ClassNotFoundException ignored) { } } } // Check whether the class in question is present in the dexPath that  // this classloader operates on.  List\u0026lt;Throwable\u0026gt; suppressedExceptions = new ArrayList\u0026lt;Throwable\u0026gt;(); Class c = pathList.findClass(name, suppressedExceptions); if (c == null) { ClassNotFoundException cnfe = new ClassNotFoundException( \u0026#34;Didn\u0026#39;t find class \\\u0026#34;\u0026#34; + name + \u0026#34;\\\u0026#34; on path: \u0026#34; + pathList); for (Throwable t : suppressedExceptions) { cnfe.addSuppressed(t); } throw cnfe; } return c; }   最终执行到Class c = pathList.findClass(name, suppressedExceptions);，再继续查看DexPathList的findClass方法\n1 2 3 4 5 6 7 8 9 10 11 12 13  public Class\u0026lt;?\u0026gt; findClass(String name, List\u0026lt;Throwable\u0026gt; suppressed) { for (Element element : dexElements) { Class\u0026lt;?\u0026gt; clazz = element.findClass(name, definingContext, suppressed); if (clazz != null) { return clazz; } } if (dexElementsSuppressedExceptions != null) { suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions)); } return null; }   再继续进入Element的findClass方法\n1 2 3  public Class\u0026lt;?\u0026gt; findClass(String name, ClassLoader definingContext,List\u0026lt;Throwable\u0026gt; suppressed) { return dexFile != null ? dexFile.loadClassBinaryName(name, definingContext, suppressed): null; }   我们只需要获取热更新补丁的dexElements与原dexElements合并，app再次重新启动就会完成修复\nClassLoader本身也是一个类，它是怎么被加载的呢？在jvm启动的时候就有一个根ClassLoader,即：bootstrapclassloader\n有个根classloader\n插件化在几年前火的一塌糊涂，由插件化延续到后来的热更新，近几年似乎没了当初的狂热\n插件化和热更新的意义在于动态化升级。不同于web只要后台发布用户前端的下次请求页面和逻辑都会改变，Android的UI及逻辑代码在手机上，发布需要经过各大市场，由审核时间，且就算发布到各大市场用户也不一定更新，强制用户更新的结果可能是被用户强制卸载。但是发布新功能/紧急修复bug的需求是巨大的。于是先有了\n 将web那一套搬到移动端的做法，但是web在移动端的性能让其体验很差，虽然出现了很多框架增强了许多，但还是有差距 原生的插件化和热更新 RectNative 热更新  RectNative用脚本语言js控制逻辑，使用c++桥接的形式控制原生控件显示，由于脚本语言不用编译，可以动态发布从而实现热更新\n由于官方不支持插件化和热更新（理由是安全问题）导致原生插件化和热更新只能另辟蹊径\n热更新分两种，一种是重启生效，一种是即时生效\n即时生效的原理是：这个过程相当复杂不易控制\n这里主要讲喜爱重启生效热更新模式的原理：\nClassLoader,java的ClassLoader双亲委托机制\n干预Android加载，既然要干预那就要首先了解其原加载过程\n1.利用代理activity启动插件化中的activity\n2.模仿系统加载启动activity\n"
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/",
	"title": "源码解析",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%83%AD%E6%9B%B4%E6%96%B0/",
	"title": "热更新",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%9B%B4%E6%92%AD/",
	"title": "直播",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/",
	"title": "编程基础",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-measurelayoutdraw/",
	"title": "自定义View-measure&amp;layout",
	"tags": ["自定义view", "android"],
	"categories": [],
	"series": ["自定义view"],
	"description": "measure&amp;layout&amp;draw",
	"content": "View\u0026amp;ViewGroup的自定义 measure/onMeasure  measure\n是View测量自己所需空间的方法，通常是调用onMeasure方法完成子控件的测量并最终确定自己的尺寸。measure方法一般无需也尽量不要重写。无论是View还是ViewGroup都可以重写onMeasure完成具体计算 onMeasure\n是父控件调用子控件测量自身的方法(通常是childView.measure())完成测量，并最终确定自己尺寸大小。并在测量完成后调用setMeasuredDimension()方法传入width/height，setMeasuredDimension()会将传入的width/height储存起来，在layout时用调用该view的getMeasuredWidth()获取测量尺寸进行布局，需要注意的是必须在onMeasure()中调用setMeasuredDimension()，因为View的measure()方法中会检测是否有PFLAG_MEASURED_DIMENSION_SET标志，若没有则会抛出异常，而PFLAG_MEASURED_DIMENSION_SET正是在被setMeasuredDimension()方法调用的setMeasuredDimensionRaw()方法中设置。另外需要明确的是setMeasuredDimension()是设置自己的大小，因此不是所有都需要先调用childView.measure()先确定子控件大小再调用setMeasuredDimension()，控件自身大小和子控件也没有强制关系，全看实现，一旦确定自身的大小就可调用setMeasuredDimension()。例如NestedScrollView自身的尺寸是有限的，但子控件的尺寸是无限的。\n无论是measure还是onMeasure，其两个参数int类型是MeasureSpec结构的，即：高2位是测量的Mode类型：EXACTLY/AT_MOST/UNSPECIFIED，低30位是尺寸大小值。可以通过MeasureSpec类方便获得。而onMeasure中调用的setMeasuredDimension()参数并不一定完全是尺寸值，可能包含MeasureState，MeasureState占这个int参数的高8位，剩余低24位才是真正的尺寸值。见其他API\nView中measure源码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87  /** * \u0026lt;p\u0026gt; * This is called to find out how big a view should be. The parent * supplies constraint information in the width and height parameters. * \u0026lt;/p\u0026gt; * * \u0026lt;p\u0026gt; * The actual measurement work of a view is performed in * {@link #onMeasure(int, int)}, called by this method. Therefore, only * {@link #onMeasure(int, int)} can and must be overridden by subclasses. * \u0026lt;/p\u0026gt; * * * @param widthMeasureSpec Horizontal space requirements as imposed by the * parent * @param heightMeasureSpec Vertical space requirements as imposed by the * parent * * @see #onMeasure(int, int) */ public final void measure(int widthMeasureSpec, int heightMeasureSpec) { //判断是否是视觉边界，做相应处理  boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } // Suppress sign extension for the low bytes  long key = (long) widthMeasureSpec \u0026lt;\u0026lt; 32 | (long) heightMeasureSpec \u0026amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); //是否是强制重新布局，当调用requestLayut()时会添加PFLAG_FORCE_LAYOUT标志  final boolean forceLayout = (mPrivateFlags \u0026amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // Optimize layout by avoiding an extra EXACTLY pass when the view is  // already measured as the correct size. In API 23 and below, this  // extra pass is required to make LinearLayout re-distribute weight.  final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY \u0026amp;\u0026amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) \u0026amp;\u0026amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); final boolean needsLayout = specChanged \u0026amp;\u0026amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); //如果是强制重新布局或者尺寸改变需要重新布局  if (forceLayout || needsLayout) { // first clears the measured dimension flag  mPrivateFlags \u0026amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex \u0026lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back  onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed  setMeasuredDimensionRaw((int) (value \u0026gt;\u0026gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise  // an exception to warn the developer  if ((mPrivateFlags \u0026amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(\u0026#34;View with id \u0026#34; + getId() + \u0026#34;: \u0026#34; + getClass().getName() + \u0026#34;#onMeasure() did not set the\u0026#34; + \u0026#34; measured dimension by calling\u0026#34; + \u0026#34; setMeasuredDimension()\u0026#34;); } //添加需要重新布局标志  mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; /将结果转成long类型，高32位是mMeasuredWidth，低32位是mMeasuredHeight。缓存合成的measure结果 mMeasureCache.put(key, ((long) mMeasuredWidth) \u0026lt;\u0026lt; 32 | (long) mMeasuredHeight \u0026amp; 0xffffffffL); // suppress sign extension }   layout/onLayout  layout\n是View确定自己位置的方法(通过调用setFrame)，并调用onLayout方法布局子控件。layout方法一般不需要重写。 onLayout\n是父控件确定子控件位置的方法，一般是在onLayout方法中调用子控件的layout方法来实现。如：childView.layout()。View中该方法是一个空方法。ViewGroup中重写为一个抽象方法。因此自定义继承自ViewGroup的控件需要重写该方法。而自定义继承View的控件因为不包含子控件，因此不需要重写该方法\nView中layout源码：  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 \u0026amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; //是否是视觉边界布局，调用响应方法，setFrame返回边界是否改变  boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); //如果边界改变或者尺寸改变需要重新布局，调用onLayout让childView也重新布局  if (changed || (mPrivateFlags \u0026amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b); ... mPrivateFlags \u0026amp;= ~PFLAG_LAYOUT_REQUIRED; ... } ... //清除强制布局标志  mPrivateFlags \u0026amp;= ~PFLAG_FORCE_LAYOUT; //添加布局完成标志  mPrivateFlags3 |= PFLAG3_IS_LAID_OUT; ... }   draw/onDraw draw 图画前景/背景/Edges等，并调用onDraw图画自身内容以及调用dispatchDraw图画子控件,onDraw具体使用因为设计较多内容我会另开一篇\n为什么measure和layout分开 理想情况measure后知道了尺寸即可layout，但是measure的情况比较复杂，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;LinearLayout android:orientation=\u0026#34;vertical\u0026#34; android:layout_width=\u0026#34;wrap_content\u0026#34; android:layout_height=\u0026#34;wrap_content\u0026#34;\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView1\u0026#34; android:layout_width=\u0026#34;match_parent\u0026#34; android:layout_height=\u0026#34;match_parent\u0026#34; android:background=\u0026#34;@color/orange_red\u0026#34;/\u0026gt; \u0026lt;TextView android:id=\u0026#34;@+id/textView2\u0026#34; android:layout_width=\u0026#34;360dp\u0026#34; android:layout_height=\u0026#34;220dp\u0026#34; android:background=\u0026#34;@color/colorPrimary\u0026#34;\u0026gt; \u0026lt;/LinearLayout\u0026gt;   LinearLayout需要经过两次测量才可以确定textView1的尺寸，因此需要将measure和layout分开处理，不然layout也要进行两次。因为LinearLayout是wrap_content，即内容多大本身尺寸就多大，而textView1是match_parent，即充满LinearLayout，这就造成了矛盾，此时LinearLayout的测量过程是：测量textView1，先将textView1的宽高测量为0，再测量textView2，宽：360，高：220，此时父控件宽：360dp，高：220。再次onMeasure方法测量，此时再将textView1宽度设置为360，高为0。\n见View:\n1 2 3 4 5 6 7  public void layout(int l, int t, int r, int b) { if ((mPrivateFlags3 \u0026amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 \u0026amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } ... }   ViewGroup ViewGroup 中封装了getChildMeasureSpec/measureChildren/measureChild/measureChildWithMargins几个方法方便我们自定义控件时使用\n getChildMeasureSpec\n根据传入的parentMeasureSpec(即onMeasure的参数)确定子控件的childMeasureSpec。源码较长，但逻辑十分简单，这里就不贴了。 measureChild 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  /** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding. * The heavy lifting is done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param parentHeightMeasureSpec The height requirements for this view */ protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { final LayoutParams lp = child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }    measureChildren 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  /** * Ask all of the children of this view to measure themselves, taking into * account both the MeasureSpec requirements for this view and its padding. * We skip children that are in the GONE state The heavy lifting is done in * getChildMeasureSpec. * * @param widthMeasureSpec The width requirements for this view * @param heightMeasureSpec The height requirements for this view */ protected void measureChildren(int widthMeasureSpec, int heightMeasureSpec) { final int size = mChildrenCount; final View[] children = mChildren; for (int i = 0; i \u0026lt; size; ++i) { final View child = children[i]; if ((child.mViewFlags \u0026amp; VISIBILITY_MASK) != GONE) { measureChild(child, widthMeasureSpec, heightMeasureSpec); } } }    measureChildWithMargins 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  /** * Ask one of the children of this view to measure itself, taking into * account both the MeasureSpec requirements for this view and its padding * and margins. The child must have MarginLayoutParams The heavy lifting is * done in getChildMeasureSpec. * * @param child The child to measure * @param parentWidthMeasureSpec The width requirements for this view * @param widthUsed Extra space that has been used up by the parent * horizontally (possibly by other children of the parent) * @param parentHeightMeasureSpec The height requirements for this view * @param heightUsed Extra space that has been used up by the parent * vertically (possibly by other children of the parent) */ protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }     在自定义view的measure时可以使用上面四个方法，大部分情况无需再自己写，如：FrameLayout，但还是看具体情况，如NestedScrollView这类滚动的View就重写了measureChild及measureChildWithMargins，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  @Override protected void measureChild(View child, int parentWidthMeasureSpec, int parentHeightMeasureSpec) { ViewGroup.LayoutParams lp = child.getLayoutParams(); int childWidthMeasureSpec; int childHeightMeasureSpec; childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, getPaddingLeft() + getPaddingRight(), lp.width); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } @Override protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, getPaddingLeft() + getPaddingRight() + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( lp.topMargin + lp.bottomMargin, MeasureSpec.UNSPECIFIED); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); }   View中读取xml布局文件中View属性的源码：\n1 2 3 4 5  public void encode(@NonNull ViewHierarchyEncoder stream) { stream.beginObject(this); encodeProperties(stream); stream.endObject(); }   测量模式：EXACTLY/AT_MOST/UNSPECIFIED  EXACTLY 精确测量，子控件大小已经确定 AT_MOST 子控件需要多大就多大，但不超过MeasureSpec.getSize(measureSpec)，如父控件是MATCH_PARENT，子控件是WRAP_CONTENT，则子控件的测量模式是AT_MOST。由于顶级父控件是一个确定的屏幕尺寸，因此只要控件是WRAP_CONTENT，根据getChildMeasureSpec的实现只要它的父控件不是UNSPECIFIED则它的测量模式就是AT_MOST UNSPECIFIED 不加任何限制，子控件要多大就多大，通常是Scrollview高度的测量模式  其他API   getMeasuredState\n将宽度的MeasuredState和高度的MeasuredState合并成一个int类型，高16位是宽度的MeasuredState，低16位是高度的MeasuredState，但MeasuredState只占一个8位长度，所以其实只有高16位的低8位和低16位的低8位是有效值，其高8位都被0填充了\n1 2 3 4 5  public final int getMeasuredState() { return (mMeasuredWidth\u0026amp;MEASURED_STATE_MASK) | ((mMeasuredHeight\u0026gt;\u0026gt;MEASURED_HEIGHT_STATE_SHIFT) \u0026amp; (MEASURED_STATE_MASK\u0026gt;\u0026gt;MEASURED_HEIGHT_STATE_SHIFT)); }     getMeasuredWidthAndState()\n可以看出getMeasuredWidthAndState就是返回mMeasuredWidth值，而我们平时常用的getMeasuredWidth返回的是mMeasuredWidth的低24位，即去除MeasuredState的尺寸值。目前View的MeasuredState似乎只有一个值：MEASURED_STATE_TOO_SMALL\n1 2 3 4 5 6  public final int getMeasuredWidthAndState() { return mMeasuredWidth; } public final int getMeasuredWidth() { return mMeasuredWidth \u0026amp; MEASURED_SIZE_MASK; }     getMeasuredHeightAndState()\n类似getMeasuredWidthAndState()\n  resolveSize\u0026amp;resolveSizeAndState()\nSDK自带的计算尺寸的方法，resolveSizeAndState()是获取带MeasureState的尺寸，resolveSize调用resolveSizeAndState但去除了MeasureState部分保留的是真正的尺寸。setMeasuredDimension()究竟应该传递这两个哪个方法计算的结果？答案：都可以。看你需要\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  public static int resolveSize(int size, int measureSpec) { return resolveSizeAndState(size, measureSpec, 0) \u0026amp; MEASURED_SIZE_MASK; } public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) { final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) { case MeasureSpec.AT_MOST: if (specSize \u0026lt; size) { result = specSize | MEASURED_STATE_TOO_SMALL; } else { result = size; } break; case MeasureSpec.EXACTLY: result = specSize; break; case MeasureSpec.UNSPECIFIED: default: result = size; } return result | (childMeasuredState \u0026amp; MEASURED_STATE_MASK); }     getMeasureWidth和getWidth  getMeasureWidth\n从源码可以看出getMeasureWidth是mMeasuredWidth的尺寸值部分，而mMeasuredWidth是onMeasure中调用setMeasuredDimension()设置的 1 2 3  public final int getMeasuredWidth() { return mMeasuredWidth \u0026amp; MEASURED_SIZE_MASK; }    getWidth 1 2 3  public final int getWidth() { return mRight - mLeft; }   \n从源码看出getWidth()是边界计算而来，而设置边界是layout方法中调用的setFrame设置的，设置的值是layout方法的参数，而我们自定义View时在在onLayout方法中调用child.layout()传递而来的。而最初的这个值是由谁传递来的呢？说来话长：当我们启动activity时会执行到ActivityThread.handleResumeActivity，源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52  @Override public void handleResumeActivity(IBinder token, boolean finalStateRequest, boolean isForward,String reason) { ... final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); if (r == null) { // We didn\u0026#39;t actually resume the activity, so skipping any follow-up actions.  return; } ... final Activity a = r.activity; ... if (r.window == null \u0026amp;\u0026amp; !a.mFinished \u0026amp;\u0026amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; // Normally the ViewRoot sets up callbacks with the Activity  // in addView-\u0026gt;ViewRootImpl#setView. If we are instead reusing  // the decor view we have to notify the view root that the  // callbacks may have changed.  ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient) { if (!a.mWindowAdded) { a.mWindowAdded = true; wm.addView(decor, l); } else { // The activity will get a callback for this {@link LayoutParams} change  // earlier. However, at that time the decor will not be set (this is set  // in this method), so no action will be taken. This call ensures the  // callback occurs with the decor set.  a.onWindowAttributesChanged(l); } } // If the window has already been added, but during resume  // we started another activity, then don\u0026#39;t yet make the  // window visible.  }else if (!willBeVisible) { if (localLOGV) Slog.v(TAG, \u0026#34;Launch \u0026#34; + r + \u0026#34; mStartedActivity set\u0026#34;); r.hideForNow = true; } }   这其中的impl.notifyChildRebuilt();最终会调用ViewRootImpl自己的performLayout。另外wm.addView(decor, l);也会会如下依次调用WindowManagerGlobal.addView()-\u0026gt;ViewRootImpl.setView()-\u0026gt;ViewRootImpl.requestLayout()-\u0026gt;\u0026hellip;-\u0026gt;ViewRootImpl.performLayout()\n1 2 3 4 5 6 7  private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { ... //这里的host是ViewRootImpl.setView()时传递过来的DecorView，最终实现从的DecorView开始一级一级传递。  host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); ... }   由此可以看出getWith()最初是和getMeasuredWidth()有关系的，正常情况两者是一致的。但不是绝对的，你非要让其不一样也是可以的。\n  总结：由于setFrame设置的是控件显示的范围，setMeasuredDimension()设置的是控件测量出来自身需要的尺寸的值。所以with/height代表的是最终控件显示的范围，measuredWidth/measuredheight代表的是理想的测量值\n参考：\n Android 4.3中的视觉边界布局(Optical bounds layout)  "
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%87%AA%E5%AE%9A%E4%B9%89view-pulllayout/",
	"title": "自定义View-PullLayout",
	"tags": ["android", "自定义view"],
	"categories": [],
	"series": ["自定义view"],
	"description": "自定义高可用，易扩展下拉刷新上拉加载空间",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF/",
	"title": "贝塞尔曲线(Bezier curve)",
	"tags": ["编程基础", "android"],
	"categories": [],
	"series": [],
	"description": "贝塞尔曲线详解",
	"content": "前置知识 Bezier曲线是用一系列点控制曲线状态的，主要分为：\n 数据点 确定曲线的起始和结束位置 控制点 确定曲线的弯曲程度  其中数据点又叫锚点，只有起始和结束两个点，控制点有0～n个，按控制点个数可分为一阶贝塞尔曲线，二阶贝塞尔曲线，三阶贝塞尔曲线，\u0026hellip;，N阶贝塞尔曲线\n一阶贝塞尔曲线 0个控制点 即为一条直线\n给定点P0，P1，其中初始点P0，结束点P1，t为比率，在P0，P1上取一点D，D即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=t $$\n一阶比较简单我们作为例子演算出公式，上面的表达式可改写为：\n$$ \\frac{D-P_0}{P_1-P_0}=t $$\n再进一步演算为：\n$$ D=t*({P_1-P_0})+P_0 $$\nD记为B(t)，推出公式：\n$$ B(t)=(1-t)P_0+tP_1,t{\\in}[0,1] $$\n二阶贝塞尔曲线(quadratic Bezier curve) 1个控制点\n给定点P0，P1，P2，其中初始点P0，结束点P2，控制点P1，t为比率，在P0P1上取一点D，P1P2取一点E，在DE上取一点F，F即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=\\frac{P_1E}{P_1P_2}=\\frac{DF}{DE}=t $$\n推出公式：\n$$ B(t)=(1-t)^2P_0+2t(1-t)P_1+t^2P_2,t{\\in}[0,1] $$\n三阶贝塞尔曲线(cubic Bezier curve) 2个控制点\n给定点P0，P1，P2，P3，其中初始点P0，结束点P3，控制点P1，P2，t为比率，在P0P1上取一点D，P1P2取一点E，P2P3取一点F，在DE上取一点G，在EF上取一点H，在GH上取一点I，I即为曲线上的点，使得：\n$$ \\frac{P_0D}{P_0P_1}=\\frac{P_1E}{P_1P_2}=\\frac{P_2F}{P_2P_3}=\\frac{DG}{DE}=\\frac{EH}{EF}=\\frac{GI}{GH}=t $$\n推出公式：\n$$ B(t)=(1-t)^3P_0+3P_1t(1-t)^2+3P_2t^2(1-t)+P_3t^3,t{\\in}[0,1] $$\n多阶贝塞尔曲线 \u0026hellip;\n贝塞尔曲线的意义 确定初始点和结束点，很容易利用控制点得到一条曲线，控制简单。因此贝塞尔曲线在Android动画中有很多应用,比如Android中的PathInterpolator,PathInterpolator初始点是(0,0)，结束点是(1,1)，构造方法中传入控制点\n参考：\n cubic-bezier  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/",
	"title": "音视频",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/",
	"title": "音视频",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/about/",
	"title": "关于",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Hugo, dshcao about",
	"content": "  GitHub.\n  掘金.\n  微博.\n  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/css/",
	"title": "css",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/html/",
	"title": "html",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/markdown/",
	"title": "markdown",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/markdown-syntax/",
	"title": "Markdown Syntax Guide",
	"tags": ["markdown", "css", "html", "themes"],
	"categories": [],
	"series": ["Themes Guide"],
	"description": "Sample article showcasing basic Markdown syntax and formatting for HTML elements.",
	"content": "This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don't communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren't part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo's internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike's talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  "
},
{
	"uri": "https://dshcao.github.io/zh/categories/syntax/",
	"title": "syntax",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/themes/",
	"title": "themes",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/themes/",
	"title": "themes",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/themes-guide/",
	"title": "Themes Guide",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/privacy/",
	"title": "privacy",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/rich-content/",
	"title": "Rich Content",
	"tags": ["shortcodes", "privacy"],
	"categories": [],
	"series": [],
	"description": "A brief description of Hugo Shortcodes",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/shortcodes/",
	"title": "shortcodes",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/math-typesetting/",
	"title": "Math Typesetting",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "A brief guide to setup KaTeX",
	"content": "Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:  {{ if or .Params.math .Site.Params.math }} {{ partial \u0026quot;math.html\u0026quot; . }} {{ end }}  To enable KaTex globally set the parameter math to true in a project's configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions\nInline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$\nExamples Inline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$\nBlock math:\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } }\n$$\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/amoji/",
	"title": "amoji",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/bamoji/",
	"title": "bamoji",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/emoji/",
	"title": "emoji",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/emoji-support/",
	"title": "Emoji Support",
	"tags": ["emoji", "gamoji", "namoji", "bamoji", "amoji"],
	"categories": [],
	"series": [],
	"description": "Guide to emoji usage in Hugo",
	"content": "Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  "
},
{
	"uri": "https://dshcao.github.io/zh/tags/gamoji/",
	"title": "gamoji",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/namoji/",
	"title": "namoji",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/diagram/",
	"title": "diagram",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/test-viz/",
	"title": "Viz support",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "A hack to put Graphviz on the web.",
	"content": "digraph G { subgraph cluster_0 { style=filled; color=lightgrey; node [style=filled,color=white]; a0 -\u0026gt; a1 -\u0026gt; a2 -\u0026gt; a3; label = \u0026quot;process #1\u0026quot;; } subgraph cluster_1 { node [style=filled]; b0 -\u0026gt; b1 -\u0026gt; b2 -\u0026gt; b3; label = \u0026quot;process #2\u0026quot;; color=blue } start -\u0026gt; a0; start -\u0026gt; b0; a1 -\u0026gt; b3; b2 -\u0026gt; a3; a3 -\u0026gt; a0; a3 -\u0026gt; end; b3 -\u0026gt; end; start [shape=Mdiamond]; end [shape=Msquare]; } "
},
{
	"uri": "https://dshcao.github.io/zh/posts/test-wavedrom/",
	"title": "Wavedrom support",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "WaveDrom is a Free and Open Source online digital timing diagram (waveform) rendering engine that uses javascript, HTML5 and SVG to convert a WaveJSON input text description into SVG vector graphics.",
	"content": "{ \u0026quot;signal\u0026quot;: [ {\u0026quot;name\u0026quot;: \u0026quot;CLK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;p.....|...\u0026quot;}, {\u0026quot;name\u0026quot;:\u0026quot;DAT\u0026quot;, \u0026quot;wave\u0026quot;:\u0026quot;x.345x|=.x\u0026quot;, \u0026quot;data\u0026quot;:[\u0026quot;A\u0026quot;,\u0026quot;B\u0026quot;,\u0026quot;C\u0026quot;,\u0026quot;D\u0026quot;]}, {\u0026quot;name\u0026quot;: \u0026quot;REQ\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;0.1..0|1.0\u0026quot;}, {}, {\u0026quot;name\u0026quot;: \u0026quot;ACK\u0026quot;, \u0026quot;wave\u0026quot;: \u0026quot;1.....|01.\u0026quot;} ]} "
},
{
	"uri": "https://dshcao.github.io/zh/posts/test-chartjs/",
	"title": "Chart support",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Simple yet flexible JavaScript charting for designers &amp; developers",
	"content": "{ \u0026quot;type\u0026quot;: \u0026quot;bar\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;], \u0026quot;datasets\u0026quot;: [{ \u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;, \u0026quot;data\u0026quot;: [12, 19, 3, 5, 3, 8] }] } } { \u0026quot;type\u0026quot;: \u0026quot;line\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;labels\u0026quot;: [\u0026quot;One\u0026quot;, \u0026quot;Two\u0026quot;, \u0026quot;Three\u0026quot;, \u0026quot;Four\u0026quot;, \u0026quot;Five\u0026quot;, \u0026quot;Six\u0026quot;], \u0026quot;datasets\u0026quot;: [ { \u0026quot;label\u0026quot;: \u0026quot;# of Votes\u0026quot;, \u0026quot;data\u0026quot;: [12, 19, 3, 5, 2, 3], \u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;, \u0026quot;borderColor\u0026quot;:\u0026quot;orange\u0026quot; }, { \u0026quot;label\u0026quot;: \u0026quot;Some other set\u0026quot;, \u0026quot;data\u0026quot;: [15, 8, 13, 5, 5, 9], \u0026quot;backgroundColor\u0026quot;:\u0026quot;transparent\u0026quot;, \u0026quot;borderColor\u0026quot;:\u0026quot;#44ccff\u0026quot; } ] } } "
},
{
	"uri": "https://dshcao.github.io/zh/posts/test-js-sequence-diagrams/",
	"title": "JS Sequence Diagram support",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Generates UML sequence diagrams from simple text",
	"content": "Alice-\u0026gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u0026gt;Alice: I am good thanks! Title: Here is a title A-\u0026gt;B: Normal line B--\u0026gt;C: Dashed line C-\u0026gt;\u0026gt;D: Open arrow D--\u0026gt;\u0026gt;A: Dashed open arrow "
},
{
	"uri": "https://dshcao.github.io/zh/tags/diagram/",
	"title": "diagram",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/test-mermaid/",
	"title": "Mermaid support",
	"tags": ["diagram"],
	"categories": [],
	"series": [""],
	"description": "Generate diagrams, charts, graphs or flows from markdown-like text via javascript.",
	"content": "graph TD; A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; graph TD; A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; graph TD; A--\u0026gt;B; A--\u0026gt;C; B--\u0026gt;D; C--\u0026gt;D; sequenceDiagram participant Alice participant Bob Alice-\u0026gt;John: Hello John, how are you? loop Healthcheck John-\u0026gt;John: Fight against hypochondria end Note right of John: Rational thoughts \u0026lt;br/\u0026gt;prevail... John--\u0026gt;Alice: Great! John-\u0026gt;Bob: How about you? Bob--\u0026gt;John: Jolly good! graph TD A[Hard] --\u0026gt;|Text| B(Round) B --\u0026gt; C{Decision} C --\u0026gt;|One| D[Result 1] C --\u0026gt;|Two| E[Result 2] gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d classDiagram Class01 \u0026lt;|-- AveryLongClass : Cool \u0026lt;\u0026lt;interface\u0026gt;\u0026gt; Class01 Class09 --\u0026gt; C2 : Where am i? Class09 --* C3 Class09 --|\u0026gt; Class07 Class07 : equals() Class07 : Object[] elementData Class01 : size() Class01 : int chimp Class01 : int gorilla class Class10 { \u0026lt;\u0026lt;service\u0026gt;\u0026gt; int id size() } stateDiagram [*] --\u0026gt; Still Still --\u0026gt; [*] Still --\u0026gt; Moving Moving --\u0026gt; Still Moving --\u0026gt; Crash Crash --\u0026gt; [*] pie \u0026quot;Dogs\u0026quot; : 386 \u0026quot;Cats\u0026quot; : 85 \u0026quot;Rats\u0026quot; : 15 "
},
{
	"uri": "https://dshcao.github.io/zh/categories/math/",
	"title": "math",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/posts/test-mathjax/",
	"title": "MathJax support",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "A JavaScript display engine for mathematics that works in all browsers.No more setup for readers. It just works.",
	"content": "When \\(a \\ne 0\\), there are two solutions to \\((ax^2 + bx + c = 0)\\) and they are\n\\[x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.\\]\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/test-katext/",
	"title": "Katex support",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "KaTeX is a fast, easy-to-use JavaScript library for TeX math rendering on the web.",
	"content": "The following\n$$ \\int_{a}^{b} x^2 dx $$\nIs an integral\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } }\n$$\nEnable Katex in the config file by setting the katex param to true. This will import the necessary Katex CSS/JS.\nSee the online reference of supported TeX functions.\nNote: For inline math to render correctly, your content file extension must be .mmark. See the official mmark site.\nInline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$ Inline math: $$ \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… $$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ Block math:\n$$\n\\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } }\n$$\n"
},
{
	"uri": "https://dshcao.github.io/zh/posts/test-flowchart/",
	"title": "Flowchart support",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "flowchart.js is a flowchart DSL and SVG render that runs in the browser and terminal. Nodes and connections are defined in separately so that nodes can be reused and connections can be quickly changed.",
	"content": "st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank] e=\u0026gt;end: End|future:\u0026gt;http://www.google.com op1=\u0026gt;operation: My Operation|past op2=\u0026gt;operation: Stuff|current sub1=\u0026gt;subroutine: My Subroutine|invalid cond=\u0026gt;condition: Yes or No?|approved:\u0026gt;http://www.google.com c2=\u0026gt;condition: Good idea|rejected io=\u0026gt;inputoutput: catch something...|future st-\u0026gt;op1(right)-\u0026gt;cond cond(yes, right)-\u0026gt;c2 cond(no)-\u0026gt;sub1(left)-\u0026gt;op1 c2(yes)-\u0026gt;io-\u0026gt;e c2(no)-\u0026gt;op2-\u0026gt;e "
},
{
	"uri": "https://dshcao.github.io/zh/tags/%E9%9A%8F%E7%AC%94/",
	"title": "随笔",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/%E9%9A%8F%E7%AC%94/",
	"title": "随笔",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/",
	"title": "随笔",
	"tags": ["index"],
	"categories": [],
	"series": [],
	"description": "Note page",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/android/%E9%9A%8F%E8%AE%B0/",
	"title": "随记",
	"tags": ["随笔"],
	"categories": [],
	"series": [""],
	"description": "小知识点",
	"content": "一、Manifest配置 allowBackup fullBackupContent https://developer.android.com/guide/topics/data/autobackup\nallowBackup配置用来开启停用自动备份\nfullBackupContent用来配置配分规则，如：android:fullBackupContent=\u0026rdquo;@xml/backup_rules\u0026rdquo;\n1 2 3 4 5 6 7 8 9  \u0026lt;!--backup_rules --\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;full-backup-content\u0026gt; \u0026lt;include domain=[\u0026#34;file\u0026#34; | \u0026#34;database\u0026#34; | \u0026#34;sharedpref\u0026#34; |\u0026#34;external\u0026#34; | \u0026#34;root\u0026#34;] path=\u0026#34;string\u0026#34; requiredFlags=[\u0026#34;clientSideEncryption\u0026#34; | \u0026#34;deviceToDeviceTransfer\u0026#34;] /\u0026gt; \u0026lt;exclude domain=[\u0026#34;file\u0026#34; | \u0026#34;database\u0026#34; | \u0026#34;sharedpref\u0026#34; |\u0026#34;external\u0026#34; | \u0026#34;root\u0026#34;] path=\u0026#34;string\u0026#34; /\u0026gt; \u0026lt;/full-backup-content\u0026gt;   另外还可实现BackupAgent应用于你的备份逻辑\n如何保证序列化和反序列化仍然是同一个对象？比如单例模式从而实现线程安全\nprotected Object readResolve() throws ObjectStreamException {\nreturn mInstance;\n}\n原因，看ObjectInputStream注释文档\ncustomized: any class-specific readObject, readObjectNoData, and readResolve methods defined by enum types are ignored during deserialization. Similarly, any serialPersistentFields or serialVersionUID field declarations are also ignored--all enum types have a fixed serialVersionUID of 0L. ObjectInputStream反序列化源码检测是否定义了readResolve()方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  if (obj != null \u0026amp;\u0026amp; handles.lookupException(passHandle) == null \u0026amp;\u0026amp; desc.hasReadResolveMethod()){ Object rep = desc.invokeReadResolve(obj); if (unshared \u0026amp;\u0026amp; rep.getClass().isArray()) { rep = cloneArray(rep); } if (rep != obj) { // Android-removed: ObjectInputFilter logic, to be reconsidered. http://b/110252929  /* // Filter the replacement object if (rep != null) { if (rep.getClass().isArray()) { filterCheck(rep.getClass(), Array.getLength(rep)); } else { filterCheck(rep.getClass(), -1); } } */ handles.setObject(passHandle, obj = rep); } }   suppressLayout suppressLayout(true)会将mSuppressLayout标志置为true时所有触发layout()操作不会执行真正的layout()，而是在layout()中将mLayoutCalledWhileSuppressed标志置为true，直到suppressLayout(false)重置mSuppressLayout标志时会触发执行一次requestLayout()，并将mLayoutCalledWhileSuppressed置为false\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /** * Tells this ViewGroup to suppress all layout() calls until layout * suppression is disabled with a later call to suppressLayout(false). * When layout suppression is disabled, a requestLayout() call is sent * if layout() was attempted while layout was being suppressed. */ public void suppressLayout(boolean suppress) { mSuppressLayout = suppress; if (!suppress) { if (mLayoutCalledWhileSuppressed) { requestLayout(); mLayoutCalledWhileSuppressed = false; } } }   getLocationOnScreen clipBounds finishActivity public void finishActivity(int requestCode)\nandroid:windowIsTranslucent=true 适配 Activity android:persistableMode=\u0026quot;persistAcrossReboots\u0026rdquo; PersistableBundle\nUniversal Android Music Player Sample\nhttps://github.com/android/uamp.git\nStackView的循环实现 "
},
{
	"uri": "https://dshcao.github.io/zh/posts/placeholder-text/",
	"title": "Placeholder Text",
	"tags": ["markdown", "text"],
	"categories": [],
	"series": [],
	"description": "Lorem Ipsum Dolor Si Amet",
	"content": "Lorem est tota propiore conpellat pectoribus de\npectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus inhospita parcite confusaque translucet patri vestro qui optatis\nlumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus\nsilentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria\ntractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra\ndicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere\nfurit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli\nLelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare\nEchionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert\nausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae\nvulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem\nPropoetides parte.\n"
},
{
	"uri": "https://dshcao.github.io/zh/tags/text/",
	"title": "text",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/blogging/",
	"title": "Blogging",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/categories/ctest/",
	"title": "cTest",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/development/",
	"title": "Development",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/fast/",
	"title": "fast",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/tags/go/",
	"title": "Go",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/series/go-web-dev/",
	"title": "Go Web Dev",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-1/",
	"title": "Note-1",
	"tags": ["Development", "Go", "fast", "Blogging"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
	"content": "post-1 content\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec. Quisque metus tellus, tincidunt eu consequat consequat, placerat sed ante. Cras pulvinar eros ex, vel luctus eros viverra sed. Donec nec quam aliquam, ultricies neque sed, sollicitudin lorem. Aenean faucibus, velit et facilisis semper, leo tellus pellentesque orci, non suscipit libero ipsum sed lacus. Fusce pharetra arcu sed tellus convallis, vel hendrerit turpis rhoncus.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-2/",
	"title": "Note-2",
	"tags": ["Go", "fast", "Blogging"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis,",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/note-3/",
	"title": "Note-3",
	"tags": ["Development", "Go", "fast"],
	"categories": [],
	"series": ["Go Web Dev"],
	"description": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis,",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-1-1/go-1/",
	"title": "Go 1",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 1 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-2/",
	"title": "Go 2",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 2 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-4/",
	"title": "Go 4",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 4 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/go/go-1/go-1-1/go-1-1-1/go-5/",
	"title": "Go 5",
	"tags": [""],
	"categories": [],
	"series": [""],
	"description": "Go 5 Description",
	"content": "Dolore in consectetur irure qui laborum. Adipisicing cillum ad laboris dolor. Quis consectetur ullamco esse ad mollit anim sint nostrud esse. Irure voluptate ex fugiat voluptate ea fugiat laboris.\nVeniam deserunt ex ullamco laboris et elit culpa enim. Irure ipsum dolore sint nisi aliquip labore fugiat magna esse ad nostrud in. Eu aliqua mollit tempor proident pariatur voluptate.\n"
},
{
	"uri": "https://dshcao.github.io/zh/notes/java/",
	"title": "Java",
	"tags": [],
	"categories": [],
	"series": [],
	"description": "Note Sub List",
	"content": "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Ut eget enim lobortis, bibendum massa et, bibendum enim. Nunc eu augue quis ante porta sodales. Mauris vel faucibus magna, dictum sagittis dolor. Nam scelerisque malesuada efficitur. Donec consequat sodales justo, ut aliquam ligula maximus nec.\n"
}]